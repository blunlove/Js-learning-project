/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("/* globals __VUE_SSR_CONTEXT__ */\r\n\r\n// this module is a runtime utility for cleaner component module output and will\r\n// be included in the final webpack user bundle\r\n\r\nmodule.exports = function normalizeComponent (\r\n  rawScriptExports,\r\n  compiledTemplate,\r\n  injectStyles,\r\n  scopeId,\r\n  moduleIdentifier /* server only */\r\n) {\r\n  var esModule\r\n  var scriptExports = rawScriptExports = rawScriptExports || {}\r\n\r\n  // ES6 modules interop\r\n  var type = typeof rawScriptExports.default\r\n  if (type === 'object' || type === 'function') {\r\n    esModule = rawScriptExports\r\n    scriptExports = rawScriptExports.default\r\n  }\r\n\r\n  // Vue.extend constructor export interop\r\n  var options = typeof scriptExports === 'function'\r\n    ? scriptExports.options\r\n    : scriptExports\r\n\r\n  // render functions\r\n  if (compiledTemplate) {\r\n    options.render = compiledTemplate.render\r\n    options.staticRenderFns = compiledTemplate.staticRenderFns\r\n  }\r\n\r\n  // scopedId\r\n  if (scopeId) {\r\n    options._scopeId = scopeId\r\n  }\r\n\r\n  var hook\r\n  if (moduleIdentifier) { // server build\r\n    hook = function (context) {\r\n      // 2.3 injection\r\n      context =\r\n        context || // cached call\r\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\r\n      // 2.2 with runInNewContext: true\r\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n        context = __VUE_SSR_CONTEXT__\r\n      }\r\n      // inject component styles\r\n      if (injectStyles) {\r\n        injectStyles.call(this, context)\r\n      }\r\n      // register component module identifier for async chunk inferrence\r\n      if (context && context._registeredComponents) {\r\n        context._registeredComponents.add(moduleIdentifier)\r\n      }\r\n    }\r\n    // used by ssr in case component is cached and beforeCreate\r\n    // never gets called\r\n    options._ssrRegister = hook\r\n  } else if (injectStyles) {\r\n    hook = injectStyles\r\n  }\r\n\r\n  if (hook) {\r\n    var functional = options.functional\r\n    var existing = functional\r\n      ? options.render\r\n      : options.beforeCreate\r\n    if (!functional) {\r\n      // inject component registration as beforeCreate hook\r\n      options.beforeCreate = existing\r\n        ? [].concat(existing, hook)\r\n        : [hook]\r\n    } else {\r\n      // register for functioal component in vue file\r\n      options.render = function renderWithStyleInjection (h, context) {\r\n        hook.call(context)\r\n        return existing(h, context)\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    esModule: esModule,\r\n    exports: scriptExports,\r\n    options: options\r\n  }\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/NTU0ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXHJcblxyXG4vLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxyXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxyXG4gIHJhd1NjcmlwdEV4cG9ydHMsXHJcbiAgY29tcGlsZWRUZW1wbGF0ZSxcclxuICBpbmplY3RTdHlsZXMsXHJcbiAgc2NvcGVJZCxcclxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXHJcbikge1xyXG4gIHZhciBlc01vZHVsZVxyXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cclxuXHJcbiAgLy8gRVM2IG1vZHVsZXMgaW50ZXJvcFxyXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxyXG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBlc01vZHVsZSA9IHJhd1NjcmlwdEV4cG9ydHNcclxuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcclxuICB9XHJcblxyXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcclxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXHJcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xyXG4gICAgOiBzY3JpcHRFeHBvcnRzXHJcblxyXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcclxuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xyXG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZFRlbXBsYXRlLnN0YXRpY1JlbmRlckZuc1xyXG4gIH1cclxuXHJcbiAgLy8gc2NvcGVkSWRcclxuICBpZiAoc2NvcGVJZCkge1xyXG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcclxuICB9XHJcblxyXG4gIHZhciBob29rXHJcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXHJcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgLy8gMi4zIGluamVjdGlvblxyXG4gICAgICBjb250ZXh0ID1cclxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXHJcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXHJcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxyXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcclxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXHJcbiAgICAgIH1cclxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcclxuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xyXG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXHJcbiAgICAgIH1cclxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXHJcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XHJcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXHJcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxyXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXHJcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcclxuICAgIGhvb2sgPSBpbmplY3RTdHlsZXNcclxuICB9XHJcblxyXG4gIGlmIChob29rKSB7XHJcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxyXG4gICAgdmFyIGV4aXN0aW5nID0gZnVuY3Rpb25hbFxyXG4gICAgICA/IG9wdGlvbnMucmVuZGVyXHJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcclxuICAgIGlmICghZnVuY3Rpb25hbCkge1xyXG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xyXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXHJcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXHJcbiAgICAgICAgOiBbaG9va11cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXHJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXHJcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nKGgsIGNvbnRleHQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXHJcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxyXG4gICAgb3B0aW9uczogb3B0aW9uc1xyXG4gIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\r\n * Vue.js v2.4.4\r\n * (c) 2014-2017 Evan You\r\n * Released under the MIT License.\r\n */\r\n/*  */\r\n\r\n// these helpers produces better vm code in JS engines due to their\r\n// explicitness and function inlining\r\nfunction isUndef (v) {\r\n  return v === undefined || v === null\r\n}\r\n\r\nfunction isDef (v) {\r\n  return v !== undefined && v !== null\r\n}\r\n\r\nfunction isTrue (v) {\r\n  return v === true\r\n}\r\n\r\nfunction isFalse (v) {\r\n  return v === false\r\n}\r\n\r\n/**\r\n * Check if value is primitive\r\n */\r\nfunction isPrimitive (value) {\r\n  return (\r\n    typeof value === 'string' ||\r\n    typeof value === 'number' ||\r\n    typeof value === 'boolean'\r\n  )\r\n}\r\n\r\n/**\r\n * Quick object check - this is primarily used to tell\r\n * Objects from primitive values when we know the value\r\n * is a JSON-compliant type.\r\n */\r\nfunction isObject (obj) {\r\n  return obj !== null && typeof obj === 'object'\r\n}\r\n\r\nvar _toString = Object.prototype.toString;\r\n\r\n/**\r\n * Strict object type check. Only returns true\r\n * for plain JavaScript objects.\r\n */\r\nfunction isPlainObject (obj) {\r\n  return _toString.call(obj) === '[object Object]'\r\n}\r\n\r\nfunction isRegExp (v) {\r\n  return _toString.call(v) === '[object RegExp]'\r\n}\r\n\r\n/**\r\n * Check if val is a valid array index.\r\n */\r\nfunction isValidArrayIndex (val) {\r\n  var n = parseFloat(val);\r\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\r\n}\r\n\r\n/**\r\n * Convert a value to a string that is actually rendered.\r\n */\r\nfunction toString (val) {\r\n  return val == null\r\n    ? ''\r\n    : typeof val === 'object'\r\n      ? JSON.stringify(val, null, 2)\r\n      : String(val)\r\n}\r\n\r\n/**\r\n * Convert a input value to a number for persistence.\r\n * If the conversion fails, return original string.\r\n */\r\nfunction toNumber (val) {\r\n  var n = parseFloat(val);\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n */\r\nfunction makeMap (\r\n  str,\r\n  expectsLowerCase\r\n) {\r\n  var map = Object.create(null);\r\n  var list = str.split(',');\r\n  for (var i = 0; i < list.length; i++) {\r\n    map[list[i]] = true;\r\n  }\r\n  return expectsLowerCase\r\n    ? function (val) { return map[val.toLowerCase()]; }\r\n    : function (val) { return map[val]; }\r\n}\r\n\r\n/**\r\n * Check if a tag is a built-in tag.\r\n */\r\nvar isBuiltInTag = makeMap('slot,component', true);\r\n\r\n/**\r\n * Check if a attribute is a reserved attribute.\r\n */\r\nvar isReservedAttribute = makeMap('key,ref,slot,is');\r\n\r\n/**\r\n * Remove an item from an array\r\n */\r\nfunction remove (arr, item) {\r\n  if (arr.length) {\r\n    var index = arr.indexOf(item);\r\n    if (index > -1) {\r\n      return arr.splice(index, 1)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check whether the object has the property.\r\n */\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwn (obj, key) {\r\n  return hasOwnProperty.call(obj, key)\r\n}\r\n\r\n/**\r\n * Create a cached version of a pure function.\r\n */\r\nfunction cached (fn) {\r\n  var cache = Object.create(null);\r\n  return (function cachedFn (str) {\r\n    var hit = cache[str];\r\n    return hit || (cache[str] = fn(str))\r\n  })\r\n}\r\n\r\n/**\r\n * Camelize a hyphen-delimited string.\r\n */\r\nvar camelizeRE = /-(\\w)/g;\r\nvar camelize = cached(function (str) {\r\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\r\n});\r\n\r\n/**\r\n * Capitalize a string.\r\n */\r\nvar capitalize = cached(function (str) {\r\n  return str.charAt(0).toUpperCase() + str.slice(1)\r\n});\r\n\r\n/**\r\n * Hyphenate a camelCase string.\r\n */\r\nvar hyphenateRE = /\\B([A-Z])/g;\r\nvar hyphenate = cached(function (str) {\r\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\r\n});\r\n\r\n/**\r\n * Simple bind, faster than native\r\n */\r\nfunction bind (fn, ctx) {\r\n  function boundFn (a) {\r\n    var l = arguments.length;\r\n    return l\r\n      ? l > 1\r\n        ? fn.apply(ctx, arguments)\r\n        : fn.call(ctx, a)\r\n      : fn.call(ctx)\r\n  }\r\n  // record original fn length\r\n  boundFn._length = fn.length;\r\n  return boundFn\r\n}\r\n\r\n/**\r\n * Convert an Array-like object to a real Array.\r\n */\r\nfunction toArray (list, start) {\r\n  start = start || 0;\r\n  var i = list.length - start;\r\n  var ret = new Array(i);\r\n  while (i--) {\r\n    ret[i] = list[i + start];\r\n  }\r\n  return ret\r\n}\r\n\r\n/**\r\n * Mix properties into target object.\r\n */\r\nfunction extend (to, _from) {\r\n  for (var key in _from) {\r\n    to[key] = _from[key];\r\n  }\r\n  return to\r\n}\r\n\r\n/**\r\n * Merge an Array of Objects into a single Object.\r\n */\r\nfunction toObject (arr) {\r\n  var res = {};\r\n  for (var i = 0; i < arr.length; i++) {\r\n    if (arr[i]) {\r\n      extend(res, arr[i]);\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\n/**\r\n * Perform no operation.\r\n * Stubbing args to make Flow happy without leaving useless transpiled code\r\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\r\n */\r\nfunction noop (a, b, c) {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nvar no = function (a, b, c) { return false; };\r\n\r\n/**\r\n * Return same value\r\n */\r\nvar identity = function (_) { return _; };\r\n\r\n/**\r\n * Generate a static keys string from compiler modules.\r\n */\r\nfunction genStaticKeys (modules) {\r\n  return modules.reduce(function (keys, m) {\r\n    return keys.concat(m.staticKeys || [])\r\n  }, []).join(',')\r\n}\r\n\r\n/**\r\n * Check if two values are loosely equal - that is,\r\n * if they are plain objects, do they have the same shape?\r\n */\r\nfunction looseEqual (a, b) {\r\n  if (a === b) { return true }\r\n  var isObjectA = isObject(a);\r\n  var isObjectB = isObject(b);\r\n  if (isObjectA && isObjectB) {\r\n    try {\r\n      var isArrayA = Array.isArray(a);\r\n      var isArrayB = Array.isArray(b);\r\n      if (isArrayA && isArrayB) {\r\n        return a.length === b.length && a.every(function (e, i) {\r\n          return looseEqual(e, b[i])\r\n        })\r\n      } else if (!isArrayA && !isArrayB) {\r\n        var keysA = Object.keys(a);\r\n        var keysB = Object.keys(b);\r\n        return keysA.length === keysB.length && keysA.every(function (key) {\r\n          return looseEqual(a[key], b[key])\r\n        })\r\n      } else {\r\n        /* istanbul ignore next */\r\n        return false\r\n      }\r\n    } catch (e) {\r\n      /* istanbul ignore next */\r\n      return false\r\n    }\r\n  } else if (!isObjectA && !isObjectB) {\r\n    return String(a) === String(b)\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction looseIndexOf (arr, val) {\r\n  for (var i = 0; i < arr.length; i++) {\r\n    if (looseEqual(arr[i], val)) { return i }\r\n  }\r\n  return -1\r\n}\r\n\r\n/**\r\n * Ensure a function is called only once.\r\n */\r\nfunction once (fn) {\r\n  var called = false;\r\n  return function () {\r\n    if (!called) {\r\n      called = true;\r\n      fn.apply(this, arguments);\r\n    }\r\n  }\r\n}\r\n\r\nvar SSR_ATTR = 'data-server-rendered';\r\n\r\nvar ASSET_TYPES = [\r\n  'component',\r\n  'directive',\r\n  'filter'\r\n];\r\n\r\nvar LIFECYCLE_HOOKS = [\r\n  'beforeCreate',\r\n  'created',\r\n  'beforeMount',\r\n  'mounted',\r\n  'beforeUpdate',\r\n  'updated',\r\n  'beforeDestroy',\r\n  'destroyed',\r\n  'activated',\r\n  'deactivated'\r\n];\r\n\r\n/*  */\r\n\r\nvar config = ({\r\n  /**\r\n   * Option merge strategies (used in core/util/options)\r\n   */\r\n  optionMergeStrategies: Object.create(null),\r\n\r\n  /**\r\n   * Whether to suppress warnings.\r\n   */\r\n  silent: false,\r\n\r\n  /**\r\n   * Show production mode tip message on boot?\r\n   */\r\n  productionTip: process.env.NODE_ENV !== 'production',\r\n\r\n  /**\r\n   * Whether to enable devtools\r\n   */\r\n  devtools: process.env.NODE_ENV !== 'production',\r\n\r\n  /**\r\n   * Whether to record perf\r\n   */\r\n  performance: false,\r\n\r\n  /**\r\n   * Error handler for watcher errors\r\n   */\r\n  errorHandler: null,\r\n\r\n  /**\r\n   * Warn handler for watcher warns\r\n   */\r\n  warnHandler: null,\r\n\r\n  /**\r\n   * Ignore certain custom elements\r\n   */\r\n  ignoredElements: [],\r\n\r\n  /**\r\n   * Custom user key aliases for v-on\r\n   */\r\n  keyCodes: Object.create(null),\r\n\r\n  /**\r\n   * Check if a tag is reserved so that it cannot be registered as a\r\n   * component. This is platform-dependent and may be overwritten.\r\n   */\r\n  isReservedTag: no,\r\n\r\n  /**\r\n   * Check if an attribute is reserved so that it cannot be used as a component\r\n   * prop. This is platform-dependent and may be overwritten.\r\n   */\r\n  isReservedAttr: no,\r\n\r\n  /**\r\n   * Check if a tag is an unknown element.\r\n   * Platform-dependent.\r\n   */\r\n  isUnknownElement: no,\r\n\r\n  /**\r\n   * Get the namespace of an element\r\n   */\r\n  getTagNamespace: noop,\r\n\r\n  /**\r\n   * Parse the real tag name for the specific platform.\r\n   */\r\n  parsePlatformTagName: identity,\r\n\r\n  /**\r\n   * Check if an attribute must be bound using property, e.g. value\r\n   * Platform-dependent.\r\n   */\r\n  mustUseProp: no,\r\n\r\n  /**\r\n   * Exposed for legacy reasons\r\n   */\r\n  _lifecycleHooks: LIFECYCLE_HOOKS\r\n});\r\n\r\n/*  */\r\n\r\nvar emptyObject = Object.freeze({});\r\n\r\n/**\r\n * Check if a string starts with $ or _\r\n */\r\nfunction isReserved (str) {\r\n  var c = (str + '').charCodeAt(0);\r\n  return c === 0x24 || c === 0x5F\r\n}\r\n\r\n/**\r\n * Define a property.\r\n */\r\nfunction def (obj, key, val, enumerable) {\r\n  Object.defineProperty(obj, key, {\r\n    value: val,\r\n    enumerable: !!enumerable,\r\n    writable: true,\r\n    configurable: true\r\n  });\r\n}\r\n\r\n/**\r\n * Parse simple path.\r\n */\r\nvar bailRE = /[^\\w.$]/;\r\nfunction parsePath (path) {\r\n  if (bailRE.test(path)) {\r\n    return\r\n  }\r\n  var segments = path.split('.');\r\n  return function (obj) {\r\n    for (var i = 0; i < segments.length; i++) {\r\n      if (!obj) { return }\r\n      obj = obj[segments[i]];\r\n    }\r\n    return obj\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar warn = noop;\r\nvar tip = noop;\r\nvar formatComponentName = (null); // work around flow check\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  var hasConsole = typeof console !== 'undefined';\r\n  var classifyRE = /(?:^|[-_])(\\w)/g;\r\n  var classify = function (str) { return str\r\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\r\n    .replace(/[-_]/g, ''); };\r\n\r\n  warn = function (msg, vm) {\r\n    var trace = vm ? generateComponentTrace(vm) : '';\r\n\r\n    if (config.warnHandler) {\r\n      config.warnHandler.call(null, msg, vm, trace);\r\n    } else if (hasConsole && (!config.silent)) {\r\n      console.error((\"[Vue warn]: \" + msg + trace));\r\n    }\r\n  };\r\n\r\n  tip = function (msg, vm) {\r\n    if (hasConsole && (!config.silent)) {\r\n      console.warn(\"[Vue tip]: \" + msg + (\r\n        vm ? generateComponentTrace(vm) : ''\r\n      ));\r\n    }\r\n  };\r\n\r\n  formatComponentName = function (vm, includeFile) {\r\n    if (vm.$root === vm) {\r\n      return '<Root>'\r\n    }\r\n    var name = typeof vm === 'string'\r\n      ? vm\r\n      : typeof vm === 'function' && vm.options\r\n        ? vm.options.name\r\n        : vm._isVue\r\n          ? vm.$options.name || vm.$options._componentTag\r\n          : vm.name;\r\n\r\n    var file = vm._isVue && vm.$options.__file;\r\n    if (!name && file) {\r\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\r\n      name = match && match[1];\r\n    }\r\n\r\n    return (\r\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\r\n      (file && includeFile !== false ? (\" at \" + file) : '')\r\n    )\r\n  };\r\n\r\n  var repeat = function (str, n) {\r\n    var res = '';\r\n    while (n) {\r\n      if (n % 2 === 1) { res += str; }\r\n      if (n > 1) { str += str; }\r\n      n >>= 1;\r\n    }\r\n    return res\r\n  };\r\n\r\n  var generateComponentTrace = function (vm) {\r\n    if (vm._isVue && vm.$parent) {\r\n      var tree = [];\r\n      var currentRecursiveSequence = 0;\r\n      while (vm) {\r\n        if (tree.length > 0) {\r\n          var last = tree[tree.length - 1];\r\n          if (last.constructor === vm.constructor) {\r\n            currentRecursiveSequence++;\r\n            vm = vm.$parent;\r\n            continue\r\n          } else if (currentRecursiveSequence > 0) {\r\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\r\n            currentRecursiveSequence = 0;\r\n          }\r\n        }\r\n        tree.push(vm);\r\n        vm = vm.$parent;\r\n      }\r\n      return '\\n\\nfound in\\n\\n' + tree\r\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\r\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\r\n            : formatComponentName(vm))); })\r\n        .join('\\n')\r\n    } else {\r\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\r\n    }\r\n  };\r\n}\r\n\r\n/*  */\r\n\r\nfunction handleError (err, vm, info) {\r\n  if (config.errorHandler) {\r\n    config.errorHandler.call(null, err, vm, info);\r\n  } else {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\r\n    }\r\n    /* istanbul ignore else */\r\n    if (inBrowser && typeof console !== 'undefined') {\r\n      console.error(err);\r\n    } else {\r\n      throw err\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n/* globals MutationObserver */\r\n\r\n// can we use __proto__?\r\nvar hasProto = '__proto__' in {};\r\n\r\n// Browser environment sniffing\r\nvar inBrowser = typeof window !== 'undefined';\r\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\r\nvar isIE = UA && /msie|trident/.test(UA);\r\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\r\nvar isEdge = UA && UA.indexOf('edge/') > 0;\r\nvar isAndroid = UA && UA.indexOf('android') > 0;\r\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\r\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\r\n\r\n// Firefox has a \"watch\" function on Object.prototype...\r\nvar nativeWatch = ({}).watch;\r\n\r\nvar supportsPassive = false;\r\nif (inBrowser) {\r\n  try {\r\n    var opts = {};\r\n    Object.defineProperty(opts, 'passive', ({\r\n      get: function get () {\r\n        /* istanbul ignore next */\r\n        supportsPassive = true;\r\n      }\r\n    })); // https://github.com/facebook/flow/issues/285\r\n    window.addEventListener('test-passive', null, opts);\r\n  } catch (e) {}\r\n}\r\n\r\n// this needs to be lazy-evaled because vue may be required before\r\n// vue-server-renderer can set VUE_ENV\r\nvar _isServer;\r\nvar isServerRendering = function () {\r\n  if (_isServer === undefined) {\r\n    /* istanbul ignore if */\r\n    if (!inBrowser && typeof global !== 'undefined') {\r\n      // detect presence of vue-server-renderer and avoid\r\n      // Webpack shimming the process\r\n      _isServer = global['process'].env.VUE_ENV === 'server';\r\n    } else {\r\n      _isServer = false;\r\n    }\r\n  }\r\n  return _isServer\r\n};\r\n\r\n// detect devtools\r\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\r\n\r\n/* istanbul ignore next */\r\nfunction isNative (Ctor) {\r\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\r\n}\r\n\r\nvar hasSymbol =\r\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\r\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\r\n\r\n/**\r\n * Defer a task to execute it asynchronously.\r\n */\r\nvar nextTick = (function () {\r\n  var callbacks = [];\r\n  var pending = false;\r\n  var timerFunc;\r\n\r\n  function nextTickHandler () {\r\n    pending = false;\r\n    var copies = callbacks.slice(0);\r\n    callbacks.length = 0;\r\n    for (var i = 0; i < copies.length; i++) {\r\n      copies[i]();\r\n    }\r\n  }\r\n\r\n  // the nextTick behavior leverages the microtask queue, which can be accessed\r\n  // via either native Promise.then or MutationObserver.\r\n  // MutationObserver has wider support, however it is seriously bugged in\r\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\r\n  // completely stops working after triggering a few times... so, if native\r\n  // Promise is available, we will use it:\r\n  /* istanbul ignore if */\r\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\r\n    var p = Promise.resolve();\r\n    var logError = function (err) { console.error(err); };\r\n    timerFunc = function () {\r\n      p.then(nextTickHandler).catch(logError);\r\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\r\n      // it can get stuck in a weird state where callbacks are pushed into the\r\n      // microtask queue but the queue isn't being flushed, until the browser\r\n      // needs to do some other work, e.g. handle a timer. Therefore we can\r\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\r\n      if (isIOS) { setTimeout(noop); }\r\n    };\r\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\r\n    isNative(MutationObserver) ||\r\n    // PhantomJS and iOS 7.x\r\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\r\n  )) {\r\n    // use MutationObserver where native Promise is not available,\r\n    // e.g. PhantomJS, iOS7, Android 4.4\r\n    var counter = 1;\r\n    var observer = new MutationObserver(nextTickHandler);\r\n    var textNode = document.createTextNode(String(counter));\r\n    observer.observe(textNode, {\r\n      characterData: true\r\n    });\r\n    timerFunc = function () {\r\n      counter = (counter + 1) % 2;\r\n      textNode.data = String(counter);\r\n    };\r\n  } else {\r\n    // fallback to setTimeout\r\n    /* istanbul ignore next */\r\n    timerFunc = function () {\r\n      setTimeout(nextTickHandler, 0);\r\n    };\r\n  }\r\n\r\n  return function queueNextTick (cb, ctx) {\r\n    var _resolve;\r\n    callbacks.push(function () {\r\n      if (cb) {\r\n        try {\r\n          cb.call(ctx);\r\n        } catch (e) {\r\n          handleError(e, ctx, 'nextTick');\r\n        }\r\n      } else if (_resolve) {\r\n        _resolve(ctx);\r\n      }\r\n    });\r\n    if (!pending) {\r\n      pending = true;\r\n      timerFunc();\r\n    }\r\n    if (!cb && typeof Promise !== 'undefined') {\r\n      return new Promise(function (resolve, reject) {\r\n        _resolve = resolve;\r\n      })\r\n    }\r\n  }\r\n})();\r\n\r\nvar _Set;\r\n/* istanbul ignore if */\r\nif (typeof Set !== 'undefined' && isNative(Set)) {\r\n  // use native Set when available.\r\n  _Set = Set;\r\n} else {\r\n  // a non-standard Set polyfill that only works with primitive keys.\r\n  _Set = (function () {\r\n    function Set () {\r\n      this.set = Object.create(null);\r\n    }\r\n    Set.prototype.has = function has (key) {\r\n      return this.set[key] === true\r\n    };\r\n    Set.prototype.add = function add (key) {\r\n      this.set[key] = true;\r\n    };\r\n    Set.prototype.clear = function clear () {\r\n      this.set = Object.create(null);\r\n    };\r\n\r\n    return Set;\r\n  }());\r\n}\r\n\r\n/*  */\r\n\r\n\r\nvar uid = 0;\r\n\r\n/**\r\n * A dep is an observable that can have multiple\r\n * directives subscribing to it.\r\n */\r\nvar Dep = function Dep () {\r\n  this.id = uid++;\r\n  this.subs = [];\r\n};\r\n\r\nDep.prototype.addSub = function addSub (sub) {\r\n  this.subs.push(sub);\r\n};\r\n\r\nDep.prototype.removeSub = function removeSub (sub) {\r\n  remove(this.subs, sub);\r\n};\r\n\r\nDep.prototype.depend = function depend () {\r\n  if (Dep.target) {\r\n    Dep.target.addDep(this);\r\n  }\r\n};\r\n\r\nDep.prototype.notify = function notify () {\r\n  // stabilize the subscriber list first\r\n  var subs = this.subs.slice();\r\n  for (var i = 0, l = subs.length; i < l; i++) {\r\n    subs[i].update();\r\n  }\r\n};\r\n\r\n// the current target watcher being evaluated.\r\n// this is globally unique because there could be only one\r\n// watcher being evaluated at any time.\r\nDep.target = null;\r\nvar targetStack = [];\r\n\r\nfunction pushTarget (_target) {\r\n  if (Dep.target) { targetStack.push(Dep.target); }\r\n  Dep.target = _target;\r\n}\r\n\r\nfunction popTarget () {\r\n  Dep.target = targetStack.pop();\r\n}\r\n\r\n/*\r\n * not type checking this file because flow doesn't play well with\r\n * dynamically accessing methods on Array prototype\r\n */\r\n\r\nvar arrayProto = Array.prototype;\r\nvar arrayMethods = Object.create(arrayProto);[\r\n  'push',\r\n  'pop',\r\n  'shift',\r\n  'unshift',\r\n  'splice',\r\n  'sort',\r\n  'reverse'\r\n]\r\n.forEach(function (method) {\r\n  // cache original method\r\n  var original = arrayProto[method];\r\n  def(arrayMethods, method, function mutator () {\r\n    var args = [], len = arguments.length;\r\n    while ( len-- ) args[ len ] = arguments[ len ];\r\n\r\n    var result = original.apply(this, args);\r\n    var ob = this.__ob__;\r\n    var inserted;\r\n    switch (method) {\r\n      case 'push':\r\n      case 'unshift':\r\n        inserted = args;\r\n        break\r\n      case 'splice':\r\n        inserted = args.slice(2);\r\n        break\r\n    }\r\n    if (inserted) { ob.observeArray(inserted); }\r\n    // notify change\r\n    ob.dep.notify();\r\n    return result\r\n  });\r\n});\r\n\r\n/*  */\r\n\r\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\r\n\r\n/**\r\n * By default, when a reactive property is set, the new value is\r\n * also converted to become reactive. However when passing down props,\r\n * we don't want to force conversion because the value may be a nested value\r\n * under a frozen data structure. Converting it would defeat the optimization.\r\n */\r\nvar observerState = {\r\n  shouldConvert: true\r\n};\r\n\r\n/**\r\n * Observer class that are attached to each observed\r\n * object. Once attached, the observer converts target\r\n * object's property keys into getter/setters that\r\n * collect dependencies and dispatches updates.\r\n */\r\nvar Observer = function Observer (value) {\r\n  this.value = value;\r\n  this.dep = new Dep();\r\n  this.vmCount = 0;\r\n  def(value, '__ob__', this);\r\n  if (Array.isArray(value)) {\r\n    var augment = hasProto\r\n      ? protoAugment\r\n      : copyAugment;\r\n    augment(value, arrayMethods, arrayKeys);\r\n    this.observeArray(value);\r\n  } else {\r\n    this.walk(value);\r\n  }\r\n};\r\n\r\n/**\r\n * Walk through each property and convert them into\r\n * getter/setters. This method should only be called when\r\n * value type is Object.\r\n */\r\nObserver.prototype.walk = function walk (obj) {\r\n  var keys = Object.keys(obj);\r\n  for (var i = 0; i < keys.length; i++) {\r\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\r\n  }\r\n};\r\n\r\n/**\r\n * Observe a list of Array items.\r\n */\r\nObserver.prototype.observeArray = function observeArray (items) {\r\n  for (var i = 0, l = items.length; i < l; i++) {\r\n    observe(items[i]);\r\n  }\r\n};\r\n\r\n// helpers\r\n\r\n/**\r\n * Augment an target Object or Array by intercepting\r\n * the prototype chain using __proto__\r\n */\r\nfunction protoAugment (target, src, keys) {\r\n  /* eslint-disable no-proto */\r\n  target.__proto__ = src;\r\n  /* eslint-enable no-proto */\r\n}\r\n\r\n/**\r\n * Augment an target Object or Array by defining\r\n * hidden properties.\r\n */\r\n/* istanbul ignore next */\r\nfunction copyAugment (target, src, keys) {\r\n  for (var i = 0, l = keys.length; i < l; i++) {\r\n    var key = keys[i];\r\n    def(target, key, src[key]);\r\n  }\r\n}\r\n\r\n/**\r\n * Attempt to create an observer instance for a value,\r\n * returns the new observer if successfully observed,\r\n * or the existing observer if the value already has one.\r\n */\r\nfunction observe (value, asRootData) {\r\n  if (!isObject(value)) {\r\n    return\r\n  }\r\n  var ob;\r\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\r\n    ob = value.__ob__;\r\n  } else if (\r\n    observerState.shouldConvert &&\r\n    !isServerRendering() &&\r\n    (Array.isArray(value) || isPlainObject(value)) &&\r\n    Object.isExtensible(value) &&\r\n    !value._isVue\r\n  ) {\r\n    ob = new Observer(value);\r\n  }\r\n  if (asRootData && ob) {\r\n    ob.vmCount++;\r\n  }\r\n  return ob\r\n}\r\n\r\n/**\r\n * Define a reactive property on an Object.\r\n */\r\nfunction defineReactive$$1 (\r\n  obj,\r\n  key,\r\n  val,\r\n  customSetter,\r\n  shallow\r\n) {\r\n  var dep = new Dep();\r\n\r\n  var property = Object.getOwnPropertyDescriptor(obj, key);\r\n  if (property && property.configurable === false) {\r\n    return\r\n  }\r\n\r\n  // cater for pre-defined getter/setters\r\n  var getter = property && property.get;\r\n  var setter = property && property.set;\r\n\r\n  var childOb = !shallow && observe(val);\r\n  Object.defineProperty(obj, key, {\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: function reactiveGetter () {\r\n      var value = getter ? getter.call(obj) : val;\r\n      if (Dep.target) {\r\n        dep.depend();\r\n        if (childOb) {\r\n          childOb.dep.depend();\r\n          if (Array.isArray(value)) {\r\n            dependArray(value);\r\n          }\r\n        }\r\n      }\r\n      return value\r\n    },\r\n    set: function reactiveSetter (newVal) {\r\n      var value = getter ? getter.call(obj) : val;\r\n      /* eslint-disable no-self-compare */\r\n      if (newVal === value || (newVal !== newVal && value !== value)) {\r\n        return\r\n      }\r\n      /* eslint-enable no-self-compare */\r\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\r\n        customSetter();\r\n      }\r\n      if (setter) {\r\n        setter.call(obj, newVal);\r\n      } else {\r\n        val = newVal;\r\n      }\r\n      childOb = !shallow && observe(newVal);\r\n      dep.notify();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Set a property on an object. Adds the new property and\r\n * triggers change notification if the property doesn't\r\n * already exist.\r\n */\r\nfunction set (target, key, val) {\r\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\r\n    target.length = Math.max(target.length, key);\r\n    target.splice(key, 1, val);\r\n    return val\r\n  }\r\n  if (hasOwn(target, key)) {\r\n    target[key] = val;\r\n    return val\r\n  }\r\n  var ob = (target).__ob__;\r\n  if (target._isVue || (ob && ob.vmCount)) {\r\n    process.env.NODE_ENV !== 'production' && warn(\r\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\r\n      'at runtime - declare it upfront in the data option.'\r\n    );\r\n    return val\r\n  }\r\n  if (!ob) {\r\n    target[key] = val;\r\n    return val\r\n  }\r\n  defineReactive$$1(ob.value, key, val);\r\n  ob.dep.notify();\r\n  return val\r\n}\r\n\r\n/**\r\n * Delete a property and trigger change if necessary.\r\n */\r\nfunction del (target, key) {\r\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\r\n    target.splice(key, 1);\r\n    return\r\n  }\r\n  var ob = (target).__ob__;\r\n  if (target._isVue || (ob && ob.vmCount)) {\r\n    process.env.NODE_ENV !== 'production' && warn(\r\n      'Avoid deleting properties on a Vue instance or its root $data ' +\r\n      '- just set it to null.'\r\n    );\r\n    return\r\n  }\r\n  if (!hasOwn(target, key)) {\r\n    return\r\n  }\r\n  delete target[key];\r\n  if (!ob) {\r\n    return\r\n  }\r\n  ob.dep.notify();\r\n}\r\n\r\n/**\r\n * Collect dependencies on array elements when the array is touched, since\r\n * we cannot intercept array element access like property getters.\r\n */\r\nfunction dependArray (value) {\r\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\r\n    e = value[i];\r\n    e && e.__ob__ && e.__ob__.dep.depend();\r\n    if (Array.isArray(e)) {\r\n      dependArray(e);\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Option overwriting strategies are functions that handle\r\n * how to merge a parent option value and a child option\r\n * value into the final value.\r\n */\r\nvar strats = config.optionMergeStrategies;\r\n\r\n/**\r\n * Options with restrictions\r\n */\r\nif (process.env.NODE_ENV !== 'production') {\r\n  strats.el = strats.propsData = function (parent, child, vm, key) {\r\n    if (!vm) {\r\n      warn(\r\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\r\n        'creation with the `new` keyword.'\r\n      );\r\n    }\r\n    return defaultStrat(parent, child)\r\n  };\r\n}\r\n\r\n/**\r\n * Helper that recursively merges two data objects together.\r\n */\r\nfunction mergeData (to, from) {\r\n  if (!from) { return to }\r\n  var key, toVal, fromVal;\r\n  var keys = Object.keys(from);\r\n  for (var i = 0; i < keys.length; i++) {\r\n    key = keys[i];\r\n    toVal = to[key];\r\n    fromVal = from[key];\r\n    if (!hasOwn(to, key)) {\r\n      set(to, key, fromVal);\r\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\r\n      mergeData(toVal, fromVal);\r\n    }\r\n  }\r\n  return to\r\n}\r\n\r\n/**\r\n * Data\r\n */\r\nfunction mergeDataOrFn (\r\n  parentVal,\r\n  childVal,\r\n  vm\r\n) {\r\n  if (!vm) {\r\n    // in a Vue.extend merge, both should be functions\r\n    if (!childVal) {\r\n      return parentVal\r\n    }\r\n    if (!parentVal) {\r\n      return childVal\r\n    }\r\n    // when parentVal & childVal are both present,\r\n    // we need to return a function that returns the\r\n    // merged result of both functions... no need to\r\n    // check if parentVal is a function here because\r\n    // it has to be a function to pass previous merges.\r\n    return function mergedDataFn () {\r\n      return mergeData(\r\n        typeof childVal === 'function' ? childVal.call(this) : childVal,\r\n        typeof parentVal === 'function' ? parentVal.call(this) : parentVal\r\n      )\r\n    }\r\n  } else if (parentVal || childVal) {\r\n    return function mergedInstanceDataFn () {\r\n      // instance merge\r\n      var instanceData = typeof childVal === 'function'\r\n        ? childVal.call(vm)\r\n        : childVal;\r\n      var defaultData = typeof parentVal === 'function'\r\n        ? parentVal.call(vm)\r\n        : parentVal;\r\n      if (instanceData) {\r\n        return mergeData(instanceData, defaultData)\r\n      } else {\r\n        return defaultData\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nstrats.data = function (\r\n  parentVal,\r\n  childVal,\r\n  vm\r\n) {\r\n  if (!vm) {\r\n    if (childVal && typeof childVal !== 'function') {\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        'The \"data\" option should be a function ' +\r\n        'that returns a per-instance value in component ' +\r\n        'definitions.',\r\n        vm\r\n      );\r\n\r\n      return parentVal\r\n    }\r\n    return mergeDataOrFn.call(this, parentVal, childVal)\r\n  }\r\n\r\n  return mergeDataOrFn(parentVal, childVal, vm)\r\n};\r\n\r\n/**\r\n * Hooks and props are merged as arrays.\r\n */\r\nfunction mergeHook (\r\n  parentVal,\r\n  childVal\r\n) {\r\n  return childVal\r\n    ? parentVal\r\n      ? parentVal.concat(childVal)\r\n      : Array.isArray(childVal)\r\n        ? childVal\r\n        : [childVal]\r\n    : parentVal\r\n}\r\n\r\nLIFECYCLE_HOOKS.forEach(function (hook) {\r\n  strats[hook] = mergeHook;\r\n});\r\n\r\n/**\r\n * Assets\r\n *\r\n * When a vm is present (instance creation), we need to do\r\n * a three-way merge between constructor options, instance\r\n * options and parent options.\r\n */\r\nfunction mergeAssets (parentVal, childVal) {\r\n  var res = Object.create(parentVal || null);\r\n  return childVal\r\n    ? extend(res, childVal)\r\n    : res\r\n}\r\n\r\nASSET_TYPES.forEach(function (type) {\r\n  strats[type + 's'] = mergeAssets;\r\n});\r\n\r\n/**\r\n * Watchers.\r\n *\r\n * Watchers hashes should not overwrite one\r\n * another, so we merge them as arrays.\r\n */\r\nstrats.watch = function (parentVal, childVal) {\r\n  // work around Firefox's Object.prototype.watch...\r\n  if (parentVal === nativeWatch) { parentVal = undefined; }\r\n  if (childVal === nativeWatch) { childVal = undefined; }\r\n  /* istanbul ignore if */\r\n  if (!childVal) { return Object.create(parentVal || null) }\r\n  if (!parentVal) { return childVal }\r\n  var ret = {};\r\n  extend(ret, parentVal);\r\n  for (var key in childVal) {\r\n    var parent = ret[key];\r\n    var child = childVal[key];\r\n    if (parent && !Array.isArray(parent)) {\r\n      parent = [parent];\r\n    }\r\n    ret[key] = parent\r\n      ? parent.concat(child)\r\n      : Array.isArray(child) ? child : [child];\r\n  }\r\n  return ret\r\n};\r\n\r\n/**\r\n * Other object hashes.\r\n */\r\nstrats.props =\r\nstrats.methods =\r\nstrats.inject =\r\nstrats.computed = function (parentVal, childVal) {\r\n  if (!parentVal) { return childVal }\r\n  var ret = Object.create(null);\r\n  extend(ret, parentVal);\r\n  if (childVal) { extend(ret, childVal); }\r\n  return ret\r\n};\r\nstrats.provide = mergeDataOrFn;\r\n\r\n/**\r\n * Default strategy.\r\n */\r\nvar defaultStrat = function (parentVal, childVal) {\r\n  return childVal === undefined\r\n    ? parentVal\r\n    : childVal\r\n};\r\n\r\n/**\r\n * Validate component names\r\n */\r\nfunction checkComponents (options) {\r\n  for (var key in options.components) {\r\n    var lower = key.toLowerCase();\r\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\r\n      warn(\r\n        'Do not use built-in or reserved HTML elements as component ' +\r\n        'id: ' + key\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure all props option syntax are normalized into the\r\n * Object-based format.\r\n */\r\nfunction normalizeProps (options) {\r\n  var props = options.props;\r\n  if (!props) { return }\r\n  var res = {};\r\n  var i, val, name;\r\n  if (Array.isArray(props)) {\r\n    i = props.length;\r\n    while (i--) {\r\n      val = props[i];\r\n      if (typeof val === 'string') {\r\n        name = camelize(val);\r\n        res[name] = { type: null };\r\n      } else if (process.env.NODE_ENV !== 'production') {\r\n        warn('props must be strings when using array syntax.');\r\n      }\r\n    }\r\n  } else if (isPlainObject(props)) {\r\n    for (var key in props) {\r\n      val = props[key];\r\n      name = camelize(key);\r\n      res[name] = isPlainObject(val)\r\n        ? val\r\n        : { type: val };\r\n    }\r\n  }\r\n  options.props = res;\r\n}\r\n\r\n/**\r\n * Normalize all injections into Object-based format\r\n */\r\nfunction normalizeInject (options) {\r\n  var inject = options.inject;\r\n  if (Array.isArray(inject)) {\r\n    var normalized = options.inject = {};\r\n    for (var i = 0; i < inject.length; i++) {\r\n      normalized[inject[i]] = inject[i];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Normalize raw function directives into object format.\r\n */\r\nfunction normalizeDirectives (options) {\r\n  var dirs = options.directives;\r\n  if (dirs) {\r\n    for (var key in dirs) {\r\n      var def = dirs[key];\r\n      if (typeof def === 'function') {\r\n        dirs[key] = { bind: def, update: def };\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Merge two option objects into a new one.\r\n * Core utility used in both instantiation and inheritance.\r\n */\r\nfunction mergeOptions (\r\n  parent,\r\n  child,\r\n  vm\r\n) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    checkComponents(child);\r\n  }\r\n\r\n  if (typeof child === 'function') {\r\n    child = child.options;\r\n  }\r\n\r\n  normalizeProps(child);\r\n  normalizeInject(child);\r\n  normalizeDirectives(child);\r\n  var extendsFrom = child.extends;\r\n  if (extendsFrom) {\r\n    parent = mergeOptions(parent, extendsFrom, vm);\r\n  }\r\n  if (child.mixins) {\r\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\r\n      parent = mergeOptions(parent, child.mixins[i], vm);\r\n    }\r\n  }\r\n  var options = {};\r\n  var key;\r\n  for (key in parent) {\r\n    mergeField(key);\r\n  }\r\n  for (key in child) {\r\n    if (!hasOwn(parent, key)) {\r\n      mergeField(key);\r\n    }\r\n  }\r\n  function mergeField (key) {\r\n    var strat = strats[key] || defaultStrat;\r\n    options[key] = strat(parent[key], child[key], vm, key);\r\n  }\r\n  return options\r\n}\r\n\r\n/**\r\n * Resolve an asset.\r\n * This function is used because child instances need access\r\n * to assets defined in its ancestor chain.\r\n */\r\nfunction resolveAsset (\r\n  options,\r\n  type,\r\n  id,\r\n  warnMissing\r\n) {\r\n  /* istanbul ignore if */\r\n  if (typeof id !== 'string') {\r\n    return\r\n  }\r\n  var assets = options[type];\r\n  // check local registration variations first\r\n  if (hasOwn(assets, id)) { return assets[id] }\r\n  var camelizedId = camelize(id);\r\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\r\n  var PascalCaseId = capitalize(camelizedId);\r\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\r\n  // fallback to prototype chain\r\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\r\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\r\n    warn(\r\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\r\n      options\r\n    );\r\n  }\r\n  return res\r\n}\r\n\r\n/*  */\r\n\r\nfunction validateProp (\r\n  key,\r\n  propOptions,\r\n  propsData,\r\n  vm\r\n) {\r\n  var prop = propOptions[key];\r\n  var absent = !hasOwn(propsData, key);\r\n  var value = propsData[key];\r\n  // handle boolean props\r\n  if (isType(Boolean, prop.type)) {\r\n    if (absent && !hasOwn(prop, 'default')) {\r\n      value = false;\r\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\r\n      value = true;\r\n    }\r\n  }\r\n  // check default value\r\n  if (value === undefined) {\r\n    value = getPropDefaultValue(vm, prop, key);\r\n    // since the default value is a fresh copy,\r\n    // make sure to observe it.\r\n    var prevShouldConvert = observerState.shouldConvert;\r\n    observerState.shouldConvert = true;\r\n    observe(value);\r\n    observerState.shouldConvert = prevShouldConvert;\r\n  }\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertProp(prop, key, value, vm, absent);\r\n  }\r\n  return value\r\n}\r\n\r\n/**\r\n * Get the default value of a prop.\r\n */\r\nfunction getPropDefaultValue (vm, prop, key) {\r\n  // no default, return undefined\r\n  if (!hasOwn(prop, 'default')) {\r\n    return undefined\r\n  }\r\n  var def = prop.default;\r\n  // warn against non-factory defaults for Object & Array\r\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\r\n    warn(\r\n      'Invalid default value for prop \"' + key + '\": ' +\r\n      'Props with type Object/Array must use a factory function ' +\r\n      'to return the default value.',\r\n      vm\r\n    );\r\n  }\r\n  // the raw prop value was also undefined from previous render,\r\n  // return previous default value to avoid unnecessary watcher trigger\r\n  if (vm && vm.$options.propsData &&\r\n    vm.$options.propsData[key] === undefined &&\r\n    vm._props[key] !== undefined\r\n  ) {\r\n    return vm._props[key]\r\n  }\r\n  // call factory function for non-Function types\r\n  // a value is Function if its prototype is function even across different execution context\r\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\r\n    ? def.call(vm)\r\n    : def\r\n}\r\n\r\n/**\r\n * Assert whether a prop is valid.\r\n */\r\nfunction assertProp (\r\n  prop,\r\n  name,\r\n  value,\r\n  vm,\r\n  absent\r\n) {\r\n  if (prop.required && absent) {\r\n    warn(\r\n      'Missing required prop: \"' + name + '\"',\r\n      vm\r\n    );\r\n    return\r\n  }\r\n  if (value == null && !prop.required) {\r\n    return\r\n  }\r\n  var type = prop.type;\r\n  var valid = !type || type === true;\r\n  var expectedTypes = [];\r\n  if (type) {\r\n    if (!Array.isArray(type)) {\r\n      type = [type];\r\n    }\r\n    for (var i = 0; i < type.length && !valid; i++) {\r\n      var assertedType = assertType(value, type[i]);\r\n      expectedTypes.push(assertedType.expectedType || '');\r\n      valid = assertedType.valid;\r\n    }\r\n  }\r\n  if (!valid) {\r\n    warn(\r\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\r\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\r\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\r\n      vm\r\n    );\r\n    return\r\n  }\r\n  var validator = prop.validator;\r\n  if (validator) {\r\n    if (!validator(value)) {\r\n      warn(\r\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\r\n        vm\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\r\n\r\nfunction assertType (value, type) {\r\n  var valid;\r\n  var expectedType = getType(type);\r\n  if (simpleCheckRE.test(expectedType)) {\r\n    var t = typeof value;\r\n    valid = t === expectedType.toLowerCase();\r\n    // for primitive wrapper objects\r\n    if (!valid && t === 'object') {\r\n      valid = value instanceof type;\r\n    }\r\n  } else if (expectedType === 'Object') {\r\n    valid = isPlainObject(value);\r\n  } else if (expectedType === 'Array') {\r\n    valid = Array.isArray(value);\r\n  } else {\r\n    valid = value instanceof type;\r\n  }\r\n  return {\r\n    valid: valid,\r\n    expectedType: expectedType\r\n  }\r\n}\r\n\r\n/**\r\n * Use function string name to check built-in types,\r\n * because a simple equality check will fail when running\r\n * across different vms / iframes.\r\n */\r\nfunction getType (fn) {\r\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\r\n  return match ? match[1] : ''\r\n}\r\n\r\nfunction isType (type, fn) {\r\n  if (!Array.isArray(fn)) {\r\n    return getType(fn) === getType(type)\r\n  }\r\n  for (var i = 0, len = fn.length; i < len; i++) {\r\n    if (getType(fn[i]) === getType(type)) {\r\n      return true\r\n    }\r\n  }\r\n  /* istanbul ignore next */\r\n  return false\r\n}\r\n\r\n/*  */\r\n\r\nvar mark;\r\nvar measure;\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  var perf = inBrowser && window.performance;\r\n  /* istanbul ignore if */\r\n  if (\r\n    perf &&\r\n    perf.mark &&\r\n    perf.measure &&\r\n    perf.clearMarks &&\r\n    perf.clearMeasures\r\n  ) {\r\n    mark = function (tag) { return perf.mark(tag); };\r\n    measure = function (name, startTag, endTag) {\r\n      perf.measure(name, startTag, endTag);\r\n      perf.clearMarks(startTag);\r\n      perf.clearMarks(endTag);\r\n      perf.clearMeasures(name);\r\n    };\r\n  }\r\n}\r\n\r\n/* not type checking this file because flow doesn't play well with Proxy */\r\n\r\nvar initProxy;\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  var allowedGlobals = makeMap(\r\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\r\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\r\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\r\n    'require' // for Webpack/Browserify\r\n  );\r\n\r\n  var warnNonPresent = function (target, key) {\r\n    warn(\r\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\r\n      \"referenced during render. Make sure to declare reactive data \" +\r\n      \"properties in the data option.\",\r\n      target\r\n    );\r\n  };\r\n\r\n  var hasProxy =\r\n    typeof Proxy !== 'undefined' &&\r\n    Proxy.toString().match(/native code/);\r\n\r\n  if (hasProxy) {\r\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\r\n    config.keyCodes = new Proxy(config.keyCodes, {\r\n      set: function set (target, key, value) {\r\n        if (isBuiltInModifier(key)) {\r\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\r\n          return false\r\n        } else {\r\n          target[key] = value;\r\n          return true\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  var hasHandler = {\r\n    has: function has (target, key) {\r\n      var has = key in target;\r\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\r\n      if (!has && !isAllowed) {\r\n        warnNonPresent(target, key);\r\n      }\r\n      return has || !isAllowed\r\n    }\r\n  };\r\n\r\n  var getHandler = {\r\n    get: function get (target, key) {\r\n      if (typeof key === 'string' && !(key in target)) {\r\n        warnNonPresent(target, key);\r\n      }\r\n      return target[key]\r\n    }\r\n  };\r\n\r\n  initProxy = function initProxy (vm) {\r\n    if (hasProxy) {\r\n      // determine which proxy handler to use\r\n      var options = vm.$options;\r\n      var handlers = options.render && options.render._withStripped\r\n        ? getHandler\r\n        : hasHandler;\r\n      vm._renderProxy = new Proxy(vm, handlers);\r\n    } else {\r\n      vm._renderProxy = vm;\r\n    }\r\n  };\r\n}\r\n\r\n/*  */\r\n\r\nvar VNode = function VNode (\r\n  tag,\r\n  data,\r\n  children,\r\n  text,\r\n  elm,\r\n  context,\r\n  componentOptions,\r\n  asyncFactory\r\n) {\r\n  this.tag = tag;\r\n  this.data = data;\r\n  this.children = children;\r\n  this.text = text;\r\n  this.elm = elm;\r\n  this.ns = undefined;\r\n  this.context = context;\r\n  this.functionalContext = undefined;\r\n  this.key = data && data.key;\r\n  this.componentOptions = componentOptions;\r\n  this.componentInstance = undefined;\r\n  this.parent = undefined;\r\n  this.raw = false;\r\n  this.isStatic = false;\r\n  this.isRootInsert = true;\r\n  this.isComment = false;\r\n  this.isCloned = false;\r\n  this.isOnce = false;\r\n  this.asyncFactory = asyncFactory;\r\n  this.asyncMeta = undefined;\r\n  this.isAsyncPlaceholder = false;\r\n};\r\n\r\nvar prototypeAccessors = { child: {} };\r\n\r\n// DEPRECATED: alias for componentInstance for backwards compat.\r\n/* istanbul ignore next */\r\nprototypeAccessors.child.get = function () {\r\n  return this.componentInstance\r\n};\r\n\r\nObject.defineProperties( VNode.prototype, prototypeAccessors );\r\n\r\nvar createEmptyVNode = function (text) {\r\n  if ( text === void 0 ) text = '';\r\n\r\n  var node = new VNode();\r\n  node.text = text;\r\n  node.isComment = true;\r\n  return node\r\n};\r\n\r\nfunction createTextVNode (val) {\r\n  return new VNode(undefined, undefined, undefined, String(val))\r\n}\r\n\r\n// optimized shallow clone\r\n// used for static nodes and slot nodes because they may be reused across\r\n// multiple renders, cloning them avoids errors when DOM manipulations rely\r\n// on their elm reference.\r\nfunction cloneVNode (vnode, deep) {\r\n  var cloned = new VNode(\r\n    vnode.tag,\r\n    vnode.data,\r\n    vnode.children,\r\n    vnode.text,\r\n    vnode.elm,\r\n    vnode.context,\r\n    vnode.componentOptions,\r\n    vnode.asyncFactory\r\n  );\r\n  cloned.ns = vnode.ns;\r\n  cloned.isStatic = vnode.isStatic;\r\n  cloned.key = vnode.key;\r\n  cloned.isComment = vnode.isComment;\r\n  cloned.isCloned = true;\r\n  if (deep && vnode.children) {\r\n    cloned.children = cloneVNodes(vnode.children);\r\n  }\r\n  return cloned\r\n}\r\n\r\nfunction cloneVNodes (vnodes, deep) {\r\n  var len = vnodes.length;\r\n  var res = new Array(len);\r\n  for (var i = 0; i < len; i++) {\r\n    res[i] = cloneVNode(vnodes[i], deep);\r\n  }\r\n  return res\r\n}\r\n\r\n/*  */\r\n\r\nvar normalizeEvent = cached(function (name) {\r\n  var passive = name.charAt(0) === '&';\r\n  name = passive ? name.slice(1) : name;\r\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\r\n  name = once$$1 ? name.slice(1) : name;\r\n  var capture = name.charAt(0) === '!';\r\n  name = capture ? name.slice(1) : name;\r\n  var plain = !(passive || once$$1 || capture);\r\n  return {\r\n    name: name,\r\n    plain: plain,\r\n    once: once$$1,\r\n    capture: capture,\r\n    passive: passive\r\n  }\r\n});\r\n\r\nfunction createFnInvoker (fns) {\r\n  function invoker () {\r\n    var arguments$1 = arguments;\r\n\r\n    var fns = invoker.fns;\r\n    if (Array.isArray(fns)) {\r\n      var cloned = fns.slice();\r\n      for (var i = 0; i < cloned.length; i++) {\r\n        cloned[i].apply(null, arguments$1);\r\n      }\r\n    } else {\r\n      // return handler return value for single handlers\r\n      return fns.apply(null, arguments)\r\n    }\r\n  }\r\n  invoker.fns = fns;\r\n  return invoker\r\n}\r\n\r\n// #6552\r\nfunction prioritizePlainEvents (a, b) {\r\n  return a.plain ? -1 : b.plain ? 1 : 0\r\n}\r\n\r\nfunction updateListeners (\r\n  on,\r\n  oldOn,\r\n  add,\r\n  remove$$1,\r\n  vm\r\n) {\r\n  var name, cur, old, event;\r\n  var toAdd = [];\r\n  var hasModifier = false;\r\n  for (name in on) {\r\n    cur = on[name];\r\n    old = oldOn[name];\r\n    event = normalizeEvent(name);\r\n    if (!event.plain) { hasModifier = true; }\r\n    if (isUndef(cur)) {\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\r\n        vm\r\n      );\r\n    } else if (isUndef(old)) {\r\n      if (isUndef(cur.fns)) {\r\n        cur = on[name] = createFnInvoker(cur);\r\n      }\r\n      event.handler = cur;\r\n      toAdd.push(event);\r\n    } else if (cur !== old) {\r\n      old.fns = cur;\r\n      on[name] = old;\r\n    }\r\n  }\r\n  if (toAdd.length) {\r\n    if (hasModifier) { toAdd.sort(prioritizePlainEvents); }\r\n    for (var i = 0; i < toAdd.length; i++) {\r\n      var event$1 = toAdd[i];\r\n      add(event$1.name, event$1.handler, event$1.once, event$1.capture, event$1.passive);\r\n    }\r\n  }\r\n  for (name in oldOn) {\r\n    if (isUndef(on[name])) {\r\n      event = normalizeEvent(name);\r\n      remove$$1(event.name, oldOn[name], event.capture);\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction mergeVNodeHook (def, hookKey, hook) {\r\n  var invoker;\r\n  var oldHook = def[hookKey];\r\n\r\n  function wrappedHook () {\r\n    hook.apply(this, arguments);\r\n    // important: remove merged hook to ensure it's called only once\r\n    // and prevent memory leak\r\n    remove(invoker.fns, wrappedHook);\r\n  }\r\n\r\n  if (isUndef(oldHook)) {\r\n    // no existing hook\r\n    invoker = createFnInvoker([wrappedHook]);\r\n  } else {\r\n    /* istanbul ignore if */\r\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\r\n      // already a merged invoker\r\n      invoker = oldHook;\r\n      invoker.fns.push(wrappedHook);\r\n    } else {\r\n      // existing plain hook\r\n      invoker = createFnInvoker([oldHook, wrappedHook]);\r\n    }\r\n  }\r\n\r\n  invoker.merged = true;\r\n  def[hookKey] = invoker;\r\n}\r\n\r\n/*  */\r\n\r\nfunction extractPropsFromVNodeData (\r\n  data,\r\n  Ctor,\r\n  tag\r\n) {\r\n  // we are only extracting raw values here.\r\n  // validation and default values are handled in the child\r\n  // component itself.\r\n  var propOptions = Ctor.options.props;\r\n  if (isUndef(propOptions)) {\r\n    return\r\n  }\r\n  var res = {};\r\n  var attrs = data.attrs;\r\n  var props = data.props;\r\n  if (isDef(attrs) || isDef(props)) {\r\n    for (var key in propOptions) {\r\n      var altKey = hyphenate(key);\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        var keyInLowerCase = key.toLowerCase();\r\n        if (\r\n          key !== keyInLowerCase &&\r\n          attrs && hasOwn(attrs, keyInLowerCase)\r\n        ) {\r\n          tip(\r\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\r\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\r\n            \" \\\"\" + key + \"\\\". \" +\r\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\r\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\r\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\r\n          );\r\n        }\r\n      }\r\n      checkProp(res, props, key, altKey, true) ||\r\n      checkProp(res, attrs, key, altKey, false);\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nfunction checkProp (\r\n  res,\r\n  hash,\r\n  key,\r\n  altKey,\r\n  preserve\r\n) {\r\n  if (isDef(hash)) {\r\n    if (hasOwn(hash, key)) {\r\n      res[key] = hash[key];\r\n      if (!preserve) {\r\n        delete hash[key];\r\n      }\r\n      return true\r\n    } else if (hasOwn(hash, altKey)) {\r\n      res[key] = hash[altKey];\r\n      if (!preserve) {\r\n        delete hash[altKey];\r\n      }\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/*  */\r\n\r\n// The template compiler attempts to minimize the need for normalization by\r\n// statically analyzing the template at compile time.\r\n//\r\n// For plain HTML markup, normalization can be completely skipped because the\r\n// generated render function is guaranteed to return Array<VNode>. There are\r\n// two cases where extra normalization is needed:\r\n\r\n// 1. When the children contains components - because a functional component\r\n// may return an Array instead of a single root. In this case, just a simple\r\n// normalization is needed - if any child is an Array, we flatten the whole\r\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\r\n// because functional components already normalize their own children.\r\nfunction simpleNormalizeChildren (children) {\r\n  for (var i = 0; i < children.length; i++) {\r\n    if (Array.isArray(children[i])) {\r\n      return Array.prototype.concat.apply([], children)\r\n    }\r\n  }\r\n  return children\r\n}\r\n\r\n// 2. When the children contains constructs that always generated nested Arrays,\r\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\r\n// with hand-written render functions / JSX. In such cases a full normalization\r\n// is needed to cater to all possible types of children values.\r\nfunction normalizeChildren (children) {\r\n  return isPrimitive(children)\r\n    ? [createTextVNode(children)]\r\n    : Array.isArray(children)\r\n      ? normalizeArrayChildren(children)\r\n      : undefined\r\n}\r\n\r\nfunction isTextNode (node) {\r\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\r\n}\r\n\r\nfunction normalizeArrayChildren (children, nestedIndex) {\r\n  var res = [];\r\n  var i, c, last;\r\n  for (i = 0; i < children.length; i++) {\r\n    c = children[i];\r\n    if (isUndef(c) || typeof c === 'boolean') { continue }\r\n    last = res[res.length - 1];\r\n    //  nested\r\n    if (Array.isArray(c)) {\r\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\r\n    } else if (isPrimitive(c)) {\r\n      if (isTextNode(last)) {\r\n        // merge adjacent text nodes\r\n        // this is necessary for SSR hydration because text nodes are\r\n        // essentially merged when rendered to HTML strings\r\n        (last).text += String(c);\r\n      } else if (c !== '') {\r\n        // convert primitive to vnode\r\n        res.push(createTextVNode(c));\r\n      }\r\n    } else {\r\n      if (isTextNode(c) && isTextNode(last)) {\r\n        // merge adjacent text nodes\r\n        res[res.length - 1] = createTextVNode(last.text + c.text);\r\n      } else {\r\n        // default key for nested array children (likely generated by v-for)\r\n        if (isTrue(children._isVList) &&\r\n          isDef(c.tag) &&\r\n          isUndef(c.key) &&\r\n          isDef(nestedIndex)) {\r\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\r\n        }\r\n        res.push(c);\r\n      }\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\n/*  */\r\n\r\nfunction ensureCtor (comp, base) {\r\n  if (comp.__esModule && comp.default) {\r\n    comp = comp.default;\r\n  }\r\n  return isObject(comp)\r\n    ? base.extend(comp)\r\n    : comp\r\n}\r\n\r\nfunction createAsyncPlaceholder (\r\n  factory,\r\n  data,\r\n  context,\r\n  children,\r\n  tag\r\n) {\r\n  var node = createEmptyVNode();\r\n  node.asyncFactory = factory;\r\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\r\n  return node\r\n}\r\n\r\nfunction resolveAsyncComponent (\r\n  factory,\r\n  baseCtor,\r\n  context\r\n) {\r\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\r\n    return factory.errorComp\r\n  }\r\n\r\n  if (isDef(factory.resolved)) {\r\n    return factory.resolved\r\n  }\r\n\r\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\r\n    return factory.loadingComp\r\n  }\r\n\r\n  if (isDef(factory.contexts)) {\r\n    // already pending\r\n    factory.contexts.push(context);\r\n  } else {\r\n    var contexts = factory.contexts = [context];\r\n    var sync = true;\r\n\r\n    var forceRender = function () {\r\n      for (var i = 0, l = contexts.length; i < l; i++) {\r\n        contexts[i].$forceUpdate();\r\n      }\r\n    };\r\n\r\n    var resolve = once(function (res) {\r\n      // cache resolved\r\n      factory.resolved = ensureCtor(res, baseCtor);\r\n      // invoke callbacks only if this is not a synchronous resolve\r\n      // (async resolves are shimmed as synchronous during SSR)\r\n      if (!sync) {\r\n        forceRender();\r\n      }\r\n    });\r\n\r\n    var reject = once(function (reason) {\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        \"Failed to resolve async component: \" + (String(factory)) +\r\n        (reason ? (\"\\nReason: \" + reason) : '')\r\n      );\r\n      if (isDef(factory.errorComp)) {\r\n        factory.error = true;\r\n        forceRender();\r\n      }\r\n    });\r\n\r\n    var res = factory(resolve, reject);\r\n\r\n    if (isObject(res)) {\r\n      if (typeof res.then === 'function') {\r\n        // () => Promise\r\n        if (isUndef(factory.resolved)) {\r\n          res.then(resolve, reject);\r\n        }\r\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\r\n        res.component.then(resolve, reject);\r\n\r\n        if (isDef(res.error)) {\r\n          factory.errorComp = ensureCtor(res.error, baseCtor);\r\n        }\r\n\r\n        if (isDef(res.loading)) {\r\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\r\n          if (res.delay === 0) {\r\n            factory.loading = true;\r\n          } else {\r\n            setTimeout(function () {\r\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\r\n                factory.loading = true;\r\n                forceRender();\r\n              }\r\n            }, res.delay || 200);\r\n          }\r\n        }\r\n\r\n        if (isDef(res.timeout)) {\r\n          setTimeout(function () {\r\n            if (isUndef(factory.resolved)) {\r\n              reject(\r\n                process.env.NODE_ENV !== 'production'\r\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\r\n                  : null\r\n              );\r\n            }\r\n          }, res.timeout);\r\n        }\r\n      }\r\n    }\r\n\r\n    sync = false;\r\n    // return in case resolved synchronously\r\n    return factory.loading\r\n      ? factory.loadingComp\r\n      : factory.resolved\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction isAsyncPlaceholder (node) {\r\n  return node.isComment && node.asyncFactory\r\n}\r\n\r\n/*  */\r\n\r\nfunction getFirstComponentChild (children) {\r\n  if (Array.isArray(children)) {\r\n    for (var i = 0; i < children.length; i++) {\r\n      var c = children[i];\r\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\r\n        return c\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n/*  */\r\n\r\nfunction initEvents (vm) {\r\n  vm._events = Object.create(null);\r\n  vm._hasHookEvent = false;\r\n  // init parent attached events\r\n  var listeners = vm.$options._parentListeners;\r\n  if (listeners) {\r\n    updateComponentListeners(vm, listeners);\r\n  }\r\n}\r\n\r\nvar target;\r\n\r\nfunction add (event, fn, once$$1) {\r\n  if (once$$1) {\r\n    target.$once(event, fn);\r\n  } else {\r\n    target.$on(event, fn);\r\n  }\r\n}\r\n\r\nfunction remove$1 (event, fn) {\r\n  target.$off(event, fn);\r\n}\r\n\r\nfunction updateComponentListeners (\r\n  vm,\r\n  listeners,\r\n  oldListeners\r\n) {\r\n  target = vm;\r\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\r\n}\r\n\r\nfunction eventsMixin (Vue) {\r\n  var hookRE = /^hook:/;\r\n  Vue.prototype.$on = function (event, fn) {\r\n    var this$1 = this;\r\n\r\n    var vm = this;\r\n    if (Array.isArray(event)) {\r\n      for (var i = 0, l = event.length; i < l; i++) {\r\n        this$1.$on(event[i], fn);\r\n      }\r\n    } else {\r\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\r\n      // optimize hook:event cost by using a boolean flag marked at registration\r\n      // instead of a hash lookup\r\n      if (hookRE.test(event)) {\r\n        vm._hasHookEvent = true;\r\n      }\r\n    }\r\n    return vm\r\n  };\r\n\r\n  Vue.prototype.$once = function (event, fn) {\r\n    var vm = this;\r\n    function on () {\r\n      vm.$off(event, on);\r\n      fn.apply(vm, arguments);\r\n    }\r\n    on.fn = fn;\r\n    vm.$on(event, on);\r\n    return vm\r\n  };\r\n\r\n  Vue.prototype.$off = function (event, fn) {\r\n    var this$1 = this;\r\n\r\n    var vm = this;\r\n    // all\r\n    if (!arguments.length) {\r\n      vm._events = Object.create(null);\r\n      return vm\r\n    }\r\n    // array of events\r\n    if (Array.isArray(event)) {\r\n      for (var i = 0, l = event.length; i < l; i++) {\r\n        this$1.$off(event[i], fn);\r\n      }\r\n      return vm\r\n    }\r\n    // specific event\r\n    var cbs = vm._events[event];\r\n    if (!cbs) {\r\n      return vm\r\n    }\r\n    if (arguments.length === 1) {\r\n      vm._events[event] = null;\r\n      return vm\r\n    }\r\n    if (fn) {\r\n      // specific handler\r\n      var cb;\r\n      var i$1 = cbs.length;\r\n      while (i$1--) {\r\n        cb = cbs[i$1];\r\n        if (cb === fn || cb.fn === fn) {\r\n          cbs.splice(i$1, 1);\r\n          break\r\n        }\r\n      }\r\n    }\r\n    return vm\r\n  };\r\n\r\n  Vue.prototype.$emit = function (event) {\r\n    var vm = this;\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      var lowerCaseEvent = event.toLowerCase();\r\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\r\n        tip(\r\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\r\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\r\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\r\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\r\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\r\n        );\r\n      }\r\n    }\r\n    var cbs = vm._events[event];\r\n    if (cbs) {\r\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\r\n      var args = toArray(arguments, 1);\r\n      for (var i = 0, l = cbs.length; i < l; i++) {\r\n        try {\r\n          cbs[i].apply(vm, args);\r\n        } catch (e) {\r\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\r\n        }\r\n      }\r\n    }\r\n    return vm\r\n  };\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Runtime helper for resolving raw children VNodes into a slot object.\r\n */\r\nfunction resolveSlots (\r\n  children,\r\n  context\r\n) {\r\n  var slots = {};\r\n  if (!children) {\r\n    return slots\r\n  }\r\n  var defaultSlot = [];\r\n  for (var i = 0, l = children.length; i < l; i++) {\r\n    var child = children[i];\r\n    var data = child.data;\r\n    // remove slot attribute if the node is resolved as a Vue slot node\r\n    if (data && data.attrs && data.attrs.slot) {\r\n      delete data.attrs.slot;\r\n    }\r\n    // named slots should only be respected if the vnode was rendered in the\r\n    // same context.\r\n    if ((child.context === context || child.functionalContext === context) &&\r\n      data && data.slot != null\r\n    ) {\r\n      var name = child.data.slot;\r\n      var slot = (slots[name] || (slots[name] = []));\r\n      if (child.tag === 'template') {\r\n        slot.push.apply(slot, child.children);\r\n      } else {\r\n        slot.push(child);\r\n      }\r\n    } else {\r\n      defaultSlot.push(child);\r\n    }\r\n  }\r\n  // ignore whitespace\r\n  if (!defaultSlot.every(isWhitespace)) {\r\n    slots.default = defaultSlot;\r\n  }\r\n  return slots\r\n}\r\n\r\nfunction isWhitespace (node) {\r\n  return node.isComment || node.text === ' '\r\n}\r\n\r\nfunction resolveScopedSlots (\r\n  fns, // see flow/vnode\r\n  res\r\n) {\r\n  res = res || {};\r\n  for (var i = 0; i < fns.length; i++) {\r\n    if (Array.isArray(fns[i])) {\r\n      resolveScopedSlots(fns[i], res);\r\n    } else {\r\n      res[fns[i].key] = fns[i].fn;\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\n/*  */\r\n\r\nvar activeInstance = null;\r\nvar isUpdatingChildComponent = false;\r\n\r\nfunction initLifecycle (vm) {\r\n  var options = vm.$options;\r\n\r\n  // locate first non-abstract parent\r\n  var parent = options.parent;\r\n  if (parent && !options.abstract) {\r\n    while (parent.$options.abstract && parent.$parent) {\r\n      parent = parent.$parent;\r\n    }\r\n    parent.$children.push(vm);\r\n  }\r\n\r\n  vm.$parent = parent;\r\n  vm.$root = parent ? parent.$root : vm;\r\n\r\n  vm.$children = [];\r\n  vm.$refs = {};\r\n\r\n  vm._watcher = null;\r\n  vm._inactive = null;\r\n  vm._directInactive = false;\r\n  vm._isMounted = false;\r\n  vm._isDestroyed = false;\r\n  vm._isBeingDestroyed = false;\r\n}\r\n\r\nfunction lifecycleMixin (Vue) {\r\n  Vue.prototype._update = function (vnode, hydrating) {\r\n    var vm = this;\r\n    if (vm._isMounted) {\r\n      callHook(vm, 'beforeUpdate');\r\n    }\r\n    var prevEl = vm.$el;\r\n    var prevVnode = vm._vnode;\r\n    var prevActiveInstance = activeInstance;\r\n    activeInstance = vm;\r\n    vm._vnode = vnode;\r\n    // Vue.prototype.__patch__ is injected in entry points\r\n    // based on the rendering backend used.\r\n    if (!prevVnode) {\r\n      // initial render\r\n      vm.$el = vm.__patch__(\r\n        vm.$el, vnode, hydrating, false /* removeOnly */,\r\n        vm.$options._parentElm,\r\n        vm.$options._refElm\r\n      );\r\n      // no need for the ref nodes after initial patch\r\n      // this prevents keeping a detached DOM tree in memory (#5851)\r\n      vm.$options._parentElm = vm.$options._refElm = null;\r\n    } else {\r\n      // updates\r\n      vm.$el = vm.__patch__(prevVnode, vnode);\r\n    }\r\n    activeInstance = prevActiveInstance;\r\n    // update __vue__ reference\r\n    if (prevEl) {\r\n      prevEl.__vue__ = null;\r\n    }\r\n    if (vm.$el) {\r\n      vm.$el.__vue__ = vm;\r\n    }\r\n    // if parent is an HOC, update its $el as well\r\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\r\n      vm.$parent.$el = vm.$el;\r\n    }\r\n    // updated hook is called by the scheduler to ensure that children are\r\n    // updated in a parent's updated hook.\r\n  };\r\n\r\n  Vue.prototype.$forceUpdate = function () {\r\n    var vm = this;\r\n    if (vm._watcher) {\r\n      vm._watcher.update();\r\n    }\r\n  };\r\n\r\n  Vue.prototype.$destroy = function () {\r\n    var vm = this;\r\n    if (vm._isBeingDestroyed) {\r\n      return\r\n    }\r\n    callHook(vm, 'beforeDestroy');\r\n    vm._isBeingDestroyed = true;\r\n    // remove self from parent\r\n    var parent = vm.$parent;\r\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\r\n      remove(parent.$children, vm);\r\n    }\r\n    // teardown watchers\r\n    if (vm._watcher) {\r\n      vm._watcher.teardown();\r\n    }\r\n    var i = vm._watchers.length;\r\n    while (i--) {\r\n      vm._watchers[i].teardown();\r\n    }\r\n    // remove reference from data ob\r\n    // frozen object may not have observer.\r\n    if (vm._data.__ob__) {\r\n      vm._data.__ob__.vmCount--;\r\n    }\r\n    // call the last hook...\r\n    vm._isDestroyed = true;\r\n    // invoke destroy hooks on current rendered tree\r\n    vm.__patch__(vm._vnode, null);\r\n    // fire destroyed hook\r\n    callHook(vm, 'destroyed');\r\n    // turn off all instance listeners.\r\n    vm.$off();\r\n    // remove __vue__ reference\r\n    if (vm.$el) {\r\n      vm.$el.__vue__ = null;\r\n    }\r\n  };\r\n}\r\n\r\nfunction mountComponent (\r\n  vm,\r\n  el,\r\n  hydrating\r\n) {\r\n  vm.$el = el;\r\n  if (!vm.$options.render) {\r\n    vm.$options.render = createEmptyVNode;\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      /* istanbul ignore if */\r\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\r\n        vm.$options.el || el) {\r\n        warn(\r\n          'You are using the runtime-only build of Vue where the template ' +\r\n          'compiler is not available. Either pre-compile the templates into ' +\r\n          'render functions, or use the compiler-included build.',\r\n          vm\r\n        );\r\n      } else {\r\n        warn(\r\n          'Failed to mount component: template or render function not defined.',\r\n          vm\r\n        );\r\n      }\r\n    }\r\n  }\r\n  callHook(vm, 'beforeMount');\r\n\r\n  var updateComponent;\r\n  /* istanbul ignore if */\r\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\r\n    updateComponent = function () {\r\n      var name = vm._name;\r\n      var id = vm._uid;\r\n      var startTag = \"vue-perf-start:\" + id;\r\n      var endTag = \"vue-perf-end:\" + id;\r\n\r\n      mark(startTag);\r\n      var vnode = vm._render();\r\n      mark(endTag);\r\n      measure((name + \" render\"), startTag, endTag);\r\n\r\n      mark(startTag);\r\n      vm._update(vnode, hydrating);\r\n      mark(endTag);\r\n      measure((name + \" patch\"), startTag, endTag);\r\n    };\r\n  } else {\r\n    updateComponent = function () {\r\n      vm._update(vm._render(), hydrating);\r\n    };\r\n  }\r\n\r\n  vm._watcher = new Watcher(vm, updateComponent, noop);\r\n  hydrating = false;\r\n\r\n  // manually mounted instance, call mounted on self\r\n  // mounted is called for render-created child components in its inserted hook\r\n  if (vm.$vnode == null) {\r\n    vm._isMounted = true;\r\n    callHook(vm, 'mounted');\r\n  }\r\n  return vm\r\n}\r\n\r\nfunction updateChildComponent (\r\n  vm,\r\n  propsData,\r\n  listeners,\r\n  parentVnode,\r\n  renderChildren\r\n) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    isUpdatingChildComponent = true;\r\n  }\r\n\r\n  // determine whether component has slot children\r\n  // we need to do this before overwriting $options._renderChildren\r\n  var hasChildren = !!(\r\n    renderChildren ||               // has new static slots\r\n    vm.$options._renderChildren ||  // has old static slots\r\n    parentVnode.data.scopedSlots || // has new scoped slots\r\n    vm.$scopedSlots !== emptyObject // has old scoped slots\r\n  );\r\n\r\n  vm.$options._parentVnode = parentVnode;\r\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\r\n\r\n  if (vm._vnode) { // update child tree's parent\r\n    vm._vnode.parent = parentVnode;\r\n  }\r\n  vm.$options._renderChildren = renderChildren;\r\n\r\n  // update $attrs and $listeners hash\r\n  // these are also reactive so they may trigger child update if the child\r\n  // used them during render\r\n  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;\r\n  vm.$listeners = listeners || emptyObject;\r\n\r\n  // update props\r\n  if (propsData && vm.$options.props) {\r\n    observerState.shouldConvert = false;\r\n    var props = vm._props;\r\n    var propKeys = vm.$options._propKeys || [];\r\n    for (var i = 0; i < propKeys.length; i++) {\r\n      var key = propKeys[i];\r\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\r\n    }\r\n    observerState.shouldConvert = true;\r\n    // keep a copy of raw propsData\r\n    vm.$options.propsData = propsData;\r\n  }\r\n\r\n  // update listeners\r\n  if (listeners) {\r\n    var oldListeners = vm.$options._parentListeners;\r\n    vm.$options._parentListeners = listeners;\r\n    updateComponentListeners(vm, listeners, oldListeners);\r\n  }\r\n  // resolve slots + force update if has children\r\n  if (hasChildren) {\r\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\r\n    vm.$forceUpdate();\r\n  }\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    isUpdatingChildComponent = false;\r\n  }\r\n}\r\n\r\nfunction isInInactiveTree (vm) {\r\n  while (vm && (vm = vm.$parent)) {\r\n    if (vm._inactive) { return true }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction activateChildComponent (vm, direct) {\r\n  if (direct) {\r\n    vm._directInactive = false;\r\n    if (isInInactiveTree(vm)) {\r\n      return\r\n    }\r\n  } else if (vm._directInactive) {\r\n    return\r\n  }\r\n  if (vm._inactive || vm._inactive === null) {\r\n    vm._inactive = false;\r\n    for (var i = 0; i < vm.$children.length; i++) {\r\n      activateChildComponent(vm.$children[i]);\r\n    }\r\n    callHook(vm, 'activated');\r\n  }\r\n}\r\n\r\nfunction deactivateChildComponent (vm, direct) {\r\n  if (direct) {\r\n    vm._directInactive = true;\r\n    if (isInInactiveTree(vm)) {\r\n      return\r\n    }\r\n  }\r\n  if (!vm._inactive) {\r\n    vm._inactive = true;\r\n    for (var i = 0; i < vm.$children.length; i++) {\r\n      deactivateChildComponent(vm.$children[i]);\r\n    }\r\n    callHook(vm, 'deactivated');\r\n  }\r\n}\r\n\r\nfunction callHook (vm, hook) {\r\n  var handlers = vm.$options[hook];\r\n  if (handlers) {\r\n    for (var i = 0, j = handlers.length; i < j; i++) {\r\n      try {\r\n        handlers[i].call(vm);\r\n      } catch (e) {\r\n        handleError(e, vm, (hook + \" hook\"));\r\n      }\r\n    }\r\n  }\r\n  if (vm._hasHookEvent) {\r\n    vm.$emit('hook:' + hook);\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n\r\nvar MAX_UPDATE_COUNT = 100;\r\n\r\nvar queue = [];\r\nvar activatedChildren = [];\r\nvar has = {};\r\nvar circular = {};\r\nvar waiting = false;\r\nvar flushing = false;\r\nvar index = 0;\r\n\r\n/**\r\n * Reset the scheduler's state.\r\n */\r\nfunction resetSchedulerState () {\r\n  index = queue.length = activatedChildren.length = 0;\r\n  has = {};\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    circular = {};\r\n  }\r\n  waiting = flushing = false;\r\n}\r\n\r\n/**\r\n * Flush both queues and run the watchers.\r\n */\r\nfunction flushSchedulerQueue () {\r\n  flushing = true;\r\n  var watcher, id;\r\n\r\n  // Sort queue before flush.\r\n  // This ensures that:\r\n  // 1. Components are updated from parent to child. (because parent is always\r\n  //    created before the child)\r\n  // 2. A component's user watchers are run before its render watcher (because\r\n  //    user watchers are created before the render watcher)\r\n  // 3. If a component is destroyed during a parent component's watcher run,\r\n  //    its watchers can be skipped.\r\n  queue.sort(function (a, b) { return a.id - b.id; });\r\n\r\n  // do not cache length because more watchers might be pushed\r\n  // as we run existing watchers\r\n  for (index = 0; index < queue.length; index++) {\r\n    watcher = queue[index];\r\n    id = watcher.id;\r\n    has[id] = null;\r\n    watcher.run();\r\n    // in dev build, check and stop circular updates.\r\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\r\n      circular[id] = (circular[id] || 0) + 1;\r\n      if (circular[id] > MAX_UPDATE_COUNT) {\r\n        warn(\r\n          'You may have an infinite update loop ' + (\r\n            watcher.user\r\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\r\n              : \"in a component render function.\"\r\n          ),\r\n          watcher.vm\r\n        );\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  // keep copies of post queues before resetting state\r\n  var activatedQueue = activatedChildren.slice();\r\n  var updatedQueue = queue.slice();\r\n\r\n  resetSchedulerState();\r\n\r\n  // call component updated and activated hooks\r\n  callActivatedHooks(activatedQueue);\r\n  callUpdatedHooks(updatedQueue);\r\n\r\n  // devtool hook\r\n  /* istanbul ignore if */\r\n  if (devtools && config.devtools) {\r\n    devtools.emit('flush');\r\n  }\r\n}\r\n\r\nfunction callUpdatedHooks (queue) {\r\n  var i = queue.length;\r\n  while (i--) {\r\n    var watcher = queue[i];\r\n    var vm = watcher.vm;\r\n    if (vm._watcher === watcher && vm._isMounted) {\r\n      callHook(vm, 'updated');\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Queue a kept-alive component that was activated during patch.\r\n * The queue will be processed after the entire tree has been patched.\r\n */\r\nfunction queueActivatedComponent (vm) {\r\n  // setting _inactive to false here so that a render function can\r\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\r\n  vm._inactive = false;\r\n  activatedChildren.push(vm);\r\n}\r\n\r\nfunction callActivatedHooks (queue) {\r\n  for (var i = 0; i < queue.length; i++) {\r\n    queue[i]._inactive = true;\r\n    activateChildComponent(queue[i], true /* true */);\r\n  }\r\n}\r\n\r\n/**\r\n * Push a watcher into the watcher queue.\r\n * Jobs with duplicate IDs will be skipped unless it's\r\n * pushed when the queue is being flushed.\r\n */\r\nfunction queueWatcher (watcher) {\r\n  var id = watcher.id;\r\n  if (has[id] == null) {\r\n    has[id] = true;\r\n    if (!flushing) {\r\n      queue.push(watcher);\r\n    } else {\r\n      // if already flushing, splice the watcher based on its id\r\n      // if already past its id, it will be run next immediately.\r\n      var i = queue.length - 1;\r\n      while (i > index && queue[i].id > watcher.id) {\r\n        i--;\r\n      }\r\n      queue.splice(i + 1, 0, watcher);\r\n    }\r\n    // queue the flush\r\n    if (!waiting) {\r\n      waiting = true;\r\n      nextTick(flushSchedulerQueue);\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar uid$2 = 0;\r\n\r\n/**\r\n * A watcher parses an expression, collects dependencies,\r\n * and fires callback when the expression value changes.\r\n * This is used for both the $watch() api and directives.\r\n */\r\nvar Watcher = function Watcher (\r\n  vm,\r\n  expOrFn,\r\n  cb,\r\n  options\r\n) {\r\n  this.vm = vm;\r\n  vm._watchers.push(this);\r\n  // options\r\n  if (options) {\r\n    this.deep = !!options.deep;\r\n    this.user = !!options.user;\r\n    this.lazy = !!options.lazy;\r\n    this.sync = !!options.sync;\r\n  } else {\r\n    this.deep = this.user = this.lazy = this.sync = false;\r\n  }\r\n  this.cb = cb;\r\n  this.id = ++uid$2; // uid for batching\r\n  this.active = true;\r\n  this.dirty = this.lazy; // for lazy watchers\r\n  this.deps = [];\r\n  this.newDeps = [];\r\n  this.depIds = new _Set();\r\n  this.newDepIds = new _Set();\r\n  this.expression = process.env.NODE_ENV !== 'production'\r\n    ? expOrFn.toString()\r\n    : '';\r\n  // parse expression for getter\r\n  if (typeof expOrFn === 'function') {\r\n    this.getter = expOrFn;\r\n  } else {\r\n    this.getter = parsePath(expOrFn);\r\n    if (!this.getter) {\r\n      this.getter = function () {};\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\r\n        'Watcher only accepts simple dot-delimited paths. ' +\r\n        'For full control, use a function instead.',\r\n        vm\r\n      );\r\n    }\r\n  }\r\n  this.value = this.lazy\r\n    ? undefined\r\n    : this.get();\r\n};\r\n\r\n/**\r\n * Evaluate the getter, and re-collect dependencies.\r\n */\r\nWatcher.prototype.get = function get () {\r\n  pushTarget(this);\r\n  var value;\r\n  var vm = this.vm;\r\n  try {\r\n    value = this.getter.call(vm, vm);\r\n  } catch (e) {\r\n    if (this.user) {\r\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\r\n    } else {\r\n      throw e\r\n    }\r\n  } finally {\r\n    // \"touch\" every property so they are all tracked as\r\n    // dependencies for deep watching\r\n    if (this.deep) {\r\n      traverse(value);\r\n    }\r\n    popTarget();\r\n    this.cleanupDeps();\r\n  }\r\n  return value\r\n};\r\n\r\n/**\r\n * Add a dependency to this directive.\r\n */\r\nWatcher.prototype.addDep = function addDep (dep) {\r\n  var id = dep.id;\r\n  if (!this.newDepIds.has(id)) {\r\n    this.newDepIds.add(id);\r\n    this.newDeps.push(dep);\r\n    if (!this.depIds.has(id)) {\r\n      dep.addSub(this);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Clean up for dependency collection.\r\n */\r\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\r\n    var this$1 = this;\r\n\r\n  var i = this.deps.length;\r\n  while (i--) {\r\n    var dep = this$1.deps[i];\r\n    if (!this$1.newDepIds.has(dep.id)) {\r\n      dep.removeSub(this$1);\r\n    }\r\n  }\r\n  var tmp = this.depIds;\r\n  this.depIds = this.newDepIds;\r\n  this.newDepIds = tmp;\r\n  this.newDepIds.clear();\r\n  tmp = this.deps;\r\n  this.deps = this.newDeps;\r\n  this.newDeps = tmp;\r\n  this.newDeps.length = 0;\r\n};\r\n\r\n/**\r\n * Subscriber interface.\r\n * Will be called when a dependency changes.\r\n */\r\nWatcher.prototype.update = function update () {\r\n  /* istanbul ignore else */\r\n  if (this.lazy) {\r\n    this.dirty = true;\r\n  } else if (this.sync) {\r\n    this.run();\r\n  } else {\r\n    queueWatcher(this);\r\n  }\r\n};\r\n\r\n/**\r\n * Scheduler job interface.\r\n * Will be called by the scheduler.\r\n */\r\nWatcher.prototype.run = function run () {\r\n  if (this.active) {\r\n    var value = this.get();\r\n    if (\r\n      value !== this.value ||\r\n      // Deep watchers and watchers on Object/Arrays should fire even\r\n      // when the value is the same, because the value may\r\n      // have mutated.\r\n      isObject(value) ||\r\n      this.deep\r\n    ) {\r\n      // set new value\r\n      var oldValue = this.value;\r\n      this.value = value;\r\n      if (this.user) {\r\n        try {\r\n          this.cb.call(this.vm, value, oldValue);\r\n        } catch (e) {\r\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\r\n        }\r\n      } else {\r\n        this.cb.call(this.vm, value, oldValue);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Evaluate the value of the watcher.\r\n * This only gets called for lazy watchers.\r\n */\r\nWatcher.prototype.evaluate = function evaluate () {\r\n  this.value = this.get();\r\n  this.dirty = false;\r\n};\r\n\r\n/**\r\n * Depend on all deps collected by this watcher.\r\n */\r\nWatcher.prototype.depend = function depend () {\r\n    var this$1 = this;\r\n\r\n  var i = this.deps.length;\r\n  while (i--) {\r\n    this$1.deps[i].depend();\r\n  }\r\n};\r\n\r\n/**\r\n * Remove self from all dependencies' subscriber list.\r\n */\r\nWatcher.prototype.teardown = function teardown () {\r\n    var this$1 = this;\r\n\r\n  if (this.active) {\r\n    // remove self from vm's watcher list\r\n    // this is a somewhat expensive operation so we skip it\r\n    // if the vm is being destroyed.\r\n    if (!this.vm._isBeingDestroyed) {\r\n      remove(this.vm._watchers, this);\r\n    }\r\n    var i = this.deps.length;\r\n    while (i--) {\r\n      this$1.deps[i].removeSub(this$1);\r\n    }\r\n    this.active = false;\r\n  }\r\n};\r\n\r\n/**\r\n * Recursively traverse an object to evoke all converted\r\n * getters, so that every nested property inside the object\r\n * is collected as a \"deep\" dependency.\r\n */\r\nvar seenObjects = new _Set();\r\nfunction traverse (val) {\r\n  seenObjects.clear();\r\n  _traverse(val, seenObjects);\r\n}\r\n\r\nfunction _traverse (val, seen) {\r\n  var i, keys;\r\n  var isA = Array.isArray(val);\r\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\r\n    return\r\n  }\r\n  if (val.__ob__) {\r\n    var depId = val.__ob__.dep.id;\r\n    if (seen.has(depId)) {\r\n      return\r\n    }\r\n    seen.add(depId);\r\n  }\r\n  if (isA) {\r\n    i = val.length;\r\n    while (i--) { _traverse(val[i], seen); }\r\n  } else {\r\n    keys = Object.keys(val);\r\n    i = keys.length;\r\n    while (i--) { _traverse(val[keys[i]], seen); }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar sharedPropertyDefinition = {\r\n  enumerable: true,\r\n  configurable: true,\r\n  get: noop,\r\n  set: noop\r\n};\r\n\r\nfunction proxy (target, sourceKey, key) {\r\n  sharedPropertyDefinition.get = function proxyGetter () {\r\n    return this[sourceKey][key]\r\n  };\r\n  sharedPropertyDefinition.set = function proxySetter (val) {\r\n    this[sourceKey][key] = val;\r\n  };\r\n  Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\n\r\nfunction initState (vm) {\r\n  vm._watchers = [];\r\n  var opts = vm.$options;\r\n  if (opts.props) { initProps(vm, opts.props); }\r\n  if (opts.methods) { initMethods(vm, opts.methods); }\r\n  if (opts.data) {\r\n    initData(vm);\r\n  } else {\r\n    observe(vm._data = {}, true /* asRootData */);\r\n  }\r\n  if (opts.computed) { initComputed(vm, opts.computed); }\r\n  if (opts.watch && opts.watch !== nativeWatch) {\r\n    initWatch(vm, opts.watch);\r\n  }\r\n}\r\n\r\nfunction checkOptionType (vm, name) {\r\n  var option = vm.$options[name];\r\n  if (!isPlainObject(option)) {\r\n    warn(\r\n      (\"component option \\\"\" + name + \"\\\" should be an object.\"),\r\n      vm\r\n    );\r\n  }\r\n}\r\n\r\nfunction initProps (vm, propsOptions) {\r\n  var propsData = vm.$options.propsData || {};\r\n  var props = vm._props = {};\r\n  // cache prop keys so that future props updates can iterate using Array\r\n  // instead of dynamic object key enumeration.\r\n  var keys = vm.$options._propKeys = [];\r\n  var isRoot = !vm.$parent;\r\n  // root instance props should be converted\r\n  observerState.shouldConvert = isRoot;\r\n  var loop = function ( key ) {\r\n    keys.push(key);\r\n    var value = validateProp(key, propsOptions, propsData, vm);\r\n    /* istanbul ignore else */\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (isReservedAttribute(key) || config.isReservedAttr(key)) {\r\n        warn(\r\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\r\n          vm\r\n        );\r\n      }\r\n      defineReactive$$1(props, key, value, function () {\r\n        if (vm.$parent && !isUpdatingChildComponent) {\r\n          warn(\r\n            \"Avoid mutating a prop directly since the value will be \" +\r\n            \"overwritten whenever the parent component re-renders. \" +\r\n            \"Instead, use a data or computed property based on the prop's \" +\r\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\r\n            vm\r\n          );\r\n        }\r\n      });\r\n    } else {\r\n      defineReactive$$1(props, key, value);\r\n    }\r\n    // static props are already proxied on the component's prototype\r\n    // during Vue.extend(). We only need to proxy props defined at\r\n    // instantiation here.\r\n    if (!(key in vm)) {\r\n      proxy(vm, \"_props\", key);\r\n    }\r\n  };\r\n\r\n  for (var key in propsOptions) loop( key );\r\n  observerState.shouldConvert = true;\r\n}\r\n\r\nfunction initData (vm) {\r\n  var data = vm.$options.data;\r\n  data = vm._data = typeof data === 'function'\r\n    ? getData(data, vm)\r\n    : data || {};\r\n  if (!isPlainObject(data)) {\r\n    data = {};\r\n    process.env.NODE_ENV !== 'production' && warn(\r\n      'data functions should return an object:\\n' +\r\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\r\n      vm\r\n    );\r\n  }\r\n  // proxy data on instance\r\n  var keys = Object.keys(data);\r\n  var props = vm.$options.props;\r\n  var methods = vm.$options.methods;\r\n  var i = keys.length;\r\n  while (i--) {\r\n    var key = keys[i];\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (methods && hasOwn(methods, key)) {\r\n        warn(\r\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\r\n          vm\r\n        );\r\n      }\r\n    }\r\n    if (props && hasOwn(props, key)) {\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\r\n        \"Use prop default value instead.\",\r\n        vm\r\n      );\r\n    } else if (!isReserved(key)) {\r\n      proxy(vm, \"_data\", key);\r\n    }\r\n  }\r\n  // observe data\r\n  observe(data, true /* asRootData */);\r\n}\r\n\r\nfunction getData (data, vm) {\r\n  try {\r\n    return data.call(vm)\r\n  } catch (e) {\r\n    handleError(e, vm, \"data()\");\r\n    return {}\r\n  }\r\n}\r\n\r\nvar computedWatcherOptions = { lazy: true };\r\n\r\nfunction initComputed (vm, computed) {\r\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');\r\n  var watchers = vm._computedWatchers = Object.create(null);\r\n  // computed properties are just getters during SSR\r\n  var isSSR = isServerRendering();\r\n\r\n  for (var key in computed) {\r\n    var userDef = computed[key];\r\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\r\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\r\n      warn(\r\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\r\n        vm\r\n      );\r\n    }\r\n\r\n    if (!isSSR) {\r\n      // create internal watcher for the computed property.\r\n      watchers[key] = new Watcher(\r\n        vm,\r\n        getter || noop,\r\n        noop,\r\n        computedWatcherOptions\r\n      );\r\n    }\r\n\r\n    // component-defined computed properties are already defined on the\r\n    // component prototype. We only need to define computed properties defined\r\n    // at instantiation here.\r\n    if (!(key in vm)) {\r\n      defineComputed(vm, key, userDef);\r\n    } else if (process.env.NODE_ENV !== 'production') {\r\n      if (key in vm.$data) {\r\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\r\n      } else if (vm.$options.props && key in vm.$options.props) {\r\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction defineComputed (\r\n  target,\r\n  key,\r\n  userDef\r\n) {\r\n  var shouldCache = !isServerRendering();\r\n  if (typeof userDef === 'function') {\r\n    sharedPropertyDefinition.get = shouldCache\r\n      ? createComputedGetter(key)\r\n      : userDef;\r\n    sharedPropertyDefinition.set = noop;\r\n  } else {\r\n    sharedPropertyDefinition.get = userDef.get\r\n      ? shouldCache && userDef.cache !== false\r\n        ? createComputedGetter(key)\r\n        : userDef.get\r\n      : noop;\r\n    sharedPropertyDefinition.set = userDef.set\r\n      ? userDef.set\r\n      : noop;\r\n  }\r\n  if (process.env.NODE_ENV !== 'production' &&\r\n      sharedPropertyDefinition.set === noop) {\r\n    sharedPropertyDefinition.set = function () {\r\n      warn(\r\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\r\n        this\r\n      );\r\n    };\r\n  }\r\n  Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\n\r\nfunction createComputedGetter (key) {\r\n  return function computedGetter () {\r\n    var watcher = this._computedWatchers && this._computedWatchers[key];\r\n    if (watcher) {\r\n      if (watcher.dirty) {\r\n        watcher.evaluate();\r\n      }\r\n      if (Dep.target) {\r\n        watcher.depend();\r\n      }\r\n      return watcher.value\r\n    }\r\n  }\r\n}\r\n\r\nfunction initMethods (vm, methods) {\r\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');\r\n  var props = vm.$options.props;\r\n  for (var key in methods) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (methods[key] == null) {\r\n        warn(\r\n          \"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\r\n          \"Did you reference the function correctly?\",\r\n          vm\r\n        );\r\n      }\r\n      if (props && hasOwn(props, key)) {\r\n        warn(\r\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\r\n          vm\r\n        );\r\n      }\r\n      if ((key in vm) && isReserved(key)) {\r\n        warn(\r\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\r\n          \"Avoid defining component methods that start with _ or $.\"\r\n        );\r\n      }\r\n    }\r\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\r\n  }\r\n}\r\n\r\nfunction initWatch (vm, watch) {\r\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');\r\n  for (var key in watch) {\r\n    var handler = watch[key];\r\n    if (Array.isArray(handler)) {\r\n      for (var i = 0; i < handler.length; i++) {\r\n        createWatcher(vm, key, handler[i]);\r\n      }\r\n    } else {\r\n      createWatcher(vm, key, handler);\r\n    }\r\n  }\r\n}\r\n\r\nfunction createWatcher (\r\n  vm,\r\n  keyOrFn,\r\n  handler,\r\n  options\r\n) {\r\n  if (isPlainObject(handler)) {\r\n    options = handler;\r\n    handler = handler.handler;\r\n  }\r\n  if (typeof handler === 'string') {\r\n    handler = vm[handler];\r\n  }\r\n  return vm.$watch(keyOrFn, handler, options)\r\n}\r\n\r\nfunction stateMixin (Vue) {\r\n  // flow somehow has problems with directly declared definition object\r\n  // when using Object.defineProperty, so we have to procedurally build up\r\n  // the object here.\r\n  var dataDef = {};\r\n  dataDef.get = function () { return this._data };\r\n  var propsDef = {};\r\n  propsDef.get = function () { return this._props };\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    dataDef.set = function (newData) {\r\n      warn(\r\n        'Avoid replacing instance root $data. ' +\r\n        'Use nested data properties instead.',\r\n        this\r\n      );\r\n    };\r\n    propsDef.set = function () {\r\n      warn(\"$props is readonly.\", this);\r\n    };\r\n  }\r\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\r\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\r\n\r\n  Vue.prototype.$set = set;\r\n  Vue.prototype.$delete = del;\r\n\r\n  Vue.prototype.$watch = function (\r\n    expOrFn,\r\n    cb,\r\n    options\r\n  ) {\r\n    var vm = this;\r\n    if (isPlainObject(cb)) {\r\n      return createWatcher(vm, expOrFn, cb, options)\r\n    }\r\n    options = options || {};\r\n    options.user = true;\r\n    var watcher = new Watcher(vm, expOrFn, cb, options);\r\n    if (options.immediate) {\r\n      cb.call(vm, watcher.value);\r\n    }\r\n    return function unwatchFn () {\r\n      watcher.teardown();\r\n    }\r\n  };\r\n}\r\n\r\n/*  */\r\n\r\nfunction initProvide (vm) {\r\n  var provide = vm.$options.provide;\r\n  if (provide) {\r\n    vm._provided = typeof provide === 'function'\r\n      ? provide.call(vm)\r\n      : provide;\r\n  }\r\n}\r\n\r\nfunction initInjections (vm) {\r\n  var result = resolveInject(vm.$options.inject, vm);\r\n  if (result) {\r\n    observerState.shouldConvert = false;\r\n    Object.keys(result).forEach(function (key) {\r\n      /* istanbul ignore else */\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        defineReactive$$1(vm, key, result[key], function () {\r\n          warn(\r\n            \"Avoid mutating an injected value directly since the changes will be \" +\r\n            \"overwritten whenever the provided component re-renders. \" +\r\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\r\n            vm\r\n          );\r\n        });\r\n      } else {\r\n        defineReactive$$1(vm, key, result[key]);\r\n      }\r\n    });\r\n    observerState.shouldConvert = true;\r\n  }\r\n}\r\n\r\nfunction resolveInject (inject, vm) {\r\n  if (inject) {\r\n    // inject is :any because flow is not smart enough to figure out cached\r\n    var result = Object.create(null);\r\n    var keys = hasSymbol\r\n        ? Reflect.ownKeys(inject).filter(function (key) {\r\n          /* istanbul ignore next */\r\n          return Object.getOwnPropertyDescriptor(inject, key).enumerable\r\n        })\r\n        : Object.keys(inject);\r\n\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n      var provideKey = inject[key];\r\n      var source = vm;\r\n      while (source) {\r\n        if (source._provided && provideKey in source._provided) {\r\n          result[key] = source._provided[provideKey];\r\n          break\r\n        }\r\n        source = source.$parent;\r\n      }\r\n      if (process.env.NODE_ENV !== 'production' && !source) {\r\n        warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\r\n      }\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction createFunctionalComponent (\r\n  Ctor,\r\n  propsData,\r\n  data,\r\n  context,\r\n  children\r\n) {\r\n  var props = {};\r\n  var propOptions = Ctor.options.props;\r\n  if (isDef(propOptions)) {\r\n    for (var key in propOptions) {\r\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\r\n    }\r\n  } else {\r\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\r\n    if (isDef(data.props)) { mergeProps(props, data.props); }\r\n  }\r\n  // ensure the createElement function in functional components\r\n  // gets a unique context - this is necessary for correct named slot check\r\n  var _context = Object.create(context);\r\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\r\n  var vnode = Ctor.options.render.call(null, h, {\r\n    data: data,\r\n    props: props,\r\n    children: children,\r\n    parent: context,\r\n    listeners: data.on || emptyObject,\r\n    injections: resolveInject(Ctor.options.inject, context),\r\n    slots: function () { return resolveSlots(children, context); }\r\n  });\r\n  if (vnode instanceof VNode) {\r\n    vnode.functionalContext = context;\r\n    vnode.functionalOptions = Ctor.options;\r\n    if (data.slot) {\r\n      (vnode.data || (vnode.data = {})).slot = data.slot;\r\n    }\r\n  }\r\n  return vnode\r\n}\r\n\r\nfunction mergeProps (to, from) {\r\n  for (var key in from) {\r\n    to[camelize(key)] = from[key];\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n// hooks to be invoked on component VNodes during patch\r\nvar componentVNodeHooks = {\r\n  init: function init (\r\n    vnode,\r\n    hydrating,\r\n    parentElm,\r\n    refElm\r\n  ) {\r\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\r\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\r\n        vnode,\r\n        activeInstance,\r\n        parentElm,\r\n        refElm\r\n      );\r\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\r\n    } else if (vnode.data.keepAlive) {\r\n      // kept-alive components, treat as a patch\r\n      var mountedNode = vnode; // work around flow\r\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\r\n    }\r\n  },\r\n\r\n  prepatch: function prepatch (oldVnode, vnode) {\r\n    var options = vnode.componentOptions;\r\n    var child = vnode.componentInstance = oldVnode.componentInstance;\r\n    updateChildComponent(\r\n      child,\r\n      options.propsData, // updated props\r\n      options.listeners, // updated listeners\r\n      vnode, // new parent vnode\r\n      options.children // new children\r\n    );\r\n  },\r\n\r\n  insert: function insert (vnode) {\r\n    var context = vnode.context;\r\n    var componentInstance = vnode.componentInstance;\r\n    if (!componentInstance._isMounted) {\r\n      componentInstance._isMounted = true;\r\n      callHook(componentInstance, 'mounted');\r\n    }\r\n    if (vnode.data.keepAlive) {\r\n      if (context._isMounted) {\r\n        // vue-router#1212\r\n        // During updates, a kept-alive component's child components may\r\n        // change, so directly walking the tree here may call activated hooks\r\n        // on incorrect children. Instead we push them into a queue which will\r\n        // be processed after the whole patch process ended.\r\n        queueActivatedComponent(componentInstance);\r\n      } else {\r\n        activateChildComponent(componentInstance, true /* direct */);\r\n      }\r\n    }\r\n  },\r\n\r\n  destroy: function destroy (vnode) {\r\n    var componentInstance = vnode.componentInstance;\r\n    if (!componentInstance._isDestroyed) {\r\n      if (!vnode.data.keepAlive) {\r\n        componentInstance.$destroy();\r\n      } else {\r\n        deactivateChildComponent(componentInstance, true /* direct */);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nvar hooksToMerge = Object.keys(componentVNodeHooks);\r\n\r\nfunction createComponent (\r\n  Ctor,\r\n  data,\r\n  context,\r\n  children,\r\n  tag\r\n) {\r\n  if (isUndef(Ctor)) {\r\n    return\r\n  }\r\n\r\n  var baseCtor = context.$options._base;\r\n\r\n  // plain options object: turn it into a constructor\r\n  if (isObject(Ctor)) {\r\n    Ctor = baseCtor.extend(Ctor);\r\n  }\r\n\r\n  // if at this stage it's not a constructor or an async component factory,\r\n  // reject.\r\n  if (typeof Ctor !== 'function') {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\r\n    }\r\n    return\r\n  }\r\n\r\n  // async component\r\n  var asyncFactory;\r\n  if (isUndef(Ctor.cid)) {\r\n    asyncFactory = Ctor;\r\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\r\n    if (Ctor === undefined) {\r\n      // return a placeholder node for async component, which is rendered\r\n      // as a comment node but preserves all the raw information for the node.\r\n      // the information will be used for async server-rendering and hydration.\r\n      return createAsyncPlaceholder(\r\n        asyncFactory,\r\n        data,\r\n        context,\r\n        children,\r\n        tag\r\n      )\r\n    }\r\n  }\r\n\r\n  data = data || {};\r\n\r\n  // resolve constructor options in case global mixins are applied after\r\n  // component constructor creation\r\n  resolveConstructorOptions(Ctor);\r\n\r\n  // transform component v-model data into props & events\r\n  if (isDef(data.model)) {\r\n    transformModel(Ctor.options, data);\r\n  }\r\n\r\n  // extract props\r\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\r\n\r\n  // functional component\r\n  if (isTrue(Ctor.options.functional)) {\r\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\r\n  }\r\n\r\n  // extract listeners, since these needs to be treated as\r\n  // child component listeners instead of DOM listeners\r\n  var listeners = data.on;\r\n  // replace with listeners with .native modifier\r\n  // so it gets processed during parent component patch.\r\n  data.on = data.nativeOn;\r\n\r\n  if (isTrue(Ctor.options.abstract)) {\r\n    // abstract components do not keep anything\r\n    // other than props & listeners & slot\r\n\r\n    // work around flow\r\n    var slot = data.slot;\r\n    data = {};\r\n    if (slot) {\r\n      data.slot = slot;\r\n    }\r\n  }\r\n\r\n  // merge component management hooks onto the placeholder node\r\n  mergeHooks(data);\r\n\r\n  // return a placeholder vnode\r\n  var name = Ctor.options.name || tag;\r\n  var vnode = new VNode(\r\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\r\n    data, undefined, undefined, undefined, context,\r\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\r\n    asyncFactory\r\n  );\r\n  return vnode\r\n}\r\n\r\nfunction createComponentInstanceForVnode (\r\n  vnode, // we know it's MountedComponentVNode but flow doesn't\r\n  parent, // activeInstance in lifecycle state\r\n  parentElm,\r\n  refElm\r\n) {\r\n  var vnodeComponentOptions = vnode.componentOptions;\r\n  var options = {\r\n    _isComponent: true,\r\n    parent: parent,\r\n    propsData: vnodeComponentOptions.propsData,\r\n    _componentTag: vnodeComponentOptions.tag,\r\n    _parentVnode: vnode,\r\n    _parentListeners: vnodeComponentOptions.listeners,\r\n    _renderChildren: vnodeComponentOptions.children,\r\n    _parentElm: parentElm || null,\r\n    _refElm: refElm || null\r\n  };\r\n  // check inline-template render functions\r\n  var inlineTemplate = vnode.data.inlineTemplate;\r\n  if (isDef(inlineTemplate)) {\r\n    options.render = inlineTemplate.render;\r\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\r\n  }\r\n  return new vnodeComponentOptions.Ctor(options)\r\n}\r\n\r\nfunction mergeHooks (data) {\r\n  if (!data.hook) {\r\n    data.hook = {};\r\n  }\r\n  for (var i = 0; i < hooksToMerge.length; i++) {\r\n    var key = hooksToMerge[i];\r\n    var fromParent = data.hook[key];\r\n    var ours = componentVNodeHooks[key];\r\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\r\n  }\r\n}\r\n\r\nfunction mergeHook$1 (one, two) {\r\n  return function (a, b, c, d) {\r\n    one(a, b, c, d);\r\n    two(a, b, c, d);\r\n  }\r\n}\r\n\r\n// transform component v-model info (value and callback) into\r\n// prop and event handler respectively.\r\nfunction transformModel (options, data) {\r\n  var prop = (options.model && options.model.prop) || 'value';\r\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\r\n  var on = data.on || (data.on = {});\r\n  if (isDef(on[event])) {\r\n    on[event] = [data.model.callback].concat(on[event]);\r\n  } else {\r\n    on[event] = data.model.callback;\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar SIMPLE_NORMALIZE = 1;\r\nvar ALWAYS_NORMALIZE = 2;\r\n\r\n// wrapper function for providing a more flexible interface\r\n// without getting yelled at by flow\r\nfunction createElement (\r\n  context,\r\n  tag,\r\n  data,\r\n  children,\r\n  normalizationType,\r\n  alwaysNormalize\r\n) {\r\n  if (Array.isArray(data) || isPrimitive(data)) {\r\n    normalizationType = children;\r\n    children = data;\r\n    data = undefined;\r\n  }\r\n  if (isTrue(alwaysNormalize)) {\r\n    normalizationType = ALWAYS_NORMALIZE;\r\n  }\r\n  return _createElement(context, tag, data, children, normalizationType)\r\n}\r\n\r\nfunction _createElement (\r\n  context,\r\n  tag,\r\n  data,\r\n  children,\r\n  normalizationType\r\n) {\r\n  if (isDef(data) && isDef((data).__ob__)) {\r\n    process.env.NODE_ENV !== 'production' && warn(\r\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\r\n      'Always create fresh vnode data objects in each render!',\r\n      context\r\n    );\r\n    return createEmptyVNode()\r\n  }\r\n  // object syntax in v-bind\r\n  if (isDef(data) && isDef(data.is)) {\r\n    tag = data.is;\r\n  }\r\n  if (!tag) {\r\n    // in case of component :is set to falsy value\r\n    return createEmptyVNode()\r\n  }\r\n  // warn against non-primitive key\r\n  if (process.env.NODE_ENV !== 'production' &&\r\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\r\n  ) {\r\n    warn(\r\n      'Avoid using non-primitive value as key, ' +\r\n      'use string/number value instead.',\r\n      context\r\n    );\r\n  }\r\n  // support single function children as default scoped slot\r\n  if (Array.isArray(children) &&\r\n    typeof children[0] === 'function'\r\n  ) {\r\n    data = data || {};\r\n    data.scopedSlots = { default: children[0] };\r\n    children.length = 0;\r\n  }\r\n  if (normalizationType === ALWAYS_NORMALIZE) {\r\n    children = normalizeChildren(children);\r\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\r\n    children = simpleNormalizeChildren(children);\r\n  }\r\n  var vnode, ns;\r\n  if (typeof tag === 'string') {\r\n    var Ctor;\r\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\r\n    if (config.isReservedTag(tag)) {\r\n      // platform built-in elements\r\n      vnode = new VNode(\r\n        config.parsePlatformTagName(tag), data, children,\r\n        undefined, undefined, context\r\n      );\r\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\r\n      // component\r\n      vnode = createComponent(Ctor, data, context, children, tag);\r\n    } else {\r\n      // unknown or unlisted namespaced elements\r\n      // check at runtime because it may get assigned a namespace when its\r\n      // parent normalizes children\r\n      vnode = new VNode(\r\n        tag, data, children,\r\n        undefined, undefined, context\r\n      );\r\n    }\r\n  } else {\r\n    // direct component options / constructor\r\n    vnode = createComponent(tag, data, context, children);\r\n  }\r\n  if (isDef(vnode)) {\r\n    if (ns) { applyNS(vnode, ns); }\r\n    return vnode\r\n  } else {\r\n    return createEmptyVNode()\r\n  }\r\n}\r\n\r\nfunction applyNS (vnode, ns) {\r\n  vnode.ns = ns;\r\n  if (vnode.tag === 'foreignObject') {\r\n    // use default namespace inside foreignObject\r\n    return\r\n  }\r\n  if (isDef(vnode.children)) {\r\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\r\n      var child = vnode.children[i];\r\n      if (isDef(child.tag) && isUndef(child.ns)) {\r\n        applyNS(child, ns);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Runtime helper for rendering v-for lists.\r\n */\r\nfunction renderList (\r\n  val,\r\n  render\r\n) {\r\n  var ret, i, l, keys, key;\r\n  if (Array.isArray(val) || typeof val === 'string') {\r\n    ret = new Array(val.length);\r\n    for (i = 0, l = val.length; i < l; i++) {\r\n      ret[i] = render(val[i], i);\r\n    }\r\n  } else if (typeof val === 'number') {\r\n    ret = new Array(val);\r\n    for (i = 0; i < val; i++) {\r\n      ret[i] = render(i + 1, i);\r\n    }\r\n  } else if (isObject(val)) {\r\n    keys = Object.keys(val);\r\n    ret = new Array(keys.length);\r\n    for (i = 0, l = keys.length; i < l; i++) {\r\n      key = keys[i];\r\n      ret[i] = render(val[key], key, i);\r\n    }\r\n  }\r\n  if (isDef(ret)) {\r\n    (ret)._isVList = true;\r\n  }\r\n  return ret\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Runtime helper for rendering <slot>\r\n */\r\nfunction renderSlot (\r\n  name,\r\n  fallback,\r\n  props,\r\n  bindObject\r\n) {\r\n  var scopedSlotFn = this.$scopedSlots[name];\r\n  if (scopedSlotFn) { // scoped slot\r\n    props = props || {};\r\n    if (bindObject) {\r\n      props = extend(extend({}, bindObject), props);\r\n    }\r\n    return scopedSlotFn(props) || fallback\r\n  } else {\r\n    var slotNodes = this.$slots[name];\r\n    // warn duplicate slot usage\r\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\r\n      slotNodes._rendered && warn(\r\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\r\n        \"- this will likely cause render errors.\",\r\n        this\r\n      );\r\n      slotNodes._rendered = true;\r\n    }\r\n    return slotNodes || fallback\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Runtime helper for resolving filters\r\n */\r\nfunction resolveFilter (id) {\r\n  return resolveAsset(this.$options, 'filters', id, true) || identity\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Runtime helper for checking keyCodes from config.\r\n */\r\nfunction checkKeyCodes (\r\n  eventKeyCode,\r\n  key,\r\n  builtInAlias\r\n) {\r\n  var keyCodes = config.keyCodes[key] || builtInAlias;\r\n  if (Array.isArray(keyCodes)) {\r\n    return keyCodes.indexOf(eventKeyCode) === -1\r\n  } else {\r\n    return keyCodes !== eventKeyCode\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\r\n */\r\nfunction bindObjectProps (\r\n  data,\r\n  tag,\r\n  value,\r\n  asProp,\r\n  isSync\r\n) {\r\n  if (value) {\r\n    if (!isObject(value)) {\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        'v-bind without argument expects an Object or Array value',\r\n        this\r\n      );\r\n    } else {\r\n      if (Array.isArray(value)) {\r\n        value = toObject(value);\r\n      }\r\n      var hash;\r\n      var loop = function ( key ) {\r\n        if (\r\n          key === 'class' ||\r\n          key === 'style' ||\r\n          isReservedAttribute(key)\r\n        ) {\r\n          hash = data;\r\n        } else {\r\n          var type = data.attrs && data.attrs.type;\r\n          hash = asProp || config.mustUseProp(tag, type, key)\r\n            ? data.domProps || (data.domProps = {})\r\n            : data.attrs || (data.attrs = {});\r\n        }\r\n        if (!(key in hash)) {\r\n          hash[key] = value[key];\r\n\r\n          if (isSync) {\r\n            var on = data.on || (data.on = {});\r\n            on[(\"update:\" + key)] = function ($event) {\r\n              value[key] = $event;\r\n            };\r\n          }\r\n        }\r\n      };\r\n\r\n      for (var key in value) loop( key );\r\n    }\r\n  }\r\n  return data\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Runtime helper for rendering static trees.\r\n */\r\nfunction renderStatic (\r\n  index,\r\n  isInFor\r\n) {\r\n  var tree = this._staticTrees[index];\r\n  // if has already-rendered static tree and not inside v-for,\r\n  // we can reuse the same tree by doing a shallow clone.\r\n  if (tree && !isInFor) {\r\n    return Array.isArray(tree)\r\n      ? cloneVNodes(tree)\r\n      : cloneVNode(tree)\r\n  }\r\n  // otherwise, render a fresh tree.\r\n  tree = this._staticTrees[index] =\r\n    this.$options.staticRenderFns[index].call(this._renderProxy);\r\n  markStatic(tree, (\"__static__\" + index), false);\r\n  return tree\r\n}\r\n\r\n/**\r\n * Runtime helper for v-once.\r\n * Effectively it means marking the node as static with a unique key.\r\n */\r\nfunction markOnce (\r\n  tree,\r\n  index,\r\n  key\r\n) {\r\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\r\n  return tree\r\n}\r\n\r\nfunction markStatic (\r\n  tree,\r\n  key,\r\n  isOnce\r\n) {\r\n  if (Array.isArray(tree)) {\r\n    for (var i = 0; i < tree.length; i++) {\r\n      if (tree[i] && typeof tree[i] !== 'string') {\r\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\r\n      }\r\n    }\r\n  } else {\r\n    markStaticNode(tree, key, isOnce);\r\n  }\r\n}\r\n\r\nfunction markStaticNode (node, key, isOnce) {\r\n  node.isStatic = true;\r\n  node.key = key;\r\n  node.isOnce = isOnce;\r\n}\r\n\r\n/*  */\r\n\r\nfunction bindObjectListeners (data, value) {\r\n  if (value) {\r\n    if (!isPlainObject(value)) {\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        'v-on without argument expects an Object value',\r\n        this\r\n      );\r\n    } else {\r\n      var on = data.on = data.on ? extend({}, data.on) : {};\r\n      for (var key in value) {\r\n        var existing = on[key];\r\n        var ours = value[key];\r\n        on[key] = existing ? [].concat(ours, existing) : ours;\r\n      }\r\n    }\r\n  }\r\n  return data\r\n}\r\n\r\n/*  */\r\n\r\nfunction initRender (vm) {\r\n  vm._vnode = null; // the root of the child tree\r\n  vm._staticTrees = null;\r\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\r\n  var renderContext = parentVnode && parentVnode.context;\r\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\r\n  vm.$scopedSlots = emptyObject;\r\n  // bind the createElement fn to this instance\r\n  // so that we get proper render context inside it.\r\n  // args order: tag, data, children, normalizationType, alwaysNormalize\r\n  // internal version is used by render functions compiled from templates\r\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\r\n  // normalization is always applied for the public version, used in\r\n  // user-written render functions.\r\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\r\n\r\n  // $attrs & $listeners are exposed for easier HOC creation.\r\n  // they need to be reactive so that HOCs using them are always updated\r\n  var parentData = parentVnode && parentVnode.data;\r\n\r\n  /* istanbul ignore else */\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\r\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\r\n    }, true);\r\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, function () {\r\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\r\n    }, true);\r\n  } else {\r\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\r\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, null, true);\r\n  }\r\n}\r\n\r\nfunction renderMixin (Vue) {\r\n  Vue.prototype.$nextTick = function (fn) {\r\n    return nextTick(fn, this)\r\n  };\r\n\r\n  Vue.prototype._render = function () {\r\n    var vm = this;\r\n    var ref = vm.$options;\r\n    var render = ref.render;\r\n    var staticRenderFns = ref.staticRenderFns;\r\n    var _parentVnode = ref._parentVnode;\r\n\r\n    if (vm._isMounted) {\r\n      // if the parent didn't update, the slot nodes will be the ones from\r\n      // last render. They need to be cloned to ensure \"freshness\" for this render.\r\n      for (var key in vm.$slots) {\r\n        var slot = vm.$slots[key];\r\n        if (slot._rendered) {\r\n          vm.$slots[key] = cloneVNodes(slot, true /* deep */);\r\n        }\r\n      }\r\n    }\r\n\r\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\r\n\r\n    if (staticRenderFns && !vm._staticTrees) {\r\n      vm._staticTrees = [];\r\n    }\r\n    // set parent vnode. this allows render functions to have access\r\n    // to the data on the placeholder node.\r\n    vm.$vnode = _parentVnode;\r\n    // render self\r\n    var vnode;\r\n    try {\r\n      vnode = render.call(vm._renderProxy, vm.$createElement);\r\n    } catch (e) {\r\n      handleError(e, vm, \"render function\");\r\n      // return error render result,\r\n      // or previous vnode to prevent render error causing blank component\r\n      /* istanbul ignore else */\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        vnode = vm.$options.renderError\r\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\r\n          : vm._vnode;\r\n      } else {\r\n        vnode = vm._vnode;\r\n      }\r\n    }\r\n    // return empty vnode in case the render function errored out\r\n    if (!(vnode instanceof VNode)) {\r\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\r\n        warn(\r\n          'Multiple root nodes returned from render function. Render function ' +\r\n          'should return a single root node.',\r\n          vm\r\n        );\r\n      }\r\n      vnode = createEmptyVNode();\r\n    }\r\n    // set parent\r\n    vnode.parent = _parentVnode;\r\n    return vnode\r\n  };\r\n\r\n  // internal render helpers.\r\n  // these are exposed on the instance prototype to reduce generated render\r\n  // code size.\r\n  Vue.prototype._o = markOnce;\r\n  Vue.prototype._n = toNumber;\r\n  Vue.prototype._s = toString;\r\n  Vue.prototype._l = renderList;\r\n  Vue.prototype._t = renderSlot;\r\n  Vue.prototype._q = looseEqual;\r\n  Vue.prototype._i = looseIndexOf;\r\n  Vue.prototype._m = renderStatic;\r\n  Vue.prototype._f = resolveFilter;\r\n  Vue.prototype._k = checkKeyCodes;\r\n  Vue.prototype._b = bindObjectProps;\r\n  Vue.prototype._v = createTextVNode;\r\n  Vue.prototype._e = createEmptyVNode;\r\n  Vue.prototype._u = resolveScopedSlots;\r\n  Vue.prototype._g = bindObjectListeners;\r\n}\r\n\r\n/*  */\r\n\r\nvar uid$1 = 0;\r\n\r\nfunction initMixin (Vue) {\r\n  Vue.prototype._init = function (options) {\r\n    var vm = this;\r\n    // a uid\r\n    vm._uid = uid$1++;\r\n\r\n    var startTag, endTag;\r\n    /* istanbul ignore if */\r\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\r\n      startTag = \"vue-perf-init:\" + (vm._uid);\r\n      endTag = \"vue-perf-end:\" + (vm._uid);\r\n      mark(startTag);\r\n    }\r\n\r\n    // a flag to avoid this being observed\r\n    vm._isVue = true;\r\n    // merge options\r\n    if (options && options._isComponent) {\r\n      // optimize internal component instantiation\r\n      // since dynamic options merging is pretty slow, and none of the\r\n      // internal component options needs special treatment.\r\n      initInternalComponent(vm, options);\r\n    } else {\r\n      vm.$options = mergeOptions(\r\n        resolveConstructorOptions(vm.constructor),\r\n        options || {},\r\n        vm\r\n      );\r\n    }\r\n    /* istanbul ignore else */\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      initProxy(vm);\r\n    } else {\r\n      vm._renderProxy = vm;\r\n    }\r\n    // expose real self\r\n    vm._self = vm;\r\n    initLifecycle(vm);\r\n    initEvents(vm);\r\n    initRender(vm);\r\n    callHook(vm, 'beforeCreate');\r\n    initInjections(vm); // resolve injections before data/props\r\n    initState(vm);\r\n    initProvide(vm); // resolve provide after data/props\r\n    callHook(vm, 'created');\r\n\r\n    /* istanbul ignore if */\r\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\r\n      vm._name = formatComponentName(vm, false);\r\n      mark(endTag);\r\n      measure(((vm._name) + \" init\"), startTag, endTag);\r\n    }\r\n\r\n    if (vm.$options.el) {\r\n      vm.$mount(vm.$options.el);\r\n    }\r\n  };\r\n}\r\n\r\nfunction initInternalComponent (vm, options) {\r\n  var opts = vm.$options = Object.create(vm.constructor.options);\r\n  // doing this because it's faster than dynamic enumeration.\r\n  opts.parent = options.parent;\r\n  opts.propsData = options.propsData;\r\n  opts._parentVnode = options._parentVnode;\r\n  opts._parentListeners = options._parentListeners;\r\n  opts._renderChildren = options._renderChildren;\r\n  opts._componentTag = options._componentTag;\r\n  opts._parentElm = options._parentElm;\r\n  opts._refElm = options._refElm;\r\n  if (options.render) {\r\n    opts.render = options.render;\r\n    opts.staticRenderFns = options.staticRenderFns;\r\n  }\r\n}\r\n\r\nfunction resolveConstructorOptions (Ctor) {\r\n  var options = Ctor.options;\r\n  if (Ctor.super) {\r\n    var superOptions = resolveConstructorOptions(Ctor.super);\r\n    var cachedSuperOptions = Ctor.superOptions;\r\n    if (superOptions !== cachedSuperOptions) {\r\n      // super option changed,\r\n      // need to resolve new options.\r\n      Ctor.superOptions = superOptions;\r\n      // check if there are any late-modified/attached options (#4976)\r\n      var modifiedOptions = resolveModifiedOptions(Ctor);\r\n      // update base extend options\r\n      if (modifiedOptions) {\r\n        extend(Ctor.extendOptions, modifiedOptions);\r\n      }\r\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\r\n      if (options.name) {\r\n        options.components[options.name] = Ctor;\r\n      }\r\n    }\r\n  }\r\n  return options\r\n}\r\n\r\nfunction resolveModifiedOptions (Ctor) {\r\n  var modified;\r\n  var latest = Ctor.options;\r\n  var extended = Ctor.extendOptions;\r\n  var sealed = Ctor.sealedOptions;\r\n  for (var key in latest) {\r\n    if (latest[key] !== sealed[key]) {\r\n      if (!modified) { modified = {}; }\r\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\r\n    }\r\n  }\r\n  return modified\r\n}\r\n\r\nfunction dedupe (latest, extended, sealed) {\r\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\r\n  // between merges\r\n  if (Array.isArray(latest)) {\r\n    var res = [];\r\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\r\n    extended = Array.isArray(extended) ? extended : [extended];\r\n    for (var i = 0; i < latest.length; i++) {\r\n      // push original options and not sealed options to exclude duplicated options\r\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\r\n        res.push(latest[i]);\r\n      }\r\n    }\r\n    return res\r\n  } else {\r\n    return latest\r\n  }\r\n}\r\n\r\nfunction Vue$3 (options) {\r\n  if (process.env.NODE_ENV !== 'production' &&\r\n    !(this instanceof Vue$3)\r\n  ) {\r\n    warn('Vue is a constructor and should be called with the `new` keyword');\r\n  }\r\n  this._init(options);\r\n}\r\n\r\ninitMixin(Vue$3);\r\nstateMixin(Vue$3);\r\neventsMixin(Vue$3);\r\nlifecycleMixin(Vue$3);\r\nrenderMixin(Vue$3);\r\n\r\n/*  */\r\n\r\nfunction initUse (Vue) {\r\n  Vue.use = function (plugin) {\r\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\r\n    if (installedPlugins.indexOf(plugin) > -1) {\r\n      return this\r\n    }\r\n\r\n    // additional parameters\r\n    var args = toArray(arguments, 1);\r\n    args.unshift(this);\r\n    if (typeof plugin.install === 'function') {\r\n      plugin.install.apply(plugin, args);\r\n    } else if (typeof plugin === 'function') {\r\n      plugin.apply(null, args);\r\n    }\r\n    installedPlugins.push(plugin);\r\n    return this\r\n  };\r\n}\r\n\r\n/*  */\r\n\r\nfunction initMixin$1 (Vue) {\r\n  Vue.mixin = function (mixin) {\r\n    this.options = mergeOptions(this.options, mixin);\r\n    return this\r\n  };\r\n}\r\n\r\n/*  */\r\n\r\nfunction initExtend (Vue) {\r\n  /**\r\n   * Each instance constructor, including Vue, has a unique\r\n   * cid. This enables us to create wrapped \"child\r\n   * constructors\" for prototypal inheritance and cache them.\r\n   */\r\n  Vue.cid = 0;\r\n  var cid = 1;\r\n\r\n  /**\r\n   * Class inheritance\r\n   */\r\n  Vue.extend = function (extendOptions) {\r\n    extendOptions = extendOptions || {};\r\n    var Super = this;\r\n    var SuperId = Super.cid;\r\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\r\n    if (cachedCtors[SuperId]) {\r\n      return cachedCtors[SuperId]\r\n    }\r\n\r\n    var name = extendOptions.name || Super.options.name;\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\r\n        warn(\r\n          'Invalid component name: \"' + name + '\". Component names ' +\r\n          'can only contain alphanumeric characters and the hyphen, ' +\r\n          'and must start with a letter.'\r\n        );\r\n      }\r\n    }\r\n\r\n    var Sub = function VueComponent (options) {\r\n      this._init(options);\r\n    };\r\n    Sub.prototype = Object.create(Super.prototype);\r\n    Sub.prototype.constructor = Sub;\r\n    Sub.cid = cid++;\r\n    Sub.options = mergeOptions(\r\n      Super.options,\r\n      extendOptions\r\n    );\r\n    Sub['super'] = Super;\r\n\r\n    // For props and computed properties, we define the proxy getters on\r\n    // the Vue instances at extension time, on the extended prototype. This\r\n    // avoids Object.defineProperty calls for each instance created.\r\n    if (Sub.options.props) {\r\n      initProps$1(Sub);\r\n    }\r\n    if (Sub.options.computed) {\r\n      initComputed$1(Sub);\r\n    }\r\n\r\n    // allow further extension/mixin/plugin usage\r\n    Sub.extend = Super.extend;\r\n    Sub.mixin = Super.mixin;\r\n    Sub.use = Super.use;\r\n\r\n    // create asset registers, so extended classes\r\n    // can have their private assets too.\r\n    ASSET_TYPES.forEach(function (type) {\r\n      Sub[type] = Super[type];\r\n    });\r\n    // enable recursive self-lookup\r\n    if (name) {\r\n      Sub.options.components[name] = Sub;\r\n    }\r\n\r\n    // keep a reference to the super options at extension time.\r\n    // later at instantiation we can check if Super's options have\r\n    // been updated.\r\n    Sub.superOptions = Super.options;\r\n    Sub.extendOptions = extendOptions;\r\n    Sub.sealedOptions = extend({}, Sub.options);\r\n\r\n    // cache constructor\r\n    cachedCtors[SuperId] = Sub;\r\n    return Sub\r\n  };\r\n}\r\n\r\nfunction initProps$1 (Comp) {\r\n  var props = Comp.options.props;\r\n  for (var key in props) {\r\n    proxy(Comp.prototype, \"_props\", key);\r\n  }\r\n}\r\n\r\nfunction initComputed$1 (Comp) {\r\n  var computed = Comp.options.computed;\r\n  for (var key in computed) {\r\n    defineComputed(Comp.prototype, key, computed[key]);\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction initAssetRegisters (Vue) {\r\n  /**\r\n   * Create asset registration methods.\r\n   */\r\n  ASSET_TYPES.forEach(function (type) {\r\n    Vue[type] = function (\r\n      id,\r\n      definition\r\n    ) {\r\n      if (!definition) {\r\n        return this.options[type + 's'][id]\r\n      } else {\r\n        /* istanbul ignore if */\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          if (type === 'component' && config.isReservedTag(id)) {\r\n            warn(\r\n              'Do not use built-in or reserved HTML elements as component ' +\r\n              'id: ' + id\r\n            );\r\n          }\r\n        }\r\n        if (type === 'component' && isPlainObject(definition)) {\r\n          definition.name = definition.name || id;\r\n          definition = this.options._base.extend(definition);\r\n        }\r\n        if (type === 'directive' && typeof definition === 'function') {\r\n          definition = { bind: definition, update: definition };\r\n        }\r\n        this.options[type + 's'][id] = definition;\r\n        return definition\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/*  */\r\n\r\nvar patternTypes = [String, RegExp, Array];\r\n\r\nfunction getComponentName (opts) {\r\n  return opts && (opts.Ctor.options.name || opts.tag)\r\n}\r\n\r\nfunction matches (pattern, name) {\r\n  if (Array.isArray(pattern)) {\r\n    return pattern.indexOf(name) > -1\r\n  } else if (typeof pattern === 'string') {\r\n    return pattern.split(',').indexOf(name) > -1\r\n  } else if (isRegExp(pattern)) {\r\n    return pattern.test(name)\r\n  }\r\n  /* istanbul ignore next */\r\n  return false\r\n}\r\n\r\nfunction pruneCache (cache, current, filter) {\r\n  for (var key in cache) {\r\n    var cachedNode = cache[key];\r\n    if (cachedNode) {\r\n      var name = getComponentName(cachedNode.componentOptions);\r\n      if (name && !filter(name)) {\r\n        if (cachedNode !== current) {\r\n          pruneCacheEntry(cachedNode);\r\n        }\r\n        cache[key] = null;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction pruneCacheEntry (vnode) {\r\n  if (vnode) {\r\n    vnode.componentInstance.$destroy();\r\n  }\r\n}\r\n\r\nvar KeepAlive = {\r\n  name: 'keep-alive',\r\n  abstract: true,\r\n\r\n  props: {\r\n    include: patternTypes,\r\n    exclude: patternTypes\r\n  },\r\n\r\n  created: function created () {\r\n    this.cache = Object.create(null);\r\n  },\r\n\r\n  destroyed: function destroyed () {\r\n    var this$1 = this;\r\n\r\n    for (var key in this$1.cache) {\r\n      pruneCacheEntry(this$1.cache[key]);\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    include: function include (val) {\r\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\r\n    },\r\n    exclude: function exclude (val) {\r\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\r\n    }\r\n  },\r\n\r\n  render: function render () {\r\n    var vnode = getFirstComponentChild(this.$slots.default);\r\n    var componentOptions = vnode && vnode.componentOptions;\r\n    if (componentOptions) {\r\n      // check pattern\r\n      var name = getComponentName(componentOptions);\r\n      if (name && (\r\n        (this.include && !matches(this.include, name)) ||\r\n        (this.exclude && matches(this.exclude, name))\r\n      )) {\r\n        return vnode\r\n      }\r\n      var key = vnode.key == null\r\n        // same constructor may get registered as different local components\r\n        // so cid alone is not enough (#3269)\r\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\r\n        : vnode.key;\r\n      if (this.cache[key]) {\r\n        vnode.componentInstance = this.cache[key].componentInstance;\r\n      } else {\r\n        this.cache[key] = vnode;\r\n      }\r\n      vnode.data.keepAlive = true;\r\n    }\r\n    return vnode\r\n  }\r\n};\r\n\r\nvar builtInComponents = {\r\n  KeepAlive: KeepAlive\r\n};\r\n\r\n/*  */\r\n\r\nfunction initGlobalAPI (Vue) {\r\n  // config\r\n  var configDef = {};\r\n  configDef.get = function () { return config; };\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    configDef.set = function () {\r\n      warn(\r\n        'Do not replace the Vue.config object, set individual fields instead.'\r\n      );\r\n    };\r\n  }\r\n  Object.defineProperty(Vue, 'config', configDef);\r\n\r\n  // exposed util methods.\r\n  // NOTE: these are not considered part of the public API - avoid relying on\r\n  // them unless you are aware of the risk.\r\n  Vue.util = {\r\n    warn: warn,\r\n    extend: extend,\r\n    mergeOptions: mergeOptions,\r\n    defineReactive: defineReactive$$1\r\n  };\r\n\r\n  Vue.set = set;\r\n  Vue.delete = del;\r\n  Vue.nextTick = nextTick;\r\n\r\n  Vue.options = Object.create(null);\r\n  ASSET_TYPES.forEach(function (type) {\r\n    Vue.options[type + 's'] = Object.create(null);\r\n  });\r\n\r\n  // this is used to identify the \"base\" constructor to extend all plain-object\r\n  // components with in Weex's multi-instance scenarios.\r\n  Vue.options._base = Vue;\r\n\r\n  extend(Vue.options.components, builtInComponents);\r\n\r\n  initUse(Vue);\r\n  initMixin$1(Vue);\r\n  initExtend(Vue);\r\n  initAssetRegisters(Vue);\r\n}\r\n\r\ninitGlobalAPI(Vue$3);\r\n\r\nObject.defineProperty(Vue$3.prototype, '$isServer', {\r\n  get: isServerRendering\r\n});\r\n\r\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\r\n  get: function get () {\r\n    /* istanbul ignore next */\r\n    return this.$vnode && this.$vnode.ssrContext\r\n  }\r\n});\r\n\r\nVue$3.version = '2.4.4';\r\n\r\n/*  */\r\n\r\n// these are reserved for web because they are directly compiled away\r\n// during template compilation\r\nvar isReservedAttr = makeMap('style,class');\r\n\r\n// attributes that should be using props for binding\r\nvar acceptValue = makeMap('input,textarea,option,select,progress');\r\nvar mustUseProp = function (tag, type, attr) {\r\n  return (\r\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\r\n    (attr === 'selected' && tag === 'option') ||\r\n    (attr === 'checked' && tag === 'input') ||\r\n    (attr === 'muted' && tag === 'video')\r\n  )\r\n};\r\n\r\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\r\n\r\nvar isBooleanAttr = makeMap(\r\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\r\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\r\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\r\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\r\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\r\n  'truespeed,typemustmatch,visible'\r\n);\r\n\r\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\r\n\r\nvar isXlink = function (name) {\r\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\r\n};\r\n\r\nvar getXlinkProp = function (name) {\r\n  return isXlink(name) ? name.slice(6, name.length) : ''\r\n};\r\n\r\nvar isFalsyAttrValue = function (val) {\r\n  return val == null || val === false\r\n};\r\n\r\n/*  */\r\n\r\nfunction genClassForVnode (vnode) {\r\n  var data = vnode.data;\r\n  var parentNode = vnode;\r\n  var childNode = vnode;\r\n  while (isDef(childNode.componentInstance)) {\r\n    childNode = childNode.componentInstance._vnode;\r\n    if (childNode.data) {\r\n      data = mergeClassData(childNode.data, data);\r\n    }\r\n  }\r\n  while (isDef(parentNode = parentNode.parent)) {\r\n    if (parentNode.data) {\r\n      data = mergeClassData(data, parentNode.data);\r\n    }\r\n  }\r\n  return renderClass(data.staticClass, data.class)\r\n}\r\n\r\nfunction mergeClassData (child, parent) {\r\n  return {\r\n    staticClass: concat(child.staticClass, parent.staticClass),\r\n    class: isDef(child.class)\r\n      ? [child.class, parent.class]\r\n      : parent.class\r\n  }\r\n}\r\n\r\nfunction renderClass (\r\n  staticClass,\r\n  dynamicClass\r\n) {\r\n  if (isDef(staticClass) || isDef(dynamicClass)) {\r\n    return concat(staticClass, stringifyClass(dynamicClass))\r\n  }\r\n  /* istanbul ignore next */\r\n  return ''\r\n}\r\n\r\nfunction concat (a, b) {\r\n  return a ? b ? (a + ' ' + b) : a : (b || '')\r\n}\r\n\r\nfunction stringifyClass (value) {\r\n  if (Array.isArray(value)) {\r\n    return stringifyArray(value)\r\n  }\r\n  if (isObject(value)) {\r\n    return stringifyObject(value)\r\n  }\r\n  if (typeof value === 'string') {\r\n    return value\r\n  }\r\n  /* istanbul ignore next */\r\n  return ''\r\n}\r\n\r\nfunction stringifyArray (value) {\r\n  var res = '';\r\n  var stringified;\r\n  for (var i = 0, l = value.length; i < l; i++) {\r\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\r\n      if (res) { res += ' '; }\r\n      res += stringified;\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nfunction stringifyObject (value) {\r\n  var res = '';\r\n  for (var key in value) {\r\n    if (value[key]) {\r\n      if (res) { res += ' '; }\r\n      res += key;\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\n/*  */\r\n\r\nvar namespaceMap = {\r\n  svg: 'http://www.w3.org/2000/svg',\r\n  math: 'http://www.w3.org/1998/Math/MathML'\r\n};\r\n\r\nvar isHTMLTag = makeMap(\r\n  'html,body,base,head,link,meta,style,title,' +\r\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\r\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\r\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\r\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\r\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\r\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\r\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\r\n  'output,progress,select,textarea,' +\r\n  'details,dialog,menu,menuitem,summary,' +\r\n  'content,element,shadow,template,blockquote,iframe,tfoot'\r\n);\r\n\r\n// this map is intentionally selective, only covering SVG elements that may\r\n// contain child elements.\r\nvar isSVG = makeMap(\r\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\r\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\r\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\r\n  true\r\n);\r\n\r\nvar isPreTag = function (tag) { return tag === 'pre'; };\r\n\r\nvar isReservedTag = function (tag) {\r\n  return isHTMLTag(tag) || isSVG(tag)\r\n};\r\n\r\nfunction getTagNamespace (tag) {\r\n  if (isSVG(tag)) {\r\n    return 'svg'\r\n  }\r\n  // basic support for MathML\r\n  // note it doesn't support other MathML elements being component roots\r\n  if (tag === 'math') {\r\n    return 'math'\r\n  }\r\n}\r\n\r\nvar unknownElementCache = Object.create(null);\r\nfunction isUnknownElement (tag) {\r\n  /* istanbul ignore if */\r\n  if (!inBrowser) {\r\n    return true\r\n  }\r\n  if (isReservedTag(tag)) {\r\n    return false\r\n  }\r\n  tag = tag.toLowerCase();\r\n  /* istanbul ignore if */\r\n  if (unknownElementCache[tag] != null) {\r\n    return unknownElementCache[tag]\r\n  }\r\n  var el = document.createElement(tag);\r\n  if (tag.indexOf('-') > -1) {\r\n    // http://stackoverflow.com/a/28210364/1070244\r\n    return (unknownElementCache[tag] = (\r\n      el.constructor === window.HTMLUnknownElement ||\r\n      el.constructor === window.HTMLElement\r\n    ))\r\n  } else {\r\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\r\n  }\r\n}\r\n\r\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\r\n\r\n/*  */\r\n\r\n/**\r\n * Query an element selector if it's not an element already.\r\n */\r\nfunction query (el) {\r\n  if (typeof el === 'string') {\r\n    var selected = document.querySelector(el);\r\n    if (!selected) {\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        'Cannot find element: ' + el\r\n      );\r\n      return document.createElement('div')\r\n    }\r\n    return selected\r\n  } else {\r\n    return el\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction createElement$1 (tagName, vnode) {\r\n  var elm = document.createElement(tagName);\r\n  if (tagName !== 'select') {\r\n    return elm\r\n  }\r\n  // false or null will remove the attribute but undefined will not\r\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\r\n    elm.setAttribute('multiple', 'multiple');\r\n  }\r\n  return elm\r\n}\r\n\r\nfunction createElementNS (namespace, tagName) {\r\n  return document.createElementNS(namespaceMap[namespace], tagName)\r\n}\r\n\r\nfunction createTextNode (text) {\r\n  return document.createTextNode(text)\r\n}\r\n\r\nfunction createComment (text) {\r\n  return document.createComment(text)\r\n}\r\n\r\nfunction insertBefore (parentNode, newNode, referenceNode) {\r\n  parentNode.insertBefore(newNode, referenceNode);\r\n}\r\n\r\nfunction removeChild (node, child) {\r\n  node.removeChild(child);\r\n}\r\n\r\nfunction appendChild (node, child) {\r\n  node.appendChild(child);\r\n}\r\n\r\nfunction parentNode (node) {\r\n  return node.parentNode\r\n}\r\n\r\nfunction nextSibling (node) {\r\n  return node.nextSibling\r\n}\r\n\r\nfunction tagName (node) {\r\n  return node.tagName\r\n}\r\n\r\nfunction setTextContent (node, text) {\r\n  node.textContent = text;\r\n}\r\n\r\nfunction setAttribute (node, key, val) {\r\n  node.setAttribute(key, val);\r\n}\r\n\r\n\r\nvar nodeOps = Object.freeze({\r\n\tcreateElement: createElement$1,\r\n\tcreateElementNS: createElementNS,\r\n\tcreateTextNode: createTextNode,\r\n\tcreateComment: createComment,\r\n\tinsertBefore: insertBefore,\r\n\tremoveChild: removeChild,\r\n\tappendChild: appendChild,\r\n\tparentNode: parentNode,\r\n\tnextSibling: nextSibling,\r\n\ttagName: tagName,\r\n\tsetTextContent: setTextContent,\r\n\tsetAttribute: setAttribute\r\n});\r\n\r\n/*  */\r\n\r\nvar ref = {\r\n  create: function create (_, vnode) {\r\n    registerRef(vnode);\r\n  },\r\n  update: function update (oldVnode, vnode) {\r\n    if (oldVnode.data.ref !== vnode.data.ref) {\r\n      registerRef(oldVnode, true);\r\n      registerRef(vnode);\r\n    }\r\n  },\r\n  destroy: function destroy (vnode) {\r\n    registerRef(vnode, true);\r\n  }\r\n};\r\n\r\nfunction registerRef (vnode, isRemoval) {\r\n  var key = vnode.data.ref;\r\n  if (!key) { return }\r\n\r\n  var vm = vnode.context;\r\n  var ref = vnode.componentInstance || vnode.elm;\r\n  var refs = vm.$refs;\r\n  if (isRemoval) {\r\n    if (Array.isArray(refs[key])) {\r\n      remove(refs[key], ref);\r\n    } else if (refs[key] === ref) {\r\n      refs[key] = undefined;\r\n    }\r\n  } else {\r\n    if (vnode.data.refInFor) {\r\n      if (!Array.isArray(refs[key])) {\r\n        refs[key] = [ref];\r\n      } else if (refs[key].indexOf(ref) < 0) {\r\n        // $flow-disable-line\r\n        refs[key].push(ref);\r\n      }\r\n    } else {\r\n      refs[key] = ref;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Virtual DOM patching algorithm based on Snabbdom by\r\n * Simon Friis Vindum (@paldepind)\r\n * Licensed under the MIT License\r\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\r\n *\r\n * modified by Evan You (@yyx990803)\r\n *\r\n * Not type-checking this because this file is perf-critical and the cost\r\n * of making flow understand it is not worth it.\r\n */\r\n\r\nvar emptyNode = new VNode('', {}, []);\r\n\r\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\r\n\r\nfunction sameVnode (a, b) {\r\n  return (\r\n    a.key === b.key && (\r\n      (\r\n        a.tag === b.tag &&\r\n        a.isComment === b.isComment &&\r\n        isDef(a.data) === isDef(b.data) &&\r\n        sameInputType(a, b)\r\n      ) || (\r\n        isTrue(a.isAsyncPlaceholder) &&\r\n        a.asyncFactory === b.asyncFactory &&\r\n        isUndef(b.asyncFactory.error)\r\n      )\r\n    )\r\n  )\r\n}\r\n\r\nfunction sameInputType (a, b) {\r\n  if (a.tag !== 'input') { return true }\r\n  var i;\r\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\r\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\r\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\r\n}\r\n\r\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\r\n  var i, key;\r\n  var map = {};\r\n  for (i = beginIdx; i <= endIdx; ++i) {\r\n    key = children[i].key;\r\n    if (isDef(key)) { map[key] = i; }\r\n  }\r\n  return map\r\n}\r\n\r\nfunction createPatchFunction (backend) {\r\n  var i, j;\r\n  var cbs = {};\r\n\r\n  var modules = backend.modules;\r\n  var nodeOps = backend.nodeOps;\r\n\r\n  for (i = 0; i < hooks.length; ++i) {\r\n    cbs[hooks[i]] = [];\r\n    for (j = 0; j < modules.length; ++j) {\r\n      if (isDef(modules[j][hooks[i]])) {\r\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\r\n      }\r\n    }\r\n  }\r\n\r\n  function emptyNodeAt (elm) {\r\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\r\n  }\r\n\r\n  function createRmCb (childElm, listeners) {\r\n    function remove$$1 () {\r\n      if (--remove$$1.listeners === 0) {\r\n        removeNode(childElm);\r\n      }\r\n    }\r\n    remove$$1.listeners = listeners;\r\n    return remove$$1\r\n  }\r\n\r\n  function removeNode (el) {\r\n    var parent = nodeOps.parentNode(el);\r\n    // element may have already been removed due to v-html / v-text\r\n    if (isDef(parent)) {\r\n      nodeOps.removeChild(parent, el);\r\n    }\r\n  }\r\n\r\n  var inPre = 0;\r\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\r\n    vnode.isRootInsert = !nested; // for transition enter check\r\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\r\n      return\r\n    }\r\n\r\n    var data = vnode.data;\r\n    var children = vnode.children;\r\n    var tag = vnode.tag;\r\n    if (isDef(tag)) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (data && data.pre) {\r\n          inPre++;\r\n        }\r\n        if (\r\n          !inPre &&\r\n          !vnode.ns &&\r\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\r\n          config.isUnknownElement(tag)\r\n        ) {\r\n          warn(\r\n            'Unknown custom element: <' + tag + '> - did you ' +\r\n            'register the component correctly? For recursive components, ' +\r\n            'make sure to provide the \"name\" option.',\r\n            vnode.context\r\n          );\r\n        }\r\n      }\r\n      vnode.elm = vnode.ns\r\n        ? nodeOps.createElementNS(vnode.ns, tag)\r\n        : nodeOps.createElement(tag, vnode);\r\n      setScope(vnode);\r\n\r\n      /* istanbul ignore if */\r\n      {\r\n        createChildren(vnode, children, insertedVnodeQueue);\r\n        if (isDef(data)) {\r\n          invokeCreateHooks(vnode, insertedVnodeQueue);\r\n        }\r\n        insert(parentElm, vnode.elm, refElm);\r\n      }\r\n\r\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\r\n        inPre--;\r\n      }\r\n    } else if (isTrue(vnode.isComment)) {\r\n      vnode.elm = nodeOps.createComment(vnode.text);\r\n      insert(parentElm, vnode.elm, refElm);\r\n    } else {\r\n      vnode.elm = nodeOps.createTextNode(vnode.text);\r\n      insert(parentElm, vnode.elm, refElm);\r\n    }\r\n  }\r\n\r\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\r\n    var i = vnode.data;\r\n    if (isDef(i)) {\r\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\r\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\r\n        i(vnode, false /* hydrating */, parentElm, refElm);\r\n      }\r\n      // after calling the init hook, if the vnode is a child component\r\n      // it should've created a child instance and mounted it. the child\r\n      // component also has set the placeholder vnode's elm.\r\n      // in that case we can just return the element and be done.\r\n      if (isDef(vnode.componentInstance)) {\r\n        initComponent(vnode, insertedVnodeQueue);\r\n        if (isTrue(isReactivated)) {\r\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\r\n        }\r\n        return true\r\n      }\r\n    }\r\n  }\r\n\r\n  function initComponent (vnode, insertedVnodeQueue) {\r\n    if (isDef(vnode.data.pendingInsert)) {\r\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\r\n      vnode.data.pendingInsert = null;\r\n    }\r\n    vnode.elm = vnode.componentInstance.$el;\r\n    if (isPatchable(vnode)) {\r\n      invokeCreateHooks(vnode, insertedVnodeQueue);\r\n      setScope(vnode);\r\n    } else {\r\n      // empty component root.\r\n      // skip all element-related modules except for ref (#3455)\r\n      registerRef(vnode);\r\n      // make sure to invoke the insert hook\r\n      insertedVnodeQueue.push(vnode);\r\n    }\r\n  }\r\n\r\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\r\n    var i;\r\n    // hack for #4339: a reactivated component with inner transition\r\n    // does not trigger because the inner node's created hooks are not called\r\n    // again. It's not ideal to involve module-specific logic in here but\r\n    // there doesn't seem to be a better way to do it.\r\n    var innerNode = vnode;\r\n    while (innerNode.componentInstance) {\r\n      innerNode = innerNode.componentInstance._vnode;\r\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\r\n        for (i = 0; i < cbs.activate.length; ++i) {\r\n          cbs.activate[i](emptyNode, innerNode);\r\n        }\r\n        insertedVnodeQueue.push(innerNode);\r\n        break\r\n      }\r\n    }\r\n    // unlike a newly created component,\r\n    // a reactivated keep-alive component doesn't insert itself\r\n    insert(parentElm, vnode.elm, refElm);\r\n  }\r\n\r\n  function insert (parent, elm, ref$$1) {\r\n    if (isDef(parent)) {\r\n      if (isDef(ref$$1)) {\r\n        if (ref$$1.parentNode === parent) {\r\n          nodeOps.insertBefore(parent, elm, ref$$1);\r\n        }\r\n      } else {\r\n        nodeOps.appendChild(parent, elm);\r\n      }\r\n    }\r\n  }\r\n\r\n  function createChildren (vnode, children, insertedVnodeQueue) {\r\n    if (Array.isArray(children)) {\r\n      for (var i = 0; i < children.length; ++i) {\r\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\r\n      }\r\n    } else if (isPrimitive(vnode.text)) {\r\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\r\n    }\r\n  }\r\n\r\n  function isPatchable (vnode) {\r\n    while (vnode.componentInstance) {\r\n      vnode = vnode.componentInstance._vnode;\r\n    }\r\n    return isDef(vnode.tag)\r\n  }\r\n\r\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\r\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\r\n      cbs.create[i$1](emptyNode, vnode);\r\n    }\r\n    i = vnode.data.hook; // Reuse variable\r\n    if (isDef(i)) {\r\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\r\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\r\n    }\r\n  }\r\n\r\n  // set scope id attribute for scoped CSS.\r\n  // this is implemented as a special case to avoid the overhead\r\n  // of going through the normal attribute patching process.\r\n  function setScope (vnode) {\r\n    var i;\r\n    var ancestor = vnode;\r\n    while (ancestor) {\r\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\r\n        nodeOps.setAttribute(vnode.elm, i, '');\r\n      }\r\n      ancestor = ancestor.parent;\r\n    }\r\n    // for slot content they should also get the scopeId from the host instance.\r\n    if (isDef(i = activeInstance) &&\r\n      i !== vnode.context &&\r\n      isDef(i = i.$options._scopeId)\r\n    ) {\r\n      nodeOps.setAttribute(vnode.elm, i, '');\r\n    }\r\n  }\r\n\r\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\r\n    for (; startIdx <= endIdx; ++startIdx) {\r\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\r\n    }\r\n  }\r\n\r\n  function invokeDestroyHook (vnode) {\r\n    var i, j;\r\n    var data = vnode.data;\r\n    if (isDef(data)) {\r\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\r\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\r\n    }\r\n    if (isDef(i = vnode.children)) {\r\n      for (j = 0; j < vnode.children.length; ++j) {\r\n        invokeDestroyHook(vnode.children[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\r\n    for (; startIdx <= endIdx; ++startIdx) {\r\n      var ch = vnodes[startIdx];\r\n      if (isDef(ch)) {\r\n        if (isDef(ch.tag)) {\r\n          removeAndInvokeRemoveHook(ch);\r\n          invokeDestroyHook(ch);\r\n        } else { // Text node\r\n          removeNode(ch.elm);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeAndInvokeRemoveHook (vnode, rm) {\r\n    if (isDef(rm) || isDef(vnode.data)) {\r\n      var i;\r\n      var listeners = cbs.remove.length + 1;\r\n      if (isDef(rm)) {\r\n        // we have a recursively passed down rm callback\r\n        // increase the listeners count\r\n        rm.listeners += listeners;\r\n      } else {\r\n        // directly removing\r\n        rm = createRmCb(vnode.elm, listeners);\r\n      }\r\n      // recursively invoke hooks on child component root node\r\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\r\n        removeAndInvokeRemoveHook(i, rm);\r\n      }\r\n      for (i = 0; i < cbs.remove.length; ++i) {\r\n        cbs.remove[i](vnode, rm);\r\n      }\r\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\r\n        i(vnode, rm);\r\n      } else {\r\n        rm();\r\n      }\r\n    } else {\r\n      removeNode(vnode.elm);\r\n    }\r\n  }\r\n\r\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\r\n    var oldStartIdx = 0;\r\n    var newStartIdx = 0;\r\n    var oldEndIdx = oldCh.length - 1;\r\n    var oldStartVnode = oldCh[0];\r\n    var oldEndVnode = oldCh[oldEndIdx];\r\n    var newEndIdx = newCh.length - 1;\r\n    var newStartVnode = newCh[0];\r\n    var newEndVnode = newCh[newEndIdx];\r\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\r\n\r\n    // removeOnly is a special flag used only by <transition-group>\r\n    // to ensure removed elements stay in correct relative positions\r\n    // during leaving transitions\r\n    var canMove = !removeOnly;\r\n\r\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n      if (isUndef(oldStartVnode)) {\r\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\r\n      } else if (isUndef(oldEndVnode)) {\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\r\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\r\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\r\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\r\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else {\r\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\r\n        idxInOld = isDef(newStartVnode.key)\r\n          ? oldKeyToIdx[newStartVnode.key]\r\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\r\n        if (isUndef(idxInOld)) { // New element\r\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\r\n        } else {\r\n          elmToMove = oldCh[idxInOld];\r\n          /* istanbul ignore if */\r\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\r\n            warn(\r\n              'It seems there are duplicate keys that is causing an update error. ' +\r\n              'Make sure each v-for item has a unique key.'\r\n            );\r\n          }\r\n          if (sameVnode(elmToMove, newStartVnode)) {\r\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\r\n            oldCh[idxInOld] = undefined;\r\n            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\r\n          } else {\r\n            // same key but different element. treat as new element\r\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\r\n          }\r\n        }\r\n        newStartVnode = newCh[++newStartIdx];\r\n      }\r\n    }\r\n    if (oldStartIdx > oldEndIdx) {\r\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\r\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\r\n    } else if (newStartIdx > newEndIdx) {\r\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\r\n    }\r\n  }\r\n\r\n  function findIdxInOld (node, oldCh, start, end) {\r\n    for (var i = start; i < end; i++) {\r\n      var c = oldCh[i];\r\n      if (isDef(c) && sameVnode(node, c)) { return i }\r\n    }\r\n  }\r\n\r\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\r\n    if (oldVnode === vnode) {\r\n      return\r\n    }\r\n\r\n    var elm = vnode.elm = oldVnode.elm;\r\n\r\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\r\n      if (isDef(vnode.asyncFactory.resolved)) {\r\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\r\n      } else {\r\n        vnode.isAsyncPlaceholder = true;\r\n      }\r\n      return\r\n    }\r\n\r\n    // reuse element for static trees.\r\n    // note we only do this if the vnode is cloned -\r\n    // if the new node is not cloned it means the render functions have been\r\n    // reset by the hot-reload-api and we need to do a proper re-render.\r\n    if (isTrue(vnode.isStatic) &&\r\n      isTrue(oldVnode.isStatic) &&\r\n      vnode.key === oldVnode.key &&\r\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\r\n    ) {\r\n      vnode.componentInstance = oldVnode.componentInstance;\r\n      return\r\n    }\r\n\r\n    var i;\r\n    var data = vnode.data;\r\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\r\n      i(oldVnode, vnode);\r\n    }\r\n\r\n    var oldCh = oldVnode.children;\r\n    var ch = vnode.children;\r\n    if (isDef(data) && isPatchable(vnode)) {\r\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\r\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\r\n    }\r\n    if (isUndef(vnode.text)) {\r\n      if (isDef(oldCh) && isDef(ch)) {\r\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\r\n      } else if (isDef(ch)) {\r\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\r\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n      } else if (isDef(oldCh)) {\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      } else if (isDef(oldVnode.text)) {\r\n        nodeOps.setTextContent(elm, '');\r\n      }\r\n    } else if (oldVnode.text !== vnode.text) {\r\n      nodeOps.setTextContent(elm, vnode.text);\r\n    }\r\n    if (isDef(data)) {\r\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\r\n    }\r\n  }\r\n\r\n  function invokeInsertHook (vnode, queue, initial) {\r\n    // delay insert hooks for component root nodes, invoke them after the\r\n    // element is really inserted\r\n    if (isTrue(initial) && isDef(vnode.parent)) {\r\n      vnode.parent.data.pendingInsert = queue;\r\n    } else {\r\n      for (var i = 0; i < queue.length; ++i) {\r\n        queue[i].data.hook.insert(queue[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  var bailed = false;\r\n  // list of modules that can skip create hook during hydration because they\r\n  // are already rendered on the client or has no need for initialization\r\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\r\n\r\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\r\n  function hydrate (elm, vnode, insertedVnodeQueue) {\r\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\r\n      vnode.elm = elm;\r\n      vnode.isAsyncPlaceholder = true;\r\n      return true\r\n    }\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (!assertNodeMatch(elm, vnode)) {\r\n        return false\r\n      }\r\n    }\r\n    vnode.elm = elm;\r\n    var tag = vnode.tag;\r\n    var data = vnode.data;\r\n    var children = vnode.children;\r\n    if (isDef(data)) {\r\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\r\n      if (isDef(i = vnode.componentInstance)) {\r\n        // child component. it should have hydrated its own tree.\r\n        initComponent(vnode, insertedVnodeQueue);\r\n        return true\r\n      }\r\n    }\r\n    if (isDef(tag)) {\r\n      if (isDef(children)) {\r\n        // empty element, allow client to pick up and populate children\r\n        if (!elm.hasChildNodes()) {\r\n          createChildren(vnode, children, insertedVnodeQueue);\r\n        } else {\r\n          // v-html and domProps: innerHTML\r\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\r\n            if (i !== elm.innerHTML) {\r\n              /* istanbul ignore if */\r\n              if (process.env.NODE_ENV !== 'production' &&\r\n                typeof console !== 'undefined' &&\r\n                !bailed\r\n              ) {\r\n                bailed = true;\r\n                console.warn('Parent: ', elm);\r\n                console.warn('server innerHTML: ', i);\r\n                console.warn('client innerHTML: ', elm.innerHTML);\r\n              }\r\n              return false\r\n            }\r\n          } else {\r\n            // iterate and compare children lists\r\n            var childrenMatch = true;\r\n            var childNode = elm.firstChild;\r\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\r\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\r\n                childrenMatch = false;\r\n                break\r\n              }\r\n              childNode = childNode.nextSibling;\r\n            }\r\n            // if childNode is not null, it means the actual childNodes list is\r\n            // longer than the virtual children list.\r\n            if (!childrenMatch || childNode) {\r\n              /* istanbul ignore if */\r\n              if (process.env.NODE_ENV !== 'production' &&\r\n                typeof console !== 'undefined' &&\r\n                !bailed\r\n              ) {\r\n                bailed = true;\r\n                console.warn('Parent: ', elm);\r\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\r\n              }\r\n              return false\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (isDef(data)) {\r\n        for (var key in data) {\r\n          if (!isRenderedModule(key)) {\r\n            invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            break\r\n          }\r\n        }\r\n      }\r\n    } else if (elm.data !== vnode.text) {\r\n      elm.data = vnode.text;\r\n    }\r\n    return true\r\n  }\r\n\r\n  function assertNodeMatch (node, vnode) {\r\n    if (isDef(vnode.tag)) {\r\n      return (\r\n        vnode.tag.indexOf('vue-component') === 0 ||\r\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\r\n      )\r\n    } else {\r\n      return node.nodeType === (vnode.isComment ? 8 : 3)\r\n    }\r\n  }\r\n\r\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\r\n    if (isUndef(vnode)) {\r\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\r\n      return\r\n    }\r\n\r\n    var isInitialPatch = false;\r\n    var insertedVnodeQueue = [];\r\n\r\n    if (isUndef(oldVnode)) {\r\n      // empty mount (likely as component), create new root element\r\n      isInitialPatch = true;\r\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\r\n    } else {\r\n      var isRealElement = isDef(oldVnode.nodeType);\r\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\r\n        // patch existing root node\r\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\r\n      } else {\r\n        if (isRealElement) {\r\n          // mounting to a real element\r\n          // check if this is server-rendered content and if we can perform\r\n          // a successful hydration.\r\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\r\n            oldVnode.removeAttribute(SSR_ATTR);\r\n            hydrating = true;\r\n          }\r\n          if (isTrue(hydrating)) {\r\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\r\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\r\n              return oldVnode\r\n            } else if (process.env.NODE_ENV !== 'production') {\r\n              warn(\r\n                'The client-side rendered virtual DOM tree is not matching ' +\r\n                'server-rendered content. This is likely caused by incorrect ' +\r\n                'HTML markup, for example nesting block-level elements inside ' +\r\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\r\n                'full client-side render.'\r\n              );\r\n            }\r\n          }\r\n          // either not server-rendered, or hydration failed.\r\n          // create an empty node and replace it\r\n          oldVnode = emptyNodeAt(oldVnode);\r\n        }\r\n        // replacing existing element\r\n        var oldElm = oldVnode.elm;\r\n        var parentElm$1 = nodeOps.parentNode(oldElm);\r\n        createElm(\r\n          vnode,\r\n          insertedVnodeQueue,\r\n          // extremely rare edge case: do not insert if old element is in a\r\n          // leaving transition. Only happens when combining transition +\r\n          // keep-alive + HOCs. (#4590)\r\n          oldElm._leaveCb ? null : parentElm$1,\r\n          nodeOps.nextSibling(oldElm)\r\n        );\r\n\r\n        if (isDef(vnode.parent)) {\r\n          // component root element replaced.\r\n          // update parent placeholder node element, recursively\r\n          var ancestor = vnode.parent;\r\n          var patchable = isPatchable(vnode);\r\n          while (ancestor) {\r\n            for (var i = 0; i < cbs.destroy.length; ++i) {\r\n              cbs.destroy[i](ancestor);\r\n            }\r\n            ancestor.elm = vnode.elm;\r\n            if (patchable) {\r\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\r\n                cbs.create[i$1](emptyNode, ancestor);\r\n              }\r\n              // #6513\r\n              // invoke insert hooks that may have been merged by create hooks.\r\n              // e.g. for directives that uses the \"inserted\" hook.\r\n              var insert = ancestor.data.hook.insert;\r\n              if (insert.merged) {\r\n                // start at index 1 to avoid re-invoking component mounted hook\r\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\r\n                  insert.fns[i$2]();\r\n                }\r\n              }\r\n            }\r\n            ancestor = ancestor.parent;\r\n          }\r\n        }\r\n\r\n        if (isDef(parentElm$1)) {\r\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\r\n        } else if (isDef(oldVnode.tag)) {\r\n          invokeDestroyHook(oldVnode);\r\n        }\r\n      }\r\n    }\r\n\r\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\r\n    return vnode.elm\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar directives = {\r\n  create: updateDirectives,\r\n  update: updateDirectives,\r\n  destroy: function unbindDirectives (vnode) {\r\n    updateDirectives(vnode, emptyNode);\r\n  }\r\n};\r\n\r\nfunction updateDirectives (oldVnode, vnode) {\r\n  if (oldVnode.data.directives || vnode.data.directives) {\r\n    _update(oldVnode, vnode);\r\n  }\r\n}\r\n\r\nfunction _update (oldVnode, vnode) {\r\n  var isCreate = oldVnode === emptyNode;\r\n  var isDestroy = vnode === emptyNode;\r\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\r\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\r\n\r\n  var dirsWithInsert = [];\r\n  var dirsWithPostpatch = [];\r\n\r\n  var key, oldDir, dir;\r\n  for (key in newDirs) {\r\n    oldDir = oldDirs[key];\r\n    dir = newDirs[key];\r\n    if (!oldDir) {\r\n      // new directive, bind\r\n      callHook$1(dir, 'bind', vnode, oldVnode);\r\n      if (dir.def && dir.def.inserted) {\r\n        dirsWithInsert.push(dir);\r\n      }\r\n    } else {\r\n      // existing directive, update\r\n      dir.oldValue = oldDir.value;\r\n      callHook$1(dir, 'update', vnode, oldVnode);\r\n      if (dir.def && dir.def.componentUpdated) {\r\n        dirsWithPostpatch.push(dir);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (dirsWithInsert.length) {\r\n    var callInsert = function () {\r\n      for (var i = 0; i < dirsWithInsert.length; i++) {\r\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\r\n      }\r\n    };\r\n    if (isCreate) {\r\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\r\n    } else {\r\n      callInsert();\r\n    }\r\n  }\r\n\r\n  if (dirsWithPostpatch.length) {\r\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\r\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\r\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\r\n      }\r\n    });\r\n  }\r\n\r\n  if (!isCreate) {\r\n    for (key in oldDirs) {\r\n      if (!newDirs[key]) {\r\n        // no longer present, unbind\r\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvar emptyModifiers = Object.create(null);\r\n\r\nfunction normalizeDirectives$1 (\r\n  dirs,\r\n  vm\r\n) {\r\n  var res = Object.create(null);\r\n  if (!dirs) {\r\n    return res\r\n  }\r\n  var i, dir;\r\n  for (i = 0; i < dirs.length; i++) {\r\n    dir = dirs[i];\r\n    if (!dir.modifiers) {\r\n      dir.modifiers = emptyModifiers;\r\n    }\r\n    res[getRawDirName(dir)] = dir;\r\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\r\n  }\r\n  return res\r\n}\r\n\r\nfunction getRawDirName (dir) {\r\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\r\n}\r\n\r\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\r\n  var fn = dir.def && dir.def[hook];\r\n  if (fn) {\r\n    try {\r\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\r\n    } catch (e) {\r\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\r\n    }\r\n  }\r\n}\r\n\r\nvar baseModules = [\r\n  ref,\r\n  directives\r\n];\r\n\r\n/*  */\r\n\r\nfunction updateAttrs (oldVnode, vnode) {\r\n  var opts = vnode.componentOptions;\r\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\r\n    return\r\n  }\r\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\r\n    return\r\n  }\r\n  var key, cur, old;\r\n  var elm = vnode.elm;\r\n  var oldAttrs = oldVnode.data.attrs || {};\r\n  var attrs = vnode.data.attrs || {};\r\n  // clone observed objects, as the user probably wants to mutate it\r\n  if (isDef(attrs.__ob__)) {\r\n    attrs = vnode.data.attrs = extend({}, attrs);\r\n  }\r\n\r\n  for (key in attrs) {\r\n    cur = attrs[key];\r\n    old = oldAttrs[key];\r\n    if (old !== cur) {\r\n      setAttr(elm, key, cur);\r\n    }\r\n  }\r\n  // #4391: in IE9, setting type can reset value for input[type=radio]\r\n  /* istanbul ignore if */\r\n  if (isIE9 && attrs.value !== oldAttrs.value) {\r\n    setAttr(elm, 'value', attrs.value);\r\n  }\r\n  for (key in oldAttrs) {\r\n    if (isUndef(attrs[key])) {\r\n      if (isXlink(key)) {\r\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n      } else if (!isEnumeratedAttr(key)) {\r\n        elm.removeAttribute(key);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction setAttr (el, key, value) {\r\n  if (isBooleanAttr(key)) {\r\n    // set attribute for blank value\r\n    // e.g. <option disabled>Select one</option>\r\n    if (isFalsyAttrValue(value)) {\r\n      el.removeAttribute(key);\r\n    } else {\r\n      // technically allowfullscreen is a boolean attribute for <iframe>,\r\n      // but Flash expects a value of \"true\" when used on <embed> tag\r\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\r\n        ? 'true'\r\n        : key;\r\n      el.setAttribute(key, value);\r\n    }\r\n  } else if (isEnumeratedAttr(key)) {\r\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\r\n  } else if (isXlink(key)) {\r\n    if (isFalsyAttrValue(value)) {\r\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n    } else {\r\n      el.setAttributeNS(xlinkNS, key, value);\r\n    }\r\n  } else {\r\n    if (isFalsyAttrValue(value)) {\r\n      el.removeAttribute(key);\r\n    } else {\r\n      el.setAttribute(key, value);\r\n    }\r\n  }\r\n}\r\n\r\nvar attrs = {\r\n  create: updateAttrs,\r\n  update: updateAttrs\r\n};\r\n\r\n/*  */\r\n\r\nfunction updateClass (oldVnode, vnode) {\r\n  var el = vnode.elm;\r\n  var data = vnode.data;\r\n  var oldData = oldVnode.data;\r\n  if (\r\n    isUndef(data.staticClass) &&\r\n    isUndef(data.class) && (\r\n      isUndef(oldData) || (\r\n        isUndef(oldData.staticClass) &&\r\n        isUndef(oldData.class)\r\n      )\r\n    )\r\n  ) {\r\n    return\r\n  }\r\n\r\n  var cls = genClassForVnode(vnode);\r\n\r\n  // handle transition classes\r\n  var transitionClass = el._transitionClasses;\r\n  if (isDef(transitionClass)) {\r\n    cls = concat(cls, stringifyClass(transitionClass));\r\n  }\r\n\r\n  // set the class\r\n  if (cls !== el._prevClass) {\r\n    el.setAttribute('class', cls);\r\n    el._prevClass = cls;\r\n  }\r\n}\r\n\r\nvar klass = {\r\n  create: updateClass,\r\n  update: updateClass\r\n};\r\n\r\n/*  */\r\n\r\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\r\n\r\nfunction parseFilters (exp) {\r\n  var inSingle = false;\r\n  var inDouble = false;\r\n  var inTemplateString = false;\r\n  var inRegex = false;\r\n  var curly = 0;\r\n  var square = 0;\r\n  var paren = 0;\r\n  var lastFilterIndex = 0;\r\n  var c, prev, i, expression, filters;\r\n\r\n  for (i = 0; i < exp.length; i++) {\r\n    prev = c;\r\n    c = exp.charCodeAt(i);\r\n    if (inSingle) {\r\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\r\n    } else if (inDouble) {\r\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\r\n    } else if (inTemplateString) {\r\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\r\n    } else if (inRegex) {\r\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\r\n    } else if (\r\n      c === 0x7C && // pipe\r\n      exp.charCodeAt(i + 1) !== 0x7C &&\r\n      exp.charCodeAt(i - 1) !== 0x7C &&\r\n      !curly && !square && !paren\r\n    ) {\r\n      if (expression === undefined) {\r\n        // first filter, end of expression\r\n        lastFilterIndex = i + 1;\r\n        expression = exp.slice(0, i).trim();\r\n      } else {\r\n        pushFilter();\r\n      }\r\n    } else {\r\n      switch (c) {\r\n        case 0x22: inDouble = true; break         // \"\r\n        case 0x27: inSingle = true; break         // '\r\n        case 0x60: inTemplateString = true; break // `\r\n        case 0x28: paren++; break                 // (\r\n        case 0x29: paren--; break                 // )\r\n        case 0x5B: square++; break                // [\r\n        case 0x5D: square--; break                // ]\r\n        case 0x7B: curly++; break                 // {\r\n        case 0x7D: curly--; break                 // }\r\n      }\r\n      if (c === 0x2f) { // /\r\n        var j = i - 1;\r\n        var p = (void 0);\r\n        // find first non-whitespace prev char\r\n        for (; j >= 0; j--) {\r\n          p = exp.charAt(j);\r\n          if (p !== ' ') { break }\r\n        }\r\n        if (!p || !validDivisionCharRE.test(p)) {\r\n          inRegex = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (expression === undefined) {\r\n    expression = exp.slice(0, i).trim();\r\n  } else if (lastFilterIndex !== 0) {\r\n    pushFilter();\r\n  }\r\n\r\n  function pushFilter () {\r\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\r\n    lastFilterIndex = i + 1;\r\n  }\r\n\r\n  if (filters) {\r\n    for (i = 0; i < filters.length; i++) {\r\n      expression = wrapFilter(expression, filters[i]);\r\n    }\r\n  }\r\n\r\n  return expression\r\n}\r\n\r\nfunction wrapFilter (exp, filter) {\r\n  var i = filter.indexOf('(');\r\n  if (i < 0) {\r\n    // _f: resolveFilter\r\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\r\n  } else {\r\n    var name = filter.slice(0, i);\r\n    var args = filter.slice(i + 1);\r\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction baseWarn (msg) {\r\n  console.error((\"[Vue compiler]: \" + msg));\r\n}\r\n\r\nfunction pluckModuleFunction (\r\n  modules,\r\n  key\r\n) {\r\n  return modules\r\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\r\n    : []\r\n}\r\n\r\nfunction addProp (el, name, value) {\r\n  (el.props || (el.props = [])).push({ name: name, value: value });\r\n}\r\n\r\nfunction addAttr (el, name, value) {\r\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\r\n}\r\n\r\nfunction addDirective (\r\n  el,\r\n  name,\r\n  rawName,\r\n  value,\r\n  arg,\r\n  modifiers\r\n) {\r\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\r\n}\r\n\r\nfunction addHandler (\r\n  el,\r\n  name,\r\n  value,\r\n  modifiers,\r\n  important,\r\n  warn\r\n) {\r\n  // warn prevent and passive modifier\r\n  /* istanbul ignore if */\r\n  if (\r\n    process.env.NODE_ENV !== 'production' && warn &&\r\n    modifiers && modifiers.prevent && modifiers.passive\r\n  ) {\r\n    warn(\r\n      'passive and prevent can\\'t be used together. ' +\r\n      'Passive handler can\\'t prevent default event.'\r\n    );\r\n  }\r\n  // check capture modifier\r\n  if (modifiers && modifiers.capture) {\r\n    delete modifiers.capture;\r\n    name = '!' + name; // mark the event as captured\r\n  }\r\n  if (modifiers && modifiers.once) {\r\n    delete modifiers.once;\r\n    name = '~' + name; // mark the event as once\r\n  }\r\n  /* istanbul ignore if */\r\n  if (modifiers && modifiers.passive) {\r\n    delete modifiers.passive;\r\n    name = '&' + name; // mark the event as passive\r\n  }\r\n  var events;\r\n  if (modifiers && modifiers.native) {\r\n    delete modifiers.native;\r\n    events = el.nativeEvents || (el.nativeEvents = {});\r\n  } else {\r\n    events = el.events || (el.events = {});\r\n  }\r\n  var newHandler = { value: value, modifiers: modifiers };\r\n  var handlers = events[name];\r\n  /* istanbul ignore if */\r\n  if (Array.isArray(handlers)) {\r\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\r\n  } else if (handlers) {\r\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\r\n  } else {\r\n    events[name] = newHandler;\r\n  }\r\n}\r\n\r\nfunction getBindingAttr (\r\n  el,\r\n  name,\r\n  getStatic\r\n) {\r\n  var dynamicValue =\r\n    getAndRemoveAttr(el, ':' + name) ||\r\n    getAndRemoveAttr(el, 'v-bind:' + name);\r\n  if (dynamicValue != null) {\r\n    return parseFilters(dynamicValue)\r\n  } else if (getStatic !== false) {\r\n    var staticValue = getAndRemoveAttr(el, name);\r\n    if (staticValue != null) {\r\n      return JSON.stringify(staticValue)\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAndRemoveAttr (el, name) {\r\n  var val;\r\n  if ((val = el.attrsMap[name]) != null) {\r\n    var list = el.attrsList;\r\n    for (var i = 0, l = list.length; i < l; i++) {\r\n      if (list[i].name === name) {\r\n        list.splice(i, 1);\r\n        break\r\n      }\r\n    }\r\n  }\r\n  return val\r\n}\r\n\r\n/*  */\r\n\r\n/**\r\n * Cross-platform code generation for component v-model\r\n */\r\nfunction genComponentModel (\r\n  el,\r\n  value,\r\n  modifiers\r\n) {\r\n  var ref = modifiers || {};\r\n  var number = ref.number;\r\n  var trim = ref.trim;\r\n\r\n  var baseValueExpression = '$$v';\r\n  var valueExpression = baseValueExpression;\r\n  if (trim) {\r\n    valueExpression =\r\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\r\n        \"? \" + baseValueExpression + \".trim()\" +\r\n        \": \" + baseValueExpression + \")\";\r\n  }\r\n  if (number) {\r\n    valueExpression = \"_n(\" + valueExpression + \")\";\r\n  }\r\n  var assignment = genAssignmentCode(value, valueExpression);\r\n\r\n  el.model = {\r\n    value: (\"(\" + value + \")\"),\r\n    expression: (\"\\\"\" + value + \"\\\"\"),\r\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\r\n  };\r\n}\r\n\r\n/**\r\n * Cross-platform codegen helper for generating v-model value assignment code.\r\n */\r\nfunction genAssignmentCode (\r\n  value,\r\n  assignment\r\n) {\r\n  var modelRs = parseModel(value);\r\n  if (modelRs.idx === null) {\r\n    return (value + \"=\" + assignment)\r\n  } else {\r\n    return (\"$set(\" + (modelRs.exp) + \", \" + (modelRs.idx) + \", \" + assignment + \")\")\r\n  }\r\n}\r\n\r\n/**\r\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\r\n *\r\n * for loop possible cases:\r\n *\r\n * - test\r\n * - test[idx]\r\n * - test[test1[idx]]\r\n * - test[\"a\"][idx]\r\n * - xxx.test[a[a].test1[idx]]\r\n * - test.xxx.a[\"asa\"][test1[idx]]\r\n *\r\n */\r\n\r\nvar len;\r\nvar str;\r\nvar chr;\r\nvar index$1;\r\nvar expressionPos;\r\nvar expressionEndPos;\r\n\r\nfunction parseModel (val) {\r\n  str = val;\r\n  len = str.length;\r\n  index$1 = expressionPos = expressionEndPos = 0;\r\n\r\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\r\n    return {\r\n      exp: val,\r\n      idx: null\r\n    }\r\n  }\r\n\r\n  while (!eof()) {\r\n    chr = next();\r\n    /* istanbul ignore if */\r\n    if (isStringStart(chr)) {\r\n      parseString(chr);\r\n    } else if (chr === 0x5B) {\r\n      parseBracket(chr);\r\n    }\r\n  }\r\n\r\n  return {\r\n    exp: val.substring(0, expressionPos),\r\n    idx: val.substring(expressionPos + 1, expressionEndPos)\r\n  }\r\n}\r\n\r\nfunction next () {\r\n  return str.charCodeAt(++index$1)\r\n}\r\n\r\nfunction eof () {\r\n  return index$1 >= len\r\n}\r\n\r\nfunction isStringStart (chr) {\r\n  return chr === 0x22 || chr === 0x27\r\n}\r\n\r\nfunction parseBracket (chr) {\r\n  var inBracket = 1;\r\n  expressionPos = index$1;\r\n  while (!eof()) {\r\n    chr = next();\r\n    if (isStringStart(chr)) {\r\n      parseString(chr);\r\n      continue\r\n    }\r\n    if (chr === 0x5B) { inBracket++; }\r\n    if (chr === 0x5D) { inBracket--; }\r\n    if (inBracket === 0) {\r\n      expressionEndPos = index$1;\r\n      break\r\n    }\r\n  }\r\n}\r\n\r\nfunction parseString (chr) {\r\n  var stringQuote = chr;\r\n  while (!eof()) {\r\n    chr = next();\r\n    if (chr === stringQuote) {\r\n      break\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar warn$1;\r\n\r\n// in some cases, the event used has to be determined at runtime\r\n// so we used some reserved tokens during compile.\r\nvar RANGE_TOKEN = '__r';\r\nvar CHECKBOX_RADIO_TOKEN = '__c';\r\n\r\nfunction model (\r\n  el,\r\n  dir,\r\n  _warn\r\n) {\r\n  warn$1 = _warn;\r\n  var value = dir.value;\r\n  var modifiers = dir.modifiers;\r\n  var tag = el.tag;\r\n  var type = el.attrsMap.type;\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\r\n    if (tag === 'input' && dynamicType) {\r\n      warn$1(\r\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\r\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\r\n      );\r\n    }\r\n    // inputs with type=\"file\" are read only and setting the input's\r\n    // value will throw an error.\r\n    if (tag === 'input' && type === 'file') {\r\n      warn$1(\r\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\r\n        \"File inputs are read only. Use a v-on:change listener instead.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  if (el.component) {\r\n    genComponentModel(el, value, modifiers);\r\n    // component v-model doesn't need extra runtime\r\n    return false\r\n  } else if (tag === 'select') {\r\n    genSelect(el, value, modifiers);\r\n  } else if (tag === 'input' && type === 'checkbox') {\r\n    genCheckboxModel(el, value, modifiers);\r\n  } else if (tag === 'input' && type === 'radio') {\r\n    genRadioModel(el, value, modifiers);\r\n  } else if (tag === 'input' || tag === 'textarea') {\r\n    genDefaultModel(el, value, modifiers);\r\n  } else if (!config.isReservedTag(tag)) {\r\n    genComponentModel(el, value, modifiers);\r\n    // component v-model doesn't need extra runtime\r\n    return false\r\n  } else if (process.env.NODE_ENV !== 'production') {\r\n    warn$1(\r\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\r\n      \"v-model is not supported on this element type. \" +\r\n      'If you are working with contenteditable, it\\'s recommended to ' +\r\n      'wrap a library dedicated for that purpose inside a custom component.'\r\n    );\r\n  }\r\n\r\n  // ensure runtime directive metadata\r\n  return true\r\n}\r\n\r\nfunction genCheckboxModel (\r\n  el,\r\n  value,\r\n  modifiers\r\n) {\r\n  var number = modifiers && modifiers.number;\r\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\r\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\r\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\r\n  addProp(el, 'checked',\r\n    \"Array.isArray(\" + value + \")\" +\r\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\r\n        trueValueBinding === 'true'\r\n          ? (\":(\" + value + \")\")\r\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\r\n      )\r\n  );\r\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\r\n    \"var $$a=\" + value + \",\" +\r\n        '$$el=$event.target,' +\r\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\r\n    'if(Array.isArray($$a)){' +\r\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\r\n          '$$i=_i($$a,$$v);' +\r\n      \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat([$$v]))}\" +\r\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\r\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\r\n    null, true\r\n  );\r\n}\r\n\r\nfunction genRadioModel (\r\n    el,\r\n    value,\r\n    modifiers\r\n) {\r\n  var number = modifiers && modifiers.number;\r\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\r\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\r\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\r\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\r\n}\r\n\r\nfunction genSelect (\r\n    el,\r\n    value,\r\n    modifiers\r\n) {\r\n  var number = modifiers && modifiers.number;\r\n  var selectedVal = \"Array.prototype.filter\" +\r\n    \".call($event.target.options,function(o){return o.selected})\" +\r\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\r\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\r\n\r\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\r\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\r\n  code = code + \" \" + (genAssignmentCode(value, assignment));\r\n  addHandler(el, 'change', code, null, true);\r\n}\r\n\r\nfunction genDefaultModel (\r\n  el,\r\n  value,\r\n  modifiers\r\n) {\r\n  var type = el.attrsMap.type;\r\n  var ref = modifiers || {};\r\n  var lazy = ref.lazy;\r\n  var number = ref.number;\r\n  var trim = ref.trim;\r\n  var needCompositionGuard = !lazy && type !== 'range';\r\n  var event = lazy\r\n    ? 'change'\r\n    : type === 'range'\r\n      ? RANGE_TOKEN\r\n      : 'input';\r\n\r\n  var valueExpression = '$event.target.value';\r\n  if (trim) {\r\n    valueExpression = \"$event.target.value.trim()\";\r\n  }\r\n  if (number) {\r\n    valueExpression = \"_n(\" + valueExpression + \")\";\r\n  }\r\n\r\n  var code = genAssignmentCode(value, valueExpression);\r\n  if (needCompositionGuard) {\r\n    code = \"if($event.target.composing)return;\" + code;\r\n  }\r\n\r\n  addProp(el, 'value', (\"(\" + value + \")\"));\r\n  addHandler(el, event, code, null, true);\r\n  if (trim || number) {\r\n    addHandler(el, 'blur', '$forceUpdate()');\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n// normalize v-model event tokens that can only be determined at runtime.\r\n// it's important to place the event as the first in the array because\r\n// the whole point is ensuring the v-model callback gets called before\r\n// user-attached handlers.\r\nfunction normalizeEvents (on) {\r\n  var event;\r\n  /* istanbul ignore if */\r\n  if (isDef(on[RANGE_TOKEN])) {\r\n    // IE input[type=range] only supports `change` event\r\n    event = isIE ? 'change' : 'input';\r\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\r\n    delete on[RANGE_TOKEN];\r\n  }\r\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\r\n    // Chrome fires microtasks in between click/change, leads to #4521\r\n    event = isChrome ? 'click' : 'change';\r\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\r\n    delete on[CHECKBOX_RADIO_TOKEN];\r\n  }\r\n}\r\n\r\nvar target$1;\r\n\r\nfunction add$1 (\r\n  event,\r\n  handler,\r\n  once$$1,\r\n  capture,\r\n  passive\r\n) {\r\n  if (once$$1) {\r\n    var oldHandler = handler;\r\n    var _target = target$1; // save current target element in closure\r\n    handler = function (ev) {\r\n      var res = arguments.length === 1\r\n        ? oldHandler(ev)\r\n        : oldHandler.apply(null, arguments);\r\n      if (res !== null) {\r\n        remove$2(event, handler, capture, _target);\r\n      }\r\n    };\r\n  }\r\n  target$1.addEventListener(\r\n    event,\r\n    handler,\r\n    supportsPassive\r\n      ? { capture: capture, passive: passive }\r\n      : capture\r\n  );\r\n}\r\n\r\nfunction remove$2 (\r\n  event,\r\n  handler,\r\n  capture,\r\n  _target\r\n) {\r\n  (_target || target$1).removeEventListener(event, handler, capture);\r\n}\r\n\r\nfunction updateDOMListeners (oldVnode, vnode) {\r\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\r\n    return\r\n  }\r\n  var on = vnode.data.on || {};\r\n  var oldOn = oldVnode.data.on || {};\r\n  target$1 = vnode.elm;\r\n  normalizeEvents(on);\r\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\r\n}\r\n\r\nvar events = {\r\n  create: updateDOMListeners,\r\n  update: updateDOMListeners\r\n};\r\n\r\n/*  */\r\n\r\nfunction updateDOMProps (oldVnode, vnode) {\r\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\r\n    return\r\n  }\r\n  var key, cur;\r\n  var elm = vnode.elm;\r\n  var oldProps = oldVnode.data.domProps || {};\r\n  var props = vnode.data.domProps || {};\r\n  // clone observed objects, as the user probably wants to mutate it\r\n  if (isDef(props.__ob__)) {\r\n    props = vnode.data.domProps = extend({}, props);\r\n  }\r\n\r\n  for (key in oldProps) {\r\n    if (isUndef(props[key])) {\r\n      elm[key] = '';\r\n    }\r\n  }\r\n  for (key in props) {\r\n    cur = props[key];\r\n    // ignore children if the node has textContent or innerHTML,\r\n    // as these will throw away existing DOM nodes and cause removal errors\r\n    // on subsequent patches (#3360)\r\n    if (key === 'textContent' || key === 'innerHTML') {\r\n      if (vnode.children) { vnode.children.length = 0; }\r\n      if (cur === oldProps[key]) { continue }\r\n    }\r\n\r\n    if (key === 'value') {\r\n      // store value as _value as well since\r\n      // non-string values will be stringified\r\n      elm._value = cur;\r\n      // avoid resetting cursor position when value is the same\r\n      var strCur = isUndef(cur) ? '' : String(cur);\r\n      if (shouldUpdateValue(elm, vnode, strCur)) {\r\n        elm.value = strCur;\r\n      }\r\n    } else {\r\n      elm[key] = cur;\r\n    }\r\n  }\r\n}\r\n\r\n// check platforms/web/util/attrs.js acceptValue\r\n\r\n\r\nfunction shouldUpdateValue (\r\n  elm,\r\n  vnode,\r\n  checkVal\r\n) {\r\n  return (!elm.composing && (\r\n    vnode.tag === 'option' ||\r\n    isDirty(elm, checkVal) ||\r\n    isInputChanged(elm, checkVal)\r\n  ))\r\n}\r\n\r\nfunction isDirty (elm, checkVal) {\r\n  // return true when textbox (.number and .trim) loses focus and its value is\r\n  // not equal to the updated value\r\n  var notInFocus = true;\r\n  // #6157\r\n  // work around IE bug when accessing document.activeElement in an iframe\r\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\r\n  return notInFocus && elm.value !== checkVal\r\n}\r\n\r\nfunction isInputChanged (elm, newVal) {\r\n  var value = elm.value;\r\n  var modifiers = elm._vModifiers; // injected by v-model runtime\r\n  if (isDef(modifiers) && modifiers.number) {\r\n    return toNumber(value) !== toNumber(newVal)\r\n  }\r\n  if (isDef(modifiers) && modifiers.trim) {\r\n    return value.trim() !== newVal.trim()\r\n  }\r\n  return value !== newVal\r\n}\r\n\r\nvar domProps = {\r\n  create: updateDOMProps,\r\n  update: updateDOMProps\r\n};\r\n\r\n/*  */\r\n\r\nvar parseStyleText = cached(function (cssText) {\r\n  var res = {};\r\n  var listDelimiter = /;(?![^(]*\\))/g;\r\n  var propertyDelimiter = /:(.+)/;\r\n  cssText.split(listDelimiter).forEach(function (item) {\r\n    if (item) {\r\n      var tmp = item.split(propertyDelimiter);\r\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\r\n    }\r\n  });\r\n  return res\r\n});\r\n\r\n// merge static and dynamic style data on the same vnode\r\nfunction normalizeStyleData (data) {\r\n  var style = normalizeStyleBinding(data.style);\r\n  // static style is pre-processed into an object during compilation\r\n  // and is always a fresh object, so it's safe to merge into it\r\n  return data.staticStyle\r\n    ? extend(data.staticStyle, style)\r\n    : style\r\n}\r\n\r\n// normalize possible array / string values into Object\r\nfunction normalizeStyleBinding (bindingStyle) {\r\n  if (Array.isArray(bindingStyle)) {\r\n    return toObject(bindingStyle)\r\n  }\r\n  if (typeof bindingStyle === 'string') {\r\n    return parseStyleText(bindingStyle)\r\n  }\r\n  return bindingStyle\r\n}\r\n\r\n/**\r\n * parent component style should be after child's\r\n * so that parent component's style could override it\r\n */\r\nfunction getStyle (vnode, checkChild) {\r\n  var res = {};\r\n  var styleData;\r\n\r\n  if (checkChild) {\r\n    var childNode = vnode;\r\n    while (childNode.componentInstance) {\r\n      childNode = childNode.componentInstance._vnode;\r\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\r\n        extend(res, styleData);\r\n      }\r\n    }\r\n  }\r\n\r\n  if ((styleData = normalizeStyleData(vnode.data))) {\r\n    extend(res, styleData);\r\n  }\r\n\r\n  var parentNode = vnode;\r\n  while ((parentNode = parentNode.parent)) {\r\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\r\n      extend(res, styleData);\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\n/*  */\r\n\r\nvar cssVarRE = /^--/;\r\nvar importantRE = /\\s*!important$/;\r\nvar setProp = function (el, name, val) {\r\n  /* istanbul ignore if */\r\n  if (cssVarRE.test(name)) {\r\n    el.style.setProperty(name, val);\r\n  } else if (importantRE.test(val)) {\r\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\r\n  } else {\r\n    var normalizedName = normalize(name);\r\n    if (Array.isArray(val)) {\r\n      // Support values array created by autoprefixer, e.g.\r\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\r\n      // Set them one by one, and the browser will only set those it can recognize\r\n      for (var i = 0, len = val.length; i < len; i++) {\r\n        el.style[normalizedName] = val[i];\r\n      }\r\n    } else {\r\n      el.style[normalizedName] = val;\r\n    }\r\n  }\r\n};\r\n\r\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\r\n\r\nvar emptyStyle;\r\nvar normalize = cached(function (prop) {\r\n  emptyStyle = emptyStyle || document.createElement('div').style;\r\n  prop = camelize(prop);\r\n  if (prop !== 'filter' && (prop in emptyStyle)) {\r\n    return prop\r\n  }\r\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\r\n  for (var i = 0; i < vendorNames.length; i++) {\r\n    var name = vendorNames[i] + capName;\r\n    if (name in emptyStyle) {\r\n      return name\r\n    }\r\n  }\r\n});\r\n\r\nfunction updateStyle (oldVnode, vnode) {\r\n  var data = vnode.data;\r\n  var oldData = oldVnode.data;\r\n\r\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\r\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\r\n  ) {\r\n    return\r\n  }\r\n\r\n  var cur, name;\r\n  var el = vnode.elm;\r\n  var oldStaticStyle = oldData.staticStyle;\r\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\r\n\r\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\r\n  var oldStyle = oldStaticStyle || oldStyleBinding;\r\n\r\n  var style = normalizeStyleBinding(vnode.data.style) || {};\r\n\r\n  // store normalized style under a different key for next diff\r\n  // make sure to clone it if it's reactive, since the user likely wants\r\n  // to mutate it.\r\n  vnode.data.normalizedStyle = isDef(style.__ob__)\r\n    ? extend({}, style)\r\n    : style;\r\n\r\n  var newStyle = getStyle(vnode, true);\r\n\r\n  for (name in oldStyle) {\r\n    if (isUndef(newStyle[name])) {\r\n      setProp(el, name, '');\r\n    }\r\n  }\r\n  for (name in newStyle) {\r\n    cur = newStyle[name];\r\n    if (cur !== oldStyle[name]) {\r\n      // ie9 setting to null has no effect, must use empty string\r\n      setProp(el, name, cur == null ? '' : cur);\r\n    }\r\n  }\r\n}\r\n\r\nvar style = {\r\n  create: updateStyle,\r\n  update: updateStyle\r\n};\r\n\r\n/*  */\r\n\r\n/**\r\n * Add class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction addClass (el, cls) {\r\n  /* istanbul ignore if */\r\n  if (!cls || !(cls = cls.trim())) {\r\n    return\r\n  }\r\n\r\n  /* istanbul ignore else */\r\n  if (el.classList) {\r\n    if (cls.indexOf(' ') > -1) {\r\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\r\n    } else {\r\n      el.classList.add(cls);\r\n    }\r\n  } else {\r\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\r\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\r\n      el.setAttribute('class', (cur + cls).trim());\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Remove class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction removeClass (el, cls) {\r\n  /* istanbul ignore if */\r\n  if (!cls || !(cls = cls.trim())) {\r\n    return\r\n  }\r\n\r\n  /* istanbul ignore else */\r\n  if (el.classList) {\r\n    if (cls.indexOf(' ') > -1) {\r\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\r\n    } else {\r\n      el.classList.remove(cls);\r\n    }\r\n    if (!el.classList.length) {\r\n      el.removeAttribute('class');\r\n    }\r\n  } else {\r\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\r\n    var tar = ' ' + cls + ' ';\r\n    while (cur.indexOf(tar) >= 0) {\r\n      cur = cur.replace(tar, ' ');\r\n    }\r\n    cur = cur.trim();\r\n    if (cur) {\r\n      el.setAttribute('class', cur);\r\n    } else {\r\n      el.removeAttribute('class');\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction resolveTransition (def$$1) {\r\n  if (!def$$1) {\r\n    return\r\n  }\r\n  /* istanbul ignore else */\r\n  if (typeof def$$1 === 'object') {\r\n    var res = {};\r\n    if (def$$1.css !== false) {\r\n      extend(res, autoCssTransition(def$$1.name || 'v'));\r\n    }\r\n    extend(res, def$$1);\r\n    return res\r\n  } else if (typeof def$$1 === 'string') {\r\n    return autoCssTransition(def$$1)\r\n  }\r\n}\r\n\r\nvar autoCssTransition = cached(function (name) {\r\n  return {\r\n    enterClass: (name + \"-enter\"),\r\n    enterToClass: (name + \"-enter-to\"),\r\n    enterActiveClass: (name + \"-enter-active\"),\r\n    leaveClass: (name + \"-leave\"),\r\n    leaveToClass: (name + \"-leave-to\"),\r\n    leaveActiveClass: (name + \"-leave-active\")\r\n  }\r\n});\r\n\r\nvar hasTransition = inBrowser && !isIE9;\r\nvar TRANSITION = 'transition';\r\nvar ANIMATION = 'animation';\r\n\r\n// Transition property/event sniffing\r\nvar transitionProp = 'transition';\r\nvar transitionEndEvent = 'transitionend';\r\nvar animationProp = 'animation';\r\nvar animationEndEvent = 'animationend';\r\nif (hasTransition) {\r\n  /* istanbul ignore if */\r\n  if (window.ontransitionend === undefined &&\r\n    window.onwebkittransitionend !== undefined\r\n  ) {\r\n    transitionProp = 'WebkitTransition';\r\n    transitionEndEvent = 'webkitTransitionEnd';\r\n  }\r\n  if (window.onanimationend === undefined &&\r\n    window.onwebkitanimationend !== undefined\r\n  ) {\r\n    animationProp = 'WebkitAnimation';\r\n    animationEndEvent = 'webkitAnimationEnd';\r\n  }\r\n}\r\n\r\n// binding to window is necessary to make hot reload work in IE in strict mode\r\nvar raf = inBrowser && window.requestAnimationFrame\r\n  ? window.requestAnimationFrame.bind(window)\r\n  : setTimeout;\r\n\r\nfunction nextFrame (fn) {\r\n  raf(function () {\r\n    raf(fn);\r\n  });\r\n}\r\n\r\nfunction addTransitionClass (el, cls) {\r\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\r\n  if (transitionClasses.indexOf(cls) < 0) {\r\n    transitionClasses.push(cls);\r\n    addClass(el, cls);\r\n  }\r\n}\r\n\r\nfunction removeTransitionClass (el, cls) {\r\n  if (el._transitionClasses) {\r\n    remove(el._transitionClasses, cls);\r\n  }\r\n  removeClass(el, cls);\r\n}\r\n\r\nfunction whenTransitionEnds (\r\n  el,\r\n  expectedType,\r\n  cb\r\n) {\r\n  var ref = getTransitionInfo(el, expectedType);\r\n  var type = ref.type;\r\n  var timeout = ref.timeout;\r\n  var propCount = ref.propCount;\r\n  if (!type) { return cb() }\r\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\r\n  var ended = 0;\r\n  var end = function () {\r\n    el.removeEventListener(event, onEnd);\r\n    cb();\r\n  };\r\n  var onEnd = function (e) {\r\n    if (e.target === el) {\r\n      if (++ended >= propCount) {\r\n        end();\r\n      }\r\n    }\r\n  };\r\n  setTimeout(function () {\r\n    if (ended < propCount) {\r\n      end();\r\n    }\r\n  }, timeout + 1);\r\n  el.addEventListener(event, onEnd);\r\n}\r\n\r\nvar transformRE = /\\b(transform|all)(,|$)/;\r\n\r\nfunction getTransitionInfo (el, expectedType) {\r\n  var styles = window.getComputedStyle(el);\r\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\r\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\r\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\r\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\r\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\r\n\r\n  var type;\r\n  var timeout = 0;\r\n  var propCount = 0;\r\n  /* istanbul ignore if */\r\n  if (expectedType === TRANSITION) {\r\n    if (transitionTimeout > 0) {\r\n      type = TRANSITION;\r\n      timeout = transitionTimeout;\r\n      propCount = transitionDurations.length;\r\n    }\r\n  } else if (expectedType === ANIMATION) {\r\n    if (animationTimeout > 0) {\r\n      type = ANIMATION;\r\n      timeout = animationTimeout;\r\n      propCount = animationDurations.length;\r\n    }\r\n  } else {\r\n    timeout = Math.max(transitionTimeout, animationTimeout);\r\n    type = timeout > 0\r\n      ? transitionTimeout > animationTimeout\r\n        ? TRANSITION\r\n        : ANIMATION\r\n      : null;\r\n    propCount = type\r\n      ? type === TRANSITION\r\n        ? transitionDurations.length\r\n        : animationDurations.length\r\n      : 0;\r\n  }\r\n  var hasTransform =\r\n    type === TRANSITION &&\r\n    transformRE.test(styles[transitionProp + 'Property']);\r\n  return {\r\n    type: type,\r\n    timeout: timeout,\r\n    propCount: propCount,\r\n    hasTransform: hasTransform\r\n  }\r\n}\r\n\r\nfunction getTimeout (delays, durations) {\r\n  /* istanbul ignore next */\r\n  while (delays.length < durations.length) {\r\n    delays = delays.concat(delays);\r\n  }\r\n\r\n  return Math.max.apply(null, durations.map(function (d, i) {\r\n    return toMs(d) + toMs(delays[i])\r\n  }))\r\n}\r\n\r\nfunction toMs (s) {\r\n  return Number(s.slice(0, -1)) * 1000\r\n}\r\n\r\n/*  */\r\n\r\nfunction enter (vnode, toggleDisplay) {\r\n  var el = vnode.elm;\r\n\r\n  // call leave callback now\r\n  if (isDef(el._leaveCb)) {\r\n    el._leaveCb.cancelled = true;\r\n    el._leaveCb();\r\n  }\r\n\r\n  var data = resolveTransition(vnode.data.transition);\r\n  if (isUndef(data)) {\r\n    return\r\n  }\r\n\r\n  /* istanbul ignore if */\r\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\r\n    return\r\n  }\r\n\r\n  var css = data.css;\r\n  var type = data.type;\r\n  var enterClass = data.enterClass;\r\n  var enterToClass = data.enterToClass;\r\n  var enterActiveClass = data.enterActiveClass;\r\n  var appearClass = data.appearClass;\r\n  var appearToClass = data.appearToClass;\r\n  var appearActiveClass = data.appearActiveClass;\r\n  var beforeEnter = data.beforeEnter;\r\n  var enter = data.enter;\r\n  var afterEnter = data.afterEnter;\r\n  var enterCancelled = data.enterCancelled;\r\n  var beforeAppear = data.beforeAppear;\r\n  var appear = data.appear;\r\n  var afterAppear = data.afterAppear;\r\n  var appearCancelled = data.appearCancelled;\r\n  var duration = data.duration;\r\n\r\n  // activeInstance will always be the <transition> component managing this\r\n  // transition. One edge case to check is when the <transition> is placed\r\n  // as the root node of a child component. In that case we need to check\r\n  // <transition>'s parent for appear check.\r\n  var context = activeInstance;\r\n  var transitionNode = activeInstance.$vnode;\r\n  while (transitionNode && transitionNode.parent) {\r\n    transitionNode = transitionNode.parent;\r\n    context = transitionNode.context;\r\n  }\r\n\r\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\r\n\r\n  if (isAppear && !appear && appear !== '') {\r\n    return\r\n  }\r\n\r\n  var startClass = isAppear && appearClass\r\n    ? appearClass\r\n    : enterClass;\r\n  var activeClass = isAppear && appearActiveClass\r\n    ? appearActiveClass\r\n    : enterActiveClass;\r\n  var toClass = isAppear && appearToClass\r\n    ? appearToClass\r\n    : enterToClass;\r\n\r\n  var beforeEnterHook = isAppear\r\n    ? (beforeAppear || beforeEnter)\r\n    : beforeEnter;\r\n  var enterHook = isAppear\r\n    ? (typeof appear === 'function' ? appear : enter)\r\n    : enter;\r\n  var afterEnterHook = isAppear\r\n    ? (afterAppear || afterEnter)\r\n    : afterEnter;\r\n  var enterCancelledHook = isAppear\r\n    ? (appearCancelled || enterCancelled)\r\n    : enterCancelled;\r\n\r\n  var explicitEnterDuration = toNumber(\r\n    isObject(duration)\r\n      ? duration.enter\r\n      : duration\r\n  );\r\n\r\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\r\n    checkDuration(explicitEnterDuration, 'enter', vnode);\r\n  }\r\n\r\n  var expectsCSS = css !== false && !isIE9;\r\n  var userWantsControl = getHookArgumentsLength(enterHook);\r\n\r\n  var cb = el._enterCb = once(function () {\r\n    if (expectsCSS) {\r\n      removeTransitionClass(el, toClass);\r\n      removeTransitionClass(el, activeClass);\r\n    }\r\n    if (cb.cancelled) {\r\n      if (expectsCSS) {\r\n        removeTransitionClass(el, startClass);\r\n      }\r\n      enterCancelledHook && enterCancelledHook(el);\r\n    } else {\r\n      afterEnterHook && afterEnterHook(el);\r\n    }\r\n    el._enterCb = null;\r\n  });\r\n\r\n  if (!vnode.data.show) {\r\n    // remove pending leave element on enter by injecting an insert hook\r\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\r\n      var parent = el.parentNode;\r\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\r\n      if (pendingNode &&\r\n        pendingNode.tag === vnode.tag &&\r\n        pendingNode.elm._leaveCb\r\n      ) {\r\n        pendingNode.elm._leaveCb();\r\n      }\r\n      enterHook && enterHook(el, cb);\r\n    });\r\n  }\r\n\r\n  // start enter transition\r\n  beforeEnterHook && beforeEnterHook(el);\r\n  if (expectsCSS) {\r\n    addTransitionClass(el, startClass);\r\n    addTransitionClass(el, activeClass);\r\n    nextFrame(function () {\r\n      addTransitionClass(el, toClass);\r\n      removeTransitionClass(el, startClass);\r\n      if (!cb.cancelled && !userWantsControl) {\r\n        if (isValidDuration(explicitEnterDuration)) {\r\n          setTimeout(cb, explicitEnterDuration);\r\n        } else {\r\n          whenTransitionEnds(el, type, cb);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  if (vnode.data.show) {\r\n    toggleDisplay && toggleDisplay();\r\n    enterHook && enterHook(el, cb);\r\n  }\r\n\r\n  if (!expectsCSS && !userWantsControl) {\r\n    cb();\r\n  }\r\n}\r\n\r\nfunction leave (vnode, rm) {\r\n  var el = vnode.elm;\r\n\r\n  // call enter callback now\r\n  if (isDef(el._enterCb)) {\r\n    el._enterCb.cancelled = true;\r\n    el._enterCb();\r\n  }\r\n\r\n  var data = resolveTransition(vnode.data.transition);\r\n  if (isUndef(data)) {\r\n    return rm()\r\n  }\r\n\r\n  /* istanbul ignore if */\r\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\r\n    return\r\n  }\r\n\r\n  var css = data.css;\r\n  var type = data.type;\r\n  var leaveClass = data.leaveClass;\r\n  var leaveToClass = data.leaveToClass;\r\n  var leaveActiveClass = data.leaveActiveClass;\r\n  var beforeLeave = data.beforeLeave;\r\n  var leave = data.leave;\r\n  var afterLeave = data.afterLeave;\r\n  var leaveCancelled = data.leaveCancelled;\r\n  var delayLeave = data.delayLeave;\r\n  var duration = data.duration;\r\n\r\n  var expectsCSS = css !== false && !isIE9;\r\n  var userWantsControl = getHookArgumentsLength(leave);\r\n\r\n  var explicitLeaveDuration = toNumber(\r\n    isObject(duration)\r\n      ? duration.leave\r\n      : duration\r\n  );\r\n\r\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\r\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\r\n  }\r\n\r\n  var cb = el._leaveCb = once(function () {\r\n    if (el.parentNode && el.parentNode._pending) {\r\n      el.parentNode._pending[vnode.key] = null;\r\n    }\r\n    if (expectsCSS) {\r\n      removeTransitionClass(el, leaveToClass);\r\n      removeTransitionClass(el, leaveActiveClass);\r\n    }\r\n    if (cb.cancelled) {\r\n      if (expectsCSS) {\r\n        removeTransitionClass(el, leaveClass);\r\n      }\r\n      leaveCancelled && leaveCancelled(el);\r\n    } else {\r\n      rm();\r\n      afterLeave && afterLeave(el);\r\n    }\r\n    el._leaveCb = null;\r\n  });\r\n\r\n  if (delayLeave) {\r\n    delayLeave(performLeave);\r\n  } else {\r\n    performLeave();\r\n  }\r\n\r\n  function performLeave () {\r\n    // the delayed leave may have already been cancelled\r\n    if (cb.cancelled) {\r\n      return\r\n    }\r\n    // record leaving element\r\n    if (!vnode.data.show) {\r\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\r\n    }\r\n    beforeLeave && beforeLeave(el);\r\n    if (expectsCSS) {\r\n      addTransitionClass(el, leaveClass);\r\n      addTransitionClass(el, leaveActiveClass);\r\n      nextFrame(function () {\r\n        addTransitionClass(el, leaveToClass);\r\n        removeTransitionClass(el, leaveClass);\r\n        if (!cb.cancelled && !userWantsControl) {\r\n          if (isValidDuration(explicitLeaveDuration)) {\r\n            setTimeout(cb, explicitLeaveDuration);\r\n          } else {\r\n            whenTransitionEnds(el, type, cb);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    leave && leave(el, cb);\r\n    if (!expectsCSS && !userWantsControl) {\r\n      cb();\r\n    }\r\n  }\r\n}\r\n\r\n// only used in dev mode\r\nfunction checkDuration (val, name, vnode) {\r\n  if (typeof val !== 'number') {\r\n    warn(\r\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\r\n      \"got \" + (JSON.stringify(val)) + \".\",\r\n      vnode.context\r\n    );\r\n  } else if (isNaN(val)) {\r\n    warn(\r\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\r\n      'the duration expression might be incorrect.',\r\n      vnode.context\r\n    );\r\n  }\r\n}\r\n\r\nfunction isValidDuration (val) {\r\n  return typeof val === 'number' && !isNaN(val)\r\n}\r\n\r\n/**\r\n * Normalize a transition hook's argument length. The hook may be:\r\n * - a merged hook (invoker) with the original in .fns\r\n * - a wrapped component method (check ._length)\r\n * - a plain function (.length)\r\n */\r\nfunction getHookArgumentsLength (fn) {\r\n  if (isUndef(fn)) {\r\n    return false\r\n  }\r\n  var invokerFns = fn.fns;\r\n  if (isDef(invokerFns)) {\r\n    // invoker\r\n    return getHookArgumentsLength(\r\n      Array.isArray(invokerFns)\r\n        ? invokerFns[0]\r\n        : invokerFns\r\n    )\r\n  } else {\r\n    return (fn._length || fn.length) > 1\r\n  }\r\n}\r\n\r\nfunction _enter (_, vnode) {\r\n  if (vnode.data.show !== true) {\r\n    enter(vnode);\r\n  }\r\n}\r\n\r\nvar transition = inBrowser ? {\r\n  create: _enter,\r\n  activate: _enter,\r\n  remove: function remove$$1 (vnode, rm) {\r\n    /* istanbul ignore else */\r\n    if (vnode.data.show !== true) {\r\n      leave(vnode, rm);\r\n    } else {\r\n      rm();\r\n    }\r\n  }\r\n} : {};\r\n\r\nvar platformModules = [\r\n  attrs,\r\n  klass,\r\n  events,\r\n  domProps,\r\n  style,\r\n  transition\r\n];\r\n\r\n/*  */\r\n\r\n// the directive module should be applied last, after all\r\n// built-in modules have been applied.\r\nvar modules = platformModules.concat(baseModules);\r\n\r\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\r\n\r\n/**\r\n * Not type checking this file because flow doesn't like attaching\r\n * properties to Elements.\r\n */\r\n\r\n/* istanbul ignore if */\r\nif (isIE9) {\r\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\r\n  document.addEventListener('selectionchange', function () {\r\n    var el = document.activeElement;\r\n    if (el && el.vmodel) {\r\n      trigger(el, 'input');\r\n    }\r\n  });\r\n}\r\n\r\nvar model$1 = {\r\n  inserted: function inserted (el, binding, vnode) {\r\n    if (vnode.tag === 'select') {\r\n      setSelected(el, binding, vnode.context);\r\n      el._vOptions = [].map.call(el.options, getValue);\r\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\r\n      el._vModifiers = binding.modifiers;\r\n      if (!binding.modifiers.lazy) {\r\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n        // switching focus before confirming composition choice\r\n        // this also fixes the issue where some browsers e.g. iOS Chrome\r\n        // fires \"change\" instead of \"input\" on autocomplete.\r\n        el.addEventListener('change', onCompositionEnd);\r\n        if (!isAndroid) {\r\n          el.addEventListener('compositionstart', onCompositionStart);\r\n          el.addEventListener('compositionend', onCompositionEnd);\r\n        }\r\n        /* istanbul ignore if */\r\n        if (isIE9) {\r\n          el.vmodel = true;\r\n        }\r\n      }\r\n    }\r\n  },\r\n  componentUpdated: function componentUpdated (el, binding, vnode) {\r\n    if (vnode.tag === 'select') {\r\n      setSelected(el, binding, vnode.context);\r\n      // in case the options rendered by v-for have changed,\r\n      // it's possible that the value is out-of-sync with the rendered options.\r\n      // detect such cases and filter out values that no longer has a matching\r\n      // option in the DOM.\r\n      var prevOptions = el._vOptions;\r\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\r\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\r\n        // trigger change event if\r\n        // no matching option found for at least one value\r\n        var needReset = el.multiple\r\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\r\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\r\n        if (needReset) {\r\n          trigger(el, 'change');\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nfunction setSelected (el, binding, vm) {\r\n  actuallySetSelected(el, binding, vm);\r\n  /* istanbul ignore if */\r\n  if (isIE || isEdge) {\r\n    setTimeout(function () {\r\n      actuallySetSelected(el, binding, vm);\r\n    }, 0);\r\n  }\r\n}\r\n\r\nfunction actuallySetSelected (el, binding, vm) {\r\n  var value = binding.value;\r\n  var isMultiple = el.multiple;\r\n  if (isMultiple && !Array.isArray(value)) {\r\n    process.env.NODE_ENV !== 'production' && warn(\r\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\r\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\r\n      vm\r\n    );\r\n    return\r\n  }\r\n  var selected, option;\r\n  for (var i = 0, l = el.options.length; i < l; i++) {\r\n    option = el.options[i];\r\n    if (isMultiple) {\r\n      selected = looseIndexOf(value, getValue(option)) > -1;\r\n      if (option.selected !== selected) {\r\n        option.selected = selected;\r\n      }\r\n    } else {\r\n      if (looseEqual(getValue(option), value)) {\r\n        if (el.selectedIndex !== i) {\r\n          el.selectedIndex = i;\r\n        }\r\n        return\r\n      }\r\n    }\r\n  }\r\n  if (!isMultiple) {\r\n    el.selectedIndex = -1;\r\n  }\r\n}\r\n\r\nfunction hasNoMatchingOption (value, options) {\r\n  return options.every(function (o) { return !looseEqual(o, value); })\r\n}\r\n\r\nfunction getValue (option) {\r\n  return '_value' in option\r\n    ? option._value\r\n    : option.value\r\n}\r\n\r\nfunction onCompositionStart (e) {\r\n  e.target.composing = true;\r\n}\r\n\r\nfunction onCompositionEnd (e) {\r\n  // prevent triggering an input event for no reason\r\n  if (!e.target.composing) { return }\r\n  e.target.composing = false;\r\n  trigger(e.target, 'input');\r\n}\r\n\r\nfunction trigger (el, type) {\r\n  var e = document.createEvent('HTMLEvents');\r\n  e.initEvent(type, true, true);\r\n  el.dispatchEvent(e);\r\n}\r\n\r\n/*  */\r\n\r\n// recursively search for possible transition defined inside the component root\r\nfunction locateNode (vnode) {\r\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\r\n    ? locateNode(vnode.componentInstance._vnode)\r\n    : vnode\r\n}\r\n\r\nvar show = {\r\n  bind: function bind (el, ref, vnode) {\r\n    var value = ref.value;\r\n\r\n    vnode = locateNode(vnode);\r\n    var transition$$1 = vnode.data && vnode.data.transition;\r\n    var originalDisplay = el.__vOriginalDisplay =\r\n      el.style.display === 'none' ? '' : el.style.display;\r\n    if (value && transition$$1) {\r\n      vnode.data.show = true;\r\n      enter(vnode, function () {\r\n        el.style.display = originalDisplay;\r\n      });\r\n    } else {\r\n      el.style.display = value ? originalDisplay : 'none';\r\n    }\r\n  },\r\n\r\n  update: function update (el, ref, vnode) {\r\n    var value = ref.value;\r\n    var oldValue = ref.oldValue;\r\n\r\n    /* istanbul ignore if */\r\n    if (value === oldValue) { return }\r\n    vnode = locateNode(vnode);\r\n    var transition$$1 = vnode.data && vnode.data.transition;\r\n    if (transition$$1) {\r\n      vnode.data.show = true;\r\n      if (value) {\r\n        enter(vnode, function () {\r\n          el.style.display = el.__vOriginalDisplay;\r\n        });\r\n      } else {\r\n        leave(vnode, function () {\r\n          el.style.display = 'none';\r\n        });\r\n      }\r\n    } else {\r\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\r\n    }\r\n  },\r\n\r\n  unbind: function unbind (\r\n    el,\r\n    binding,\r\n    vnode,\r\n    oldVnode,\r\n    isDestroy\r\n  ) {\r\n    if (!isDestroy) {\r\n      el.style.display = el.__vOriginalDisplay;\r\n    }\r\n  }\r\n};\r\n\r\nvar platformDirectives = {\r\n  model: model$1,\r\n  show: show\r\n};\r\n\r\n/*  */\r\n\r\n// Provides transition support for a single element/component.\r\n// supports transition mode (out-in / in-out)\r\n\r\nvar transitionProps = {\r\n  name: String,\r\n  appear: Boolean,\r\n  css: Boolean,\r\n  mode: String,\r\n  type: String,\r\n  enterClass: String,\r\n  leaveClass: String,\r\n  enterToClass: String,\r\n  leaveToClass: String,\r\n  enterActiveClass: String,\r\n  leaveActiveClass: String,\r\n  appearClass: String,\r\n  appearActiveClass: String,\r\n  appearToClass: String,\r\n  duration: [Number, String, Object]\r\n};\r\n\r\n// in case the child is also an abstract component, e.g. <keep-alive>\r\n// we want to recursively retrieve the real component to be rendered\r\nfunction getRealChild (vnode) {\r\n  var compOptions = vnode && vnode.componentOptions;\r\n  if (compOptions && compOptions.Ctor.options.abstract) {\r\n    return getRealChild(getFirstComponentChild(compOptions.children))\r\n  } else {\r\n    return vnode\r\n  }\r\n}\r\n\r\nfunction extractTransitionData (comp) {\r\n  var data = {};\r\n  var options = comp.$options;\r\n  // props\r\n  for (var key in options.propsData) {\r\n    data[key] = comp[key];\r\n  }\r\n  // events.\r\n  // extract listeners and pass them directly to the transition methods\r\n  var listeners = options._parentListeners;\r\n  for (var key$1 in listeners) {\r\n    data[camelize(key$1)] = listeners[key$1];\r\n  }\r\n  return data\r\n}\r\n\r\nfunction placeholder (h, rawChild) {\r\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\r\n    return h('keep-alive', {\r\n      props: rawChild.componentOptions.propsData\r\n    })\r\n  }\r\n}\r\n\r\nfunction hasParentTransition (vnode) {\r\n  while ((vnode = vnode.parent)) {\r\n    if (vnode.data.transition) {\r\n      return true\r\n    }\r\n  }\r\n}\r\n\r\nfunction isSameChild (child, oldChild) {\r\n  return oldChild.key === child.key && oldChild.tag === child.tag\r\n}\r\n\r\nvar Transition = {\r\n  name: 'transition',\r\n  props: transitionProps,\r\n  abstract: true,\r\n\r\n  render: function render (h) {\r\n    var this$1 = this;\r\n\r\n    var children = this.$options._renderChildren;\r\n    if (!children) {\r\n      return\r\n    }\r\n\r\n    // filter out text nodes (possible whitespaces)\r\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\r\n    /* istanbul ignore if */\r\n    if (!children.length) {\r\n      return\r\n    }\r\n\r\n    // warn multiple elements\r\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\r\n      warn(\r\n        '<transition> can only be used on a single element. Use ' +\r\n        '<transition-group> for lists.',\r\n        this.$parent\r\n      );\r\n    }\r\n\r\n    var mode = this.mode;\r\n\r\n    // warn invalid mode\r\n    if (process.env.NODE_ENV !== 'production' &&\r\n      mode && mode !== 'in-out' && mode !== 'out-in'\r\n    ) {\r\n      warn(\r\n        'invalid <transition> mode: ' + mode,\r\n        this.$parent\r\n      );\r\n    }\r\n\r\n    var rawChild = children[0];\r\n\r\n    // if this is a component root node and the component's\r\n    // parent container node also has transition, skip.\r\n    if (hasParentTransition(this.$vnode)) {\r\n      return rawChild\r\n    }\r\n\r\n    // apply transition data to child\r\n    // use getRealChild() to ignore abstract components e.g. keep-alive\r\n    var child = getRealChild(rawChild);\r\n    /* istanbul ignore if */\r\n    if (!child) {\r\n      return rawChild\r\n    }\r\n\r\n    if (this._leaving) {\r\n      return placeholder(h, rawChild)\r\n    }\r\n\r\n    // ensure a key that is unique to the vnode type and to this transition\r\n    // component instance. This key will be used to remove pending leaving nodes\r\n    // during entering.\r\n    var id = \"__transition-\" + (this._uid) + \"-\";\r\n    child.key = child.key == null\r\n      ? child.isComment\r\n        ? id + 'comment'\r\n        : id + child.tag\r\n      : isPrimitive(child.key)\r\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\r\n        : child.key;\r\n\r\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\r\n    var oldRawChild = this._vnode;\r\n    var oldChild = getRealChild(oldRawChild);\r\n\r\n    // mark v-show\r\n    // so that the transition module can hand over the control to the directive\r\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\r\n      child.data.show = true;\r\n    }\r\n\r\n    if (\r\n      oldChild &&\r\n      oldChild.data &&\r\n      !isSameChild(child, oldChild) &&\r\n      !isAsyncPlaceholder(oldChild)\r\n    ) {\r\n      // replace old child transition data with fresh one\r\n      // important for dynamic transitions!\r\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\r\n      // handle transition mode\r\n      if (mode === 'out-in') {\r\n        // return placeholder node and queue update when leave finishes\r\n        this._leaving = true;\r\n        mergeVNodeHook(oldData, 'afterLeave', function () {\r\n          this$1._leaving = false;\r\n          this$1.$forceUpdate();\r\n        });\r\n        return placeholder(h, rawChild)\r\n      } else if (mode === 'in-out') {\r\n        if (isAsyncPlaceholder(child)) {\r\n          return oldRawChild\r\n        }\r\n        var delayedLeave;\r\n        var performLeave = function () { delayedLeave(); };\r\n        mergeVNodeHook(data, 'afterEnter', performLeave);\r\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\r\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\r\n      }\r\n    }\r\n\r\n    return rawChild\r\n  }\r\n};\r\n\r\n/*  */\r\n\r\n// Provides transition support for list items.\r\n// supports move transitions using the FLIP technique.\r\n\r\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\r\n// it doesn't guarantee the relative positioning of removed elements,\r\n// we force transition-group to update its children into two passes:\r\n// in the first pass, we remove all nodes that need to be removed,\r\n// triggering their leaving transition; in the second pass, we insert/move\r\n// into the final desired state. This way in the second pass removed\r\n// nodes will remain where they should be.\r\n\r\nvar props = extend({\r\n  tag: String,\r\n  moveClass: String\r\n}, transitionProps);\r\n\r\ndelete props.mode;\r\n\r\nvar TransitionGroup = {\r\n  props: props,\r\n\r\n  render: function render (h) {\r\n    var tag = this.tag || this.$vnode.data.tag || 'span';\r\n    var map = Object.create(null);\r\n    var prevChildren = this.prevChildren = this.children;\r\n    var rawChildren = this.$slots.default || [];\r\n    var children = this.children = [];\r\n    var transitionData = extractTransitionData(this);\r\n\r\n    for (var i = 0; i < rawChildren.length; i++) {\r\n      var c = rawChildren[i];\r\n      if (c.tag) {\r\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\r\n          children.push(c);\r\n          map[c.key] = c\r\n          ;(c.data || (c.data = {})).transition = transitionData;\r\n        } else if (process.env.NODE_ENV !== 'production') {\r\n          var opts = c.componentOptions;\r\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\r\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (prevChildren) {\r\n      var kept = [];\r\n      var removed = [];\r\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\r\n        var c$1 = prevChildren[i$1];\r\n        c$1.data.transition = transitionData;\r\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\r\n        if (map[c$1.key]) {\r\n          kept.push(c$1);\r\n        } else {\r\n          removed.push(c$1);\r\n        }\r\n      }\r\n      this.kept = h(tag, null, kept);\r\n      this.removed = removed;\r\n    }\r\n\r\n    return h(tag, null, children)\r\n  },\r\n\r\n  beforeUpdate: function beforeUpdate () {\r\n    // force removing pass\r\n    this.__patch__(\r\n      this._vnode,\r\n      this.kept,\r\n      false, // hydrating\r\n      true // removeOnly (!important, avoids unnecessary moves)\r\n    );\r\n    this._vnode = this.kept;\r\n  },\r\n\r\n  updated: function updated () {\r\n    var children = this.prevChildren;\r\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\r\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\r\n      return\r\n    }\r\n\r\n    // we divide the work into three loops to avoid mixing DOM reads and writes\r\n    // in each iteration - which helps prevent layout thrashing.\r\n    children.forEach(callPendingCbs);\r\n    children.forEach(recordPosition);\r\n    children.forEach(applyTranslation);\r\n\r\n    // force reflow to put everything in position\r\n    var body = document.body;\r\n    var f = body.offsetHeight; // eslint-disable-line\r\n\r\n    children.forEach(function (c) {\r\n      if (c.data.moved) {\r\n        var el = c.elm;\r\n        var s = el.style;\r\n        addTransitionClass(el, moveClass);\r\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\r\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\r\n          if (!e || /transform$/.test(e.propertyName)) {\r\n            el.removeEventListener(transitionEndEvent, cb);\r\n            el._moveCb = null;\r\n            removeTransitionClass(el, moveClass);\r\n          }\r\n        });\r\n      }\r\n    });\r\n  },\r\n\r\n  methods: {\r\n    hasMove: function hasMove (el, moveClass) {\r\n      /* istanbul ignore if */\r\n      if (!hasTransition) {\r\n        return false\r\n      }\r\n      /* istanbul ignore if */\r\n      if (this._hasMove) {\r\n        return this._hasMove\r\n      }\r\n      // Detect whether an element with the move class applied has\r\n      // CSS transitions. Since the element may be inside an entering\r\n      // transition at this very moment, we make a clone of it and remove\r\n      // all other transition classes applied to ensure only the move class\r\n      // is applied.\r\n      var clone = el.cloneNode();\r\n      if (el._transitionClasses) {\r\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\r\n      }\r\n      addClass(clone, moveClass);\r\n      clone.style.display = 'none';\r\n      this.$el.appendChild(clone);\r\n      var info = getTransitionInfo(clone);\r\n      this.$el.removeChild(clone);\r\n      return (this._hasMove = info.hasTransform)\r\n    }\r\n  }\r\n};\r\n\r\nfunction callPendingCbs (c) {\r\n  /* istanbul ignore if */\r\n  if (c.elm._moveCb) {\r\n    c.elm._moveCb();\r\n  }\r\n  /* istanbul ignore if */\r\n  if (c.elm._enterCb) {\r\n    c.elm._enterCb();\r\n  }\r\n}\r\n\r\nfunction recordPosition (c) {\r\n  c.data.newPos = c.elm.getBoundingClientRect();\r\n}\r\n\r\nfunction applyTranslation (c) {\r\n  var oldPos = c.data.pos;\r\n  var newPos = c.data.newPos;\r\n  var dx = oldPos.left - newPos.left;\r\n  var dy = oldPos.top - newPos.top;\r\n  if (dx || dy) {\r\n    c.data.moved = true;\r\n    var s = c.elm.style;\r\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\r\n    s.transitionDuration = '0s';\r\n  }\r\n}\r\n\r\nvar platformComponents = {\r\n  Transition: Transition,\r\n  TransitionGroup: TransitionGroup\r\n};\r\n\r\n/*  */\r\n\r\n// install platform specific utils\r\nVue$3.config.mustUseProp = mustUseProp;\r\nVue$3.config.isReservedTag = isReservedTag;\r\nVue$3.config.isReservedAttr = isReservedAttr;\r\nVue$3.config.getTagNamespace = getTagNamespace;\r\nVue$3.config.isUnknownElement = isUnknownElement;\r\n\r\n// install platform runtime directives & components\r\nextend(Vue$3.options.directives, platformDirectives);\r\nextend(Vue$3.options.components, platformComponents);\r\n\r\n// install platform patch function\r\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\r\n\r\n// public mount method\r\nVue$3.prototype.$mount = function (\r\n  el,\r\n  hydrating\r\n) {\r\n  el = el && inBrowser ? query(el) : undefined;\r\n  return mountComponent(this, el, hydrating)\r\n};\r\n\r\n// devtools global hook\r\n/* istanbul ignore next */\r\nsetTimeout(function () {\r\n  if (config.devtools) {\r\n    if (devtools) {\r\n      devtools.emit('init', Vue$3);\r\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\r\n      console[console.info ? 'info' : 'log'](\r\n        'Download the Vue Devtools extension for a better development experience:\\n' +\r\n        'https://github.com/vuejs/vue-devtools'\r\n      );\r\n    }\r\n  }\r\n  if (process.env.NODE_ENV !== 'production' &&\r\n    config.productionTip !== false &&\r\n    inBrowser && typeof console !== 'undefined'\r\n  ) {\r\n    console[console.info ? 'info' : 'log'](\r\n      \"You are running Vue in development mode.\\n\" +\r\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\r\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\r\n    );\r\n  }\r\n}, 0);\r\n\r\n/*  */\r\n\r\n// check whether current browser encodes a char inside attribute values\r\nfunction shouldDecode (content, encoded) {\r\n  var div = document.createElement('div');\r\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\"/>\";\r\n  return div.innerHTML.indexOf(encoded) > 0\r\n}\r\n\r\n// #3663\r\n// IE encodes newlines inside attribute values while other browsers don't\r\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\r\n\r\n/*  */\r\n\r\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\r\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\r\n\r\nvar buildRegex = cached(function (delimiters) {\r\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\r\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\r\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\r\n});\r\n\r\nfunction parseText (\r\n  text,\r\n  delimiters\r\n) {\r\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\r\n  if (!tagRE.test(text)) {\r\n    return\r\n  }\r\n  var tokens = [];\r\n  var lastIndex = tagRE.lastIndex = 0;\r\n  var match, index;\r\n  while ((match = tagRE.exec(text))) {\r\n    index = match.index;\r\n    // push text token\r\n    if (index > lastIndex) {\r\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\r\n    }\r\n    // tag token\r\n    var exp = parseFilters(match[1].trim());\r\n    tokens.push((\"_s(\" + exp + \")\"));\r\n    lastIndex = index + match[0].length;\r\n  }\r\n  if (lastIndex < text.length) {\r\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\r\n  }\r\n  return tokens.join('+')\r\n}\r\n\r\n/*  */\r\n\r\nfunction transformNode (el, options) {\r\n  var warn = options.warn || baseWarn;\r\n  var staticClass = getAndRemoveAttr(el, 'class');\r\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\r\n    var expression = parseText(staticClass, options.delimiters);\r\n    if (expression) {\r\n      warn(\r\n        \"class=\\\"\" + staticClass + \"\\\": \" +\r\n        'Interpolation inside attributes has been removed. ' +\r\n        'Use v-bind or the colon shorthand instead. For example, ' +\r\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\r\n      );\r\n    }\r\n  }\r\n  if (staticClass) {\r\n    el.staticClass = JSON.stringify(staticClass);\r\n  }\r\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\r\n  if (classBinding) {\r\n    el.classBinding = classBinding;\r\n  }\r\n}\r\n\r\nfunction genData (el) {\r\n  var data = '';\r\n  if (el.staticClass) {\r\n    data += \"staticClass:\" + (el.staticClass) + \",\";\r\n  }\r\n  if (el.classBinding) {\r\n    data += \"class:\" + (el.classBinding) + \",\";\r\n  }\r\n  return data\r\n}\r\n\r\nvar klass$1 = {\r\n  staticKeys: ['staticClass'],\r\n  transformNode: transformNode,\r\n  genData: genData\r\n};\r\n\r\n/*  */\r\n\r\nfunction transformNode$1 (el, options) {\r\n  var warn = options.warn || baseWarn;\r\n  var staticStyle = getAndRemoveAttr(el, 'style');\r\n  if (staticStyle) {\r\n    /* istanbul ignore if */\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      var expression = parseText(staticStyle, options.delimiters);\r\n      if (expression) {\r\n        warn(\r\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\r\n          'Interpolation inside attributes has been removed. ' +\r\n          'Use v-bind or the colon shorthand instead. For example, ' +\r\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\r\n        );\r\n      }\r\n    }\r\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\r\n  }\r\n\r\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\r\n  if (styleBinding) {\r\n    el.styleBinding = styleBinding;\r\n  }\r\n}\r\n\r\nfunction genData$1 (el) {\r\n  var data = '';\r\n  if (el.staticStyle) {\r\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\r\n  }\r\n  if (el.styleBinding) {\r\n    data += \"style:(\" + (el.styleBinding) + \"),\";\r\n  }\r\n  return data\r\n}\r\n\r\nvar style$1 = {\r\n  staticKeys: ['staticStyle'],\r\n  transformNode: transformNode$1,\r\n  genData: genData$1\r\n};\r\n\r\nvar modules$1 = [\r\n  klass$1,\r\n  style$1\r\n];\r\n\r\n/*  */\r\n\r\nfunction text (el, dir) {\r\n  if (dir.value) {\r\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction html (el, dir) {\r\n  if (dir.value) {\r\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\r\n  }\r\n}\r\n\r\nvar directives$1 = {\r\n  model: model,\r\n  text: text,\r\n  html: html\r\n};\r\n\r\n/*  */\r\n\r\nvar isUnaryTag = makeMap(\r\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\r\n  'link,meta,param,source,track,wbr'\r\n);\r\n\r\n// Elements that you can, intentionally, leave open\r\n// (and which close themselves)\r\nvar canBeLeftOpenTag = makeMap(\r\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\r\n);\r\n\r\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\r\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\r\nvar isNonPhrasingTag = makeMap(\r\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\r\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\r\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\r\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\r\n  'title,tr,track'\r\n);\r\n\r\n/*  */\r\n\r\nvar baseOptions = {\r\n  expectHTML: true,\r\n  modules: modules$1,\r\n  directives: directives$1,\r\n  isPreTag: isPreTag,\r\n  isUnaryTag: isUnaryTag,\r\n  mustUseProp: mustUseProp,\r\n  canBeLeftOpenTag: canBeLeftOpenTag,\r\n  isReservedTag: isReservedTag,\r\n  getTagNamespace: getTagNamespace,\r\n  staticKeys: genStaticKeys(modules$1)\r\n};\r\n\r\n/*  */\r\n\r\nvar decoder;\r\n\r\nvar he = {\r\n  decode: function decode (html) {\r\n    decoder = decoder || document.createElement('div');\r\n    decoder.innerHTML = html;\r\n    return decoder.textContent\r\n  }\r\n};\r\n\r\n/**\r\n * Not type-checking this file because it's mostly vendor code.\r\n */\r\n\r\n/*!\r\n * HTML Parser By John Resig (ejohn.org)\r\n * Modified by Juriy \"kangax\" Zaytsev\r\n * Original code by Erik Arvidsson, Mozilla Public License\r\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\r\n */\r\n\r\n// Regular Expressions for parsing tags and attributes\r\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\r\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\r\n// but for Vue templates we can enforce a simple charset\r\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\r\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\r\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\r\nvar startTagClose = /^\\s*(\\/?)>/;\r\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\r\nvar doctype = /^<!DOCTYPE [^>]+>/i;\r\nvar comment = /^<!--/;\r\nvar conditionalComment = /^<!\\[/;\r\n\r\nvar IS_REGEX_CAPTURING_BROKEN = false;\r\n'x'.replace(/x(.)?/g, function (m, g) {\r\n  IS_REGEX_CAPTURING_BROKEN = g === '';\r\n});\r\n\r\n// Special Elements (can contain anything)\r\nvar isPlainTextElement = makeMap('script,style,textarea', true);\r\nvar reCache = {};\r\n\r\nvar decodingMap = {\r\n  '&lt;': '<',\r\n  '&gt;': '>',\r\n  '&quot;': '\"',\r\n  '&amp;': '&',\r\n  '&#10;': '\\n'\r\n};\r\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\r\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\r\n\r\n// #5992\r\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\r\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\r\n\r\nfunction decodeAttr (value, shouldDecodeNewlines) {\r\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\r\n  return value.replace(re, function (match) { return decodingMap[match]; })\r\n}\r\n\r\nfunction parseHTML (html, options) {\r\n  var stack = [];\r\n  var expectHTML = options.expectHTML;\r\n  var isUnaryTag$$1 = options.isUnaryTag || no;\r\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\r\n  var index = 0;\r\n  var last, lastTag;\r\n  while (html) {\r\n    last = html;\r\n    // Make sure we're not in a plaintext content element like script/style\r\n    if (!lastTag || !isPlainTextElement(lastTag)) {\r\n      var textEnd = html.indexOf('<');\r\n      if (textEnd === 0) {\r\n        // Comment:\r\n        if (comment.test(html)) {\r\n          var commentEnd = html.indexOf('-->');\r\n\r\n          if (commentEnd >= 0) {\r\n            if (options.shouldKeepComment) {\r\n              options.comment(html.substring(4, commentEnd));\r\n            }\r\n            advance(commentEnd + 3);\r\n            continue\r\n          }\r\n        }\r\n\r\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\r\n        if (conditionalComment.test(html)) {\r\n          var conditionalEnd = html.indexOf(']>');\r\n\r\n          if (conditionalEnd >= 0) {\r\n            advance(conditionalEnd + 2);\r\n            continue\r\n          }\r\n        }\r\n\r\n        // Doctype:\r\n        var doctypeMatch = html.match(doctype);\r\n        if (doctypeMatch) {\r\n          advance(doctypeMatch[0].length);\r\n          continue\r\n        }\r\n\r\n        // End tag:\r\n        var endTagMatch = html.match(endTag);\r\n        if (endTagMatch) {\r\n          var curIndex = index;\r\n          advance(endTagMatch[0].length);\r\n          parseEndTag(endTagMatch[1], curIndex, index);\r\n          continue\r\n        }\r\n\r\n        // Start tag:\r\n        var startTagMatch = parseStartTag();\r\n        if (startTagMatch) {\r\n          handleStartTag(startTagMatch);\r\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\r\n            advance(1);\r\n          }\r\n          continue\r\n        }\r\n      }\r\n\r\n      var text = (void 0), rest = (void 0), next = (void 0);\r\n      if (textEnd >= 0) {\r\n        rest = html.slice(textEnd);\r\n        while (\r\n          !endTag.test(rest) &&\r\n          !startTagOpen.test(rest) &&\r\n          !comment.test(rest) &&\r\n          !conditionalComment.test(rest)\r\n        ) {\r\n          // < in plain text, be forgiving and treat it as text\r\n          next = rest.indexOf('<', 1);\r\n          if (next < 0) { break }\r\n          textEnd += next;\r\n          rest = html.slice(textEnd);\r\n        }\r\n        text = html.substring(0, textEnd);\r\n        advance(textEnd);\r\n      }\r\n\r\n      if (textEnd < 0) {\r\n        text = html;\r\n        html = '';\r\n      }\r\n\r\n      if (options.chars && text) {\r\n        options.chars(text);\r\n      }\r\n    } else {\r\n      var endTagLength = 0;\r\n      var stackedTag = lastTag.toLowerCase();\r\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\r\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\r\n        endTagLength = endTag.length;\r\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\r\n          text = text\r\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\r\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\r\n        }\r\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\r\n          text = text.slice(1);\r\n        }\r\n        if (options.chars) {\r\n          options.chars(text);\r\n        }\r\n        return ''\r\n      });\r\n      index += html.length - rest$1.length;\r\n      html = rest$1;\r\n      parseEndTag(stackedTag, index - endTagLength, index);\r\n    }\r\n\r\n    if (html === last) {\r\n      options.chars && options.chars(html);\r\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\r\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\r\n      }\r\n      break\r\n    }\r\n  }\r\n\r\n  // Clean up any remaining tags\r\n  parseEndTag();\r\n\r\n  function advance (n) {\r\n    index += n;\r\n    html = html.substring(n);\r\n  }\r\n\r\n  function parseStartTag () {\r\n    var start = html.match(startTagOpen);\r\n    if (start) {\r\n      var match = {\r\n        tagName: start[1],\r\n        attrs: [],\r\n        start: index\r\n      };\r\n      advance(start[0].length);\r\n      var end, attr;\r\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\r\n        advance(attr[0].length);\r\n        match.attrs.push(attr);\r\n      }\r\n      if (end) {\r\n        match.unarySlash = end[1];\r\n        advance(end[0].length);\r\n        match.end = index;\r\n        return match\r\n      }\r\n    }\r\n  }\r\n\r\n  function handleStartTag (match) {\r\n    var tagName = match.tagName;\r\n    var unarySlash = match.unarySlash;\r\n\r\n    if (expectHTML) {\r\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\r\n        parseEndTag(lastTag);\r\n      }\r\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\r\n        parseEndTag(tagName);\r\n      }\r\n    }\r\n\r\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\r\n\r\n    var l = match.attrs.length;\r\n    var attrs = new Array(l);\r\n    for (var i = 0; i < l; i++) {\r\n      var args = match.attrs[i];\r\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\r\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\r\n        if (args[3] === '') { delete args[3]; }\r\n        if (args[4] === '') { delete args[4]; }\r\n        if (args[5] === '') { delete args[5]; }\r\n      }\r\n      var value = args[3] || args[4] || args[5] || '';\r\n      attrs[i] = {\r\n        name: args[1],\r\n        value: decodeAttr(\r\n          value,\r\n          options.shouldDecodeNewlines\r\n        )\r\n      };\r\n    }\r\n\r\n    if (!unary) {\r\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\r\n      lastTag = tagName;\r\n    }\r\n\r\n    if (options.start) {\r\n      options.start(tagName, attrs, unary, match.start, match.end);\r\n    }\r\n  }\r\n\r\n  function parseEndTag (tagName, start, end) {\r\n    var pos, lowerCasedTagName;\r\n    if (start == null) { start = index; }\r\n    if (end == null) { end = index; }\r\n\r\n    if (tagName) {\r\n      lowerCasedTagName = tagName.toLowerCase();\r\n    }\r\n\r\n    // Find the closest opened tag of the same type\r\n    if (tagName) {\r\n      for (pos = stack.length - 1; pos >= 0; pos--) {\r\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\r\n          break\r\n        }\r\n      }\r\n    } else {\r\n      // If no tag name is provided, clean shop\r\n      pos = 0;\r\n    }\r\n\r\n    if (pos >= 0) {\r\n      // Close all the open elements, up the stack\r\n      for (var i = stack.length - 1; i >= pos; i--) {\r\n        if (process.env.NODE_ENV !== 'production' &&\r\n          (i > pos || !tagName) &&\r\n          options.warn\r\n        ) {\r\n          options.warn(\r\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\r\n          );\r\n        }\r\n        if (options.end) {\r\n          options.end(stack[i].tag, start, end);\r\n        }\r\n      }\r\n\r\n      // Remove the open elements from the stack\r\n      stack.length = pos;\r\n      lastTag = pos && stack[pos - 1].tag;\r\n    } else if (lowerCasedTagName === 'br') {\r\n      if (options.start) {\r\n        options.start(tagName, [], true, start, end);\r\n      }\r\n    } else if (lowerCasedTagName === 'p') {\r\n      if (options.start) {\r\n        options.start(tagName, [], false, start, end);\r\n      }\r\n      if (options.end) {\r\n        options.end(tagName, start, end);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar onRE = /^@|^v-on:/;\r\nvar dirRE = /^v-|^@|^:/;\r\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\r\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\r\n\r\nvar argRE = /:(.*)$/;\r\nvar bindRE = /^:|^v-bind:/;\r\nvar modifierRE = /\\.[^.]+/g;\r\n\r\nvar decodeHTMLCached = cached(he.decode);\r\n\r\n// configurable state\r\nvar warn$2;\r\nvar delimiters;\r\nvar transforms;\r\nvar preTransforms;\r\nvar postTransforms;\r\nvar platformIsPreTag;\r\nvar platformMustUseProp;\r\nvar platformGetTagNamespace;\r\n\r\n/**\r\n * Convert HTML string to AST.\r\n */\r\nfunction parse (\r\n  template,\r\n  options\r\n) {\r\n  warn$2 = options.warn || baseWarn;\r\n\r\n  platformIsPreTag = options.isPreTag || no;\r\n  platformMustUseProp = options.mustUseProp || no;\r\n  platformGetTagNamespace = options.getTagNamespace || no;\r\n\r\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\r\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\r\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\r\n\r\n  delimiters = options.delimiters;\r\n\r\n  var stack = [];\r\n  var preserveWhitespace = options.preserveWhitespace !== false;\r\n  var root;\r\n  var currentParent;\r\n  var inVPre = false;\r\n  var inPre = false;\r\n  var warned = false;\r\n\r\n  function warnOnce (msg) {\r\n    if (!warned) {\r\n      warned = true;\r\n      warn$2(msg);\r\n    }\r\n  }\r\n\r\n  function endPre (element) {\r\n    // check pre state\r\n    if (element.pre) {\r\n      inVPre = false;\r\n    }\r\n    if (platformIsPreTag(element.tag)) {\r\n      inPre = false;\r\n    }\r\n  }\r\n\r\n  parseHTML(template, {\r\n    warn: warn$2,\r\n    expectHTML: options.expectHTML,\r\n    isUnaryTag: options.isUnaryTag,\r\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\r\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\r\n    shouldKeepComment: options.comments,\r\n    start: function start (tag, attrs, unary) {\r\n      // check namespace.\r\n      // inherit parent ns if there is one\r\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\r\n\r\n      // handle IE svg bug\r\n      /* istanbul ignore if */\r\n      if (isIE && ns === 'svg') {\r\n        attrs = guardIESVGBug(attrs);\r\n      }\r\n\r\n      var element = {\r\n        type: 1,\r\n        tag: tag,\r\n        attrsList: attrs,\r\n        attrsMap: makeAttrsMap(attrs),\r\n        parent: currentParent,\r\n        children: []\r\n      };\r\n      if (ns) {\r\n        element.ns = ns;\r\n      }\r\n\r\n      if (isForbiddenTag(element) && !isServerRendering()) {\r\n        element.forbidden = true;\r\n        process.env.NODE_ENV !== 'production' && warn$2(\r\n          'Templates should only be responsible for mapping the state to the ' +\r\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\r\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\r\n        );\r\n      }\r\n\r\n      // apply pre-transforms\r\n      for (var i = 0; i < preTransforms.length; i++) {\r\n        preTransforms[i](element, options);\r\n      }\r\n\r\n      if (!inVPre) {\r\n        processPre(element);\r\n        if (element.pre) {\r\n          inVPre = true;\r\n        }\r\n      }\r\n      if (platformIsPreTag(element.tag)) {\r\n        inPre = true;\r\n      }\r\n      if (inVPre) {\r\n        processRawAttrs(element);\r\n      } else {\r\n        processFor(element);\r\n        processIf(element);\r\n        processOnce(element);\r\n        processKey(element);\r\n\r\n        // determine whether this is a plain element after\r\n        // removing structural attributes\r\n        element.plain = !element.key && !attrs.length;\r\n\r\n        processRef(element);\r\n        processSlot(element);\r\n        processComponent(element);\r\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\r\n          transforms[i$1](element, options);\r\n        }\r\n        processAttrs(element);\r\n      }\r\n\r\n      function checkRootConstraints (el) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          if (el.tag === 'slot' || el.tag === 'template') {\r\n            warnOnce(\r\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\r\n              'contain multiple nodes.'\r\n            );\r\n          }\r\n          if (el.attrsMap.hasOwnProperty('v-for')) {\r\n            warnOnce(\r\n              'Cannot use v-for on stateful component root element because ' +\r\n              'it renders multiple elements.'\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // tree management\r\n      if (!root) {\r\n        root = element;\r\n        checkRootConstraints(root);\r\n      } else if (!stack.length) {\r\n        // allow root elements with v-if, v-else-if and v-else\r\n        if (root.if && (element.elseif || element.else)) {\r\n          checkRootConstraints(element);\r\n          addIfCondition(root, {\r\n            exp: element.elseif,\r\n            block: element\r\n          });\r\n        } else if (process.env.NODE_ENV !== 'production') {\r\n          warnOnce(\r\n            \"Component template should contain exactly one root element. \" +\r\n            \"If you are using v-if on multiple elements, \" +\r\n            \"use v-else-if to chain them instead.\"\r\n          );\r\n        }\r\n      }\r\n      if (currentParent && !element.forbidden) {\r\n        if (element.elseif || element.else) {\r\n          processIfConditions(element, currentParent);\r\n        } else if (element.slotScope) { // scoped slot\r\n          currentParent.plain = false;\r\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\r\n        } else {\r\n          currentParent.children.push(element);\r\n          element.parent = currentParent;\r\n        }\r\n      }\r\n      if (!unary) {\r\n        currentParent = element;\r\n        stack.push(element);\r\n      } else {\r\n        endPre(element);\r\n      }\r\n      // apply post-transforms\r\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\r\n        postTransforms[i$2](element, options);\r\n      }\r\n    },\r\n\r\n    end: function end () {\r\n      // remove trailing whitespace\r\n      var element = stack[stack.length - 1];\r\n      var lastNode = element.children[element.children.length - 1];\r\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\r\n        element.children.pop();\r\n      }\r\n      // pop stack\r\n      stack.length -= 1;\r\n      currentParent = stack[stack.length - 1];\r\n      endPre(element);\r\n    },\r\n\r\n    chars: function chars (text) {\r\n      if (!currentParent) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          if (text === template) {\r\n            warnOnce(\r\n              'Component template requires a root element, rather than just text.'\r\n            );\r\n          } else if ((text = text.trim())) {\r\n            warnOnce(\r\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\r\n            );\r\n          }\r\n        }\r\n        return\r\n      }\r\n      // IE textarea placeholder bug\r\n      /* istanbul ignore if */\r\n      if (isIE &&\r\n        currentParent.tag === 'textarea' &&\r\n        currentParent.attrsMap.placeholder === text\r\n      ) {\r\n        return\r\n      }\r\n      var children = currentParent.children;\r\n      text = inPre || text.trim()\r\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\r\n        // only preserve whitespace if its not right after a starting tag\r\n        : preserveWhitespace && children.length ? ' ' : '';\r\n      if (text) {\r\n        var expression;\r\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\r\n          children.push({\r\n            type: 2,\r\n            expression: expression,\r\n            text: text\r\n          });\r\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\r\n          children.push({\r\n            type: 3,\r\n            text: text\r\n          });\r\n        }\r\n      }\r\n    },\r\n    comment: function comment (text) {\r\n      currentParent.children.push({\r\n        type: 3,\r\n        text: text,\r\n        isComment: true\r\n      });\r\n    }\r\n  });\r\n  return root\r\n}\r\n\r\nfunction processPre (el) {\r\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\r\n    el.pre = true;\r\n  }\r\n}\r\n\r\nfunction processRawAttrs (el) {\r\n  var l = el.attrsList.length;\r\n  if (l) {\r\n    var attrs = el.attrs = new Array(l);\r\n    for (var i = 0; i < l; i++) {\r\n      attrs[i] = {\r\n        name: el.attrsList[i].name,\r\n        value: JSON.stringify(el.attrsList[i].value)\r\n      };\r\n    }\r\n  } else if (!el.pre) {\r\n    // non root node in pre blocks with no attributes\r\n    el.plain = true;\r\n  }\r\n}\r\n\r\nfunction processKey (el) {\r\n  var exp = getBindingAttr(el, 'key');\r\n  if (exp) {\r\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\r\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\r\n    }\r\n    el.key = exp;\r\n  }\r\n}\r\n\r\nfunction processRef (el) {\r\n  var ref = getBindingAttr(el, 'ref');\r\n  if (ref) {\r\n    el.ref = ref;\r\n    el.refInFor = checkInFor(el);\r\n  }\r\n}\r\n\r\nfunction processFor (el) {\r\n  var exp;\r\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\r\n    var inMatch = exp.match(forAliasRE);\r\n    if (!inMatch) {\r\n      process.env.NODE_ENV !== 'production' && warn$2(\r\n        (\"Invalid v-for expression: \" + exp)\r\n      );\r\n      return\r\n    }\r\n    el.for = inMatch[2].trim();\r\n    var alias = inMatch[1].trim();\r\n    var iteratorMatch = alias.match(forIteratorRE);\r\n    if (iteratorMatch) {\r\n      el.alias = iteratorMatch[1].trim();\r\n      el.iterator1 = iteratorMatch[2].trim();\r\n      if (iteratorMatch[3]) {\r\n        el.iterator2 = iteratorMatch[3].trim();\r\n      }\r\n    } else {\r\n      el.alias = alias;\r\n    }\r\n  }\r\n}\r\n\r\nfunction processIf (el) {\r\n  var exp = getAndRemoveAttr(el, 'v-if');\r\n  if (exp) {\r\n    el.if = exp;\r\n    addIfCondition(el, {\r\n      exp: exp,\r\n      block: el\r\n    });\r\n  } else {\r\n    if (getAndRemoveAttr(el, 'v-else') != null) {\r\n      el.else = true;\r\n    }\r\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\r\n    if (elseif) {\r\n      el.elseif = elseif;\r\n    }\r\n  }\r\n}\r\n\r\nfunction processIfConditions (el, parent) {\r\n  var prev = findPrevElement(parent.children);\r\n  if (prev && prev.if) {\r\n    addIfCondition(prev, {\r\n      exp: el.elseif,\r\n      block: el\r\n    });\r\n  } else if (process.env.NODE_ENV !== 'production') {\r\n    warn$2(\r\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\r\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\r\n    );\r\n  }\r\n}\r\n\r\nfunction findPrevElement (children) {\r\n  var i = children.length;\r\n  while (i--) {\r\n    if (children[i].type === 1) {\r\n      return children[i]\r\n    } else {\r\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\r\n        warn$2(\r\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\r\n          \"will be ignored.\"\r\n        );\r\n      }\r\n      children.pop();\r\n    }\r\n  }\r\n}\r\n\r\nfunction addIfCondition (el, condition) {\r\n  if (!el.ifConditions) {\r\n    el.ifConditions = [];\r\n  }\r\n  el.ifConditions.push(condition);\r\n}\r\n\r\nfunction processOnce (el) {\r\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\r\n  if (once$$1 != null) {\r\n    el.once = true;\r\n  }\r\n}\r\n\r\nfunction processSlot (el) {\r\n  if (el.tag === 'slot') {\r\n    el.slotName = getBindingAttr(el, 'name');\r\n    if (process.env.NODE_ENV !== 'production' && el.key) {\r\n      warn$2(\r\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\r\n        \"and can possibly expand into multiple elements. \" +\r\n        \"Use the key on a wrapping element instead.\"\r\n      );\r\n    }\r\n  } else {\r\n    var slotTarget = getBindingAttr(el, 'slot');\r\n    if (slotTarget) {\r\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\r\n      // preserve slot as an attribute for native shadow DOM compat\r\n      addAttr(el, 'slot', slotTarget);\r\n    }\r\n    if (el.tag === 'template') {\r\n      el.slotScope = getAndRemoveAttr(el, 'scope');\r\n    }\r\n  }\r\n}\r\n\r\nfunction processComponent (el) {\r\n  var binding;\r\n  if ((binding = getBindingAttr(el, 'is'))) {\r\n    el.component = binding;\r\n  }\r\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\r\n    el.inlineTemplate = true;\r\n  }\r\n}\r\n\r\nfunction processAttrs (el) {\r\n  var list = el.attrsList;\r\n  var i, l, name, rawName, value, modifiers, isProp;\r\n  for (i = 0, l = list.length; i < l; i++) {\r\n    name = rawName = list[i].name;\r\n    value = list[i].value;\r\n    if (dirRE.test(name)) {\r\n      // mark element as dynamic\r\n      el.hasBindings = true;\r\n      // modifiers\r\n      modifiers = parseModifiers(name);\r\n      if (modifiers) {\r\n        name = name.replace(modifierRE, '');\r\n      }\r\n      if (bindRE.test(name)) { // v-bind\r\n        name = name.replace(bindRE, '');\r\n        value = parseFilters(value);\r\n        isProp = false;\r\n        if (modifiers) {\r\n          if (modifiers.prop) {\r\n            isProp = true;\r\n            name = camelize(name);\r\n            if (name === 'innerHtml') { name = 'innerHTML'; }\r\n          }\r\n          if (modifiers.camel) {\r\n            name = camelize(name);\r\n          }\r\n          if (modifiers.sync) {\r\n            addHandler(\r\n              el,\r\n              (\"update:\" + (camelize(name))),\r\n              genAssignmentCode(value, \"$event\")\r\n            );\r\n          }\r\n        }\r\n        if (isProp || (\r\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\r\n        )) {\r\n          addProp(el, name, value);\r\n        } else {\r\n          addAttr(el, name, value);\r\n        }\r\n      } else if (onRE.test(name)) { // v-on\r\n        name = name.replace(onRE, '');\r\n        addHandler(el, name, value, modifiers, false, warn$2);\r\n      } else { // normal directives\r\n        name = name.replace(dirRE, '');\r\n        // parse arg\r\n        var argMatch = name.match(argRE);\r\n        var arg = argMatch && argMatch[1];\r\n        if (arg) {\r\n          name = name.slice(0, -(arg.length + 1));\r\n        }\r\n        addDirective(el, name, rawName, value, arg, modifiers);\r\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\r\n          checkForAliasModel(el, value);\r\n        }\r\n      }\r\n    } else {\r\n      // literal attribute\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        var expression = parseText(value, delimiters);\r\n        if (expression) {\r\n          warn$2(\r\n            name + \"=\\\"\" + value + \"\\\": \" +\r\n            'Interpolation inside attributes has been removed. ' +\r\n            'Use v-bind or the colon shorthand instead. For example, ' +\r\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\r\n          );\r\n        }\r\n      }\r\n      addAttr(el, name, JSON.stringify(value));\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkInFor (el) {\r\n  var parent = el;\r\n  while (parent) {\r\n    if (parent.for !== undefined) {\r\n      return true\r\n    }\r\n    parent = parent.parent;\r\n  }\r\n  return false\r\n}\r\n\r\nfunction parseModifiers (name) {\r\n  var match = name.match(modifierRE);\r\n  if (match) {\r\n    var ret = {};\r\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\r\n    return ret\r\n  }\r\n}\r\n\r\nfunction makeAttrsMap (attrs) {\r\n  var map = {};\r\n  for (var i = 0, l = attrs.length; i < l; i++) {\r\n    if (\r\n      process.env.NODE_ENV !== 'production' &&\r\n      map[attrs[i].name] && !isIE && !isEdge\r\n    ) {\r\n      warn$2('duplicate attribute: ' + attrs[i].name);\r\n    }\r\n    map[attrs[i].name] = attrs[i].value;\r\n  }\r\n  return map\r\n}\r\n\r\n// for script (e.g. type=\"x/template\") or style, do not decode content\r\nfunction isTextTag (el) {\r\n  return el.tag === 'script' || el.tag === 'style'\r\n}\r\n\r\nfunction isForbiddenTag (el) {\r\n  return (\r\n    el.tag === 'style' ||\r\n    (el.tag === 'script' && (\r\n      !el.attrsMap.type ||\r\n      el.attrsMap.type === 'text/javascript'\r\n    ))\r\n  )\r\n}\r\n\r\nvar ieNSBug = /^xmlns:NS\\d+/;\r\nvar ieNSPrefix = /^NS\\d+:/;\r\n\r\n/* istanbul ignore next */\r\nfunction guardIESVGBug (attrs) {\r\n  var res = [];\r\n  for (var i = 0; i < attrs.length; i++) {\r\n    var attr = attrs[i];\r\n    if (!ieNSBug.test(attr.name)) {\r\n      attr.name = attr.name.replace(ieNSPrefix, '');\r\n      res.push(attr);\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nfunction checkForAliasModel (el, value) {\r\n  var _el = el;\r\n  while (_el) {\r\n    if (_el.for && _el.alias === value) {\r\n      warn$2(\r\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\r\n        \"You are binding v-model directly to a v-for iteration alias. \" +\r\n        \"This will not be able to modify the v-for source array because \" +\r\n        \"writing to the alias is like modifying a function local variable. \" +\r\n        \"Consider using an array of objects and use v-model on an object property instead.\"\r\n      );\r\n    }\r\n    _el = _el.parent;\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar isStaticKey;\r\nvar isPlatformReservedTag;\r\n\r\nvar genStaticKeysCached = cached(genStaticKeys$1);\r\n\r\n/**\r\n * Goal of the optimizer: walk the generated template AST tree\r\n * and detect sub-trees that are purely static, i.e. parts of\r\n * the DOM that never needs to change.\r\n *\r\n * Once we detect these sub-trees, we can:\r\n *\r\n * 1. Hoist them into constants, so that we no longer need to\r\n *    create fresh nodes for them on each re-render;\r\n * 2. Completely skip them in the patching process.\r\n */\r\nfunction optimize (root, options) {\r\n  if (!root) { return }\r\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\r\n  isPlatformReservedTag = options.isReservedTag || no;\r\n  // first pass: mark all non-static nodes.\r\n  markStatic$1(root);\r\n  // second pass: mark static roots.\r\n  markStaticRoots(root, false);\r\n}\r\n\r\nfunction genStaticKeys$1 (keys) {\r\n  return makeMap(\r\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\r\n    (keys ? ',' + keys : '')\r\n  )\r\n}\r\n\r\nfunction markStatic$1 (node) {\r\n  node.static = isStatic(node);\r\n  if (node.type === 1) {\r\n    // do not make component slot content static. this avoids\r\n    // 1. components not able to mutate slot nodes\r\n    // 2. static slot content fails for hot-reloading\r\n    if (\r\n      !isPlatformReservedTag(node.tag) &&\r\n      node.tag !== 'slot' &&\r\n      node.attrsMap['inline-template'] == null\r\n    ) {\r\n      return\r\n    }\r\n    for (var i = 0, l = node.children.length; i < l; i++) {\r\n      var child = node.children[i];\r\n      markStatic$1(child);\r\n      if (!child.static) {\r\n        node.static = false;\r\n      }\r\n    }\r\n    if (node.ifConditions) {\r\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\r\n        var block = node.ifConditions[i$1].block;\r\n        markStatic$1(block);\r\n        if (!block.static) {\r\n          node.static = false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction markStaticRoots (node, isInFor) {\r\n  if (node.type === 1) {\r\n    if (node.static || node.once) {\r\n      node.staticInFor = isInFor;\r\n    }\r\n    // For a node to qualify as a static root, it should have children that\r\n    // are not just static text. Otherwise the cost of hoisting out will\r\n    // outweigh the benefits and it's better off to just always render it fresh.\r\n    if (node.static && node.children.length && !(\r\n      node.children.length === 1 &&\r\n      node.children[0].type === 3\r\n    )) {\r\n      node.staticRoot = true;\r\n      return\r\n    } else {\r\n      node.staticRoot = false;\r\n    }\r\n    if (node.children) {\r\n      for (var i = 0, l = node.children.length; i < l; i++) {\r\n        markStaticRoots(node.children[i], isInFor || !!node.for);\r\n      }\r\n    }\r\n    if (node.ifConditions) {\r\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\r\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction isStatic (node) {\r\n  if (node.type === 2) { // expression\r\n    return false\r\n  }\r\n  if (node.type === 3) { // text\r\n    return true\r\n  }\r\n  return !!(node.pre || (\r\n    !node.hasBindings && // no dynamic bindings\r\n    !node.if && !node.for && // not v-if or v-for or v-else\r\n    !isBuiltInTag(node.tag) && // not a built-in\r\n    isPlatformReservedTag(node.tag) && // not a component\r\n    !isDirectChildOfTemplateFor(node) &&\r\n    Object.keys(node).every(isStaticKey)\r\n  ))\r\n}\r\n\r\nfunction isDirectChildOfTemplateFor (node) {\r\n  while (node.parent) {\r\n    node = node.parent;\r\n    if (node.tag !== 'template') {\r\n      return false\r\n    }\r\n    if (node.for) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/*  */\r\n\r\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\r\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\r\n\r\n// keyCode aliases\r\nvar keyCodes = {\r\n  esc: 27,\r\n  tab: 9,\r\n  enter: 13,\r\n  space: 32,\r\n  up: 38,\r\n  left: 37,\r\n  right: 39,\r\n  down: 40,\r\n  'delete': [8, 46]\r\n};\r\n\r\n// #4868: modifiers that prevent the execution of the listener\r\n// need to explicitly return null so that we can determine whether to remove\r\n// the listener for .once\r\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\r\n\r\nvar modifierCode = {\r\n  stop: '$event.stopPropagation();',\r\n  prevent: '$event.preventDefault();',\r\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\r\n  ctrl: genGuard(\"!$event.ctrlKey\"),\r\n  shift: genGuard(\"!$event.shiftKey\"),\r\n  alt: genGuard(\"!$event.altKey\"),\r\n  meta: genGuard(\"!$event.metaKey\"),\r\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\r\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\r\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\r\n};\r\n\r\nfunction genHandlers (\r\n  events,\r\n  isNative,\r\n  warn\r\n) {\r\n  var res = isNative ? 'nativeOn:{' : 'on:{';\r\n  for (var name in events) {\r\n    var handler = events[name];\r\n    // #5330: warn click.right, since right clicks do not actually fire click events.\r\n    if (process.env.NODE_ENV !== 'production' &&\r\n      name === 'click' &&\r\n      handler && handler.modifiers && handler.modifiers.right\r\n    ) {\r\n      warn(\r\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\r\n        \"do not actually fire \\\"click\\\" events.\"\r\n      );\r\n    }\r\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\r\n  }\r\n  return res.slice(0, -1) + '}'\r\n}\r\n\r\nfunction genHandler (\r\n  name,\r\n  handler\r\n) {\r\n  if (!handler) {\r\n    return 'function(){}'\r\n  }\r\n\r\n  if (Array.isArray(handler)) {\r\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\r\n  }\r\n\r\n  var isMethodPath = simplePathRE.test(handler.value);\r\n  var isFunctionExpression = fnExpRE.test(handler.value);\r\n\r\n  if (!handler.modifiers) {\r\n    return isMethodPath || isFunctionExpression\r\n      ? handler.value\r\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\r\n  } else {\r\n    var code = '';\r\n    var genModifierCode = '';\r\n    var keys = [];\r\n    for (var key in handler.modifiers) {\r\n      if (modifierCode[key]) {\r\n        genModifierCode += modifierCode[key];\r\n        // left/right\r\n        if (keyCodes[key]) {\r\n          keys.push(key);\r\n        }\r\n      } else {\r\n        keys.push(key);\r\n      }\r\n    }\r\n    if (keys.length) {\r\n      code += genKeyFilter(keys);\r\n    }\r\n    // Make sure modifiers like prevent and stop get executed after key filtering\r\n    if (genModifierCode) {\r\n      code += genModifierCode;\r\n    }\r\n    var handlerCode = isMethodPath\r\n      ? handler.value + '($event)'\r\n      : isFunctionExpression\r\n        ? (\"(\" + (handler.value) + \")($event)\")\r\n        : handler.value;\r\n    return (\"function($event){\" + code + handlerCode + \"}\")\r\n  }\r\n}\r\n\r\nfunction genKeyFilter (keys) {\r\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\r\n}\r\n\r\nfunction genFilterCode (key) {\r\n  var keyVal = parseInt(key, 10);\r\n  if (keyVal) {\r\n    return (\"$event.keyCode!==\" + keyVal)\r\n  }\r\n  var alias = keyCodes[key];\r\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\r\n}\r\n\r\n/*  */\r\n\r\nfunction on (el, dir) {\r\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\r\n    warn(\"v-on without argument does not support modifiers.\");\r\n  }\r\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\r\n}\r\n\r\n/*  */\r\n\r\nfunction bind$1 (el, dir) {\r\n  el.wrapData = function (code) {\r\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\r\n  };\r\n}\r\n\r\n/*  */\r\n\r\nvar baseDirectives = {\r\n  on: on,\r\n  bind: bind$1,\r\n  cloak: noop\r\n};\r\n\r\n/*  */\r\n\r\nvar CodegenState = function CodegenState (options) {\r\n  this.options = options;\r\n  this.warn = options.warn || baseWarn;\r\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\r\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\r\n  this.directives = extend(extend({}, baseDirectives), options.directives);\r\n  var isReservedTag = options.isReservedTag || no;\r\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\r\n  this.onceId = 0;\r\n  this.staticRenderFns = [];\r\n};\r\n\r\n\r\n\r\nfunction generate (\r\n  ast,\r\n  options\r\n) {\r\n  var state = new CodegenState(options);\r\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\r\n  return {\r\n    render: (\"with(this){return \" + code + \"}\"),\r\n    staticRenderFns: state.staticRenderFns\r\n  }\r\n}\r\n\r\nfunction genElement (el, state) {\r\n  if (el.staticRoot && !el.staticProcessed) {\r\n    return genStatic(el, state)\r\n  } else if (el.once && !el.onceProcessed) {\r\n    return genOnce(el, state)\r\n  } else if (el.for && !el.forProcessed) {\r\n    return genFor(el, state)\r\n  } else if (el.if && !el.ifProcessed) {\r\n    return genIf(el, state)\r\n  } else if (el.tag === 'template' && !el.slotTarget) {\r\n    return genChildren(el, state) || 'void 0'\r\n  } else if (el.tag === 'slot') {\r\n    return genSlot(el, state)\r\n  } else {\r\n    // component or element\r\n    var code;\r\n    if (el.component) {\r\n      code = genComponent(el.component, el, state);\r\n    } else {\r\n      var data = el.plain ? undefined : genData$2(el, state);\r\n\r\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\r\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\r\n    }\r\n    // module transforms\r\n    for (var i = 0; i < state.transforms.length; i++) {\r\n      code = state.transforms[i](el, code);\r\n    }\r\n    return code\r\n  }\r\n}\r\n\r\n// hoist static sub-trees out\r\nfunction genStatic (el, state) {\r\n  el.staticProcessed = true;\r\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\r\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\r\n}\r\n\r\n// v-once\r\nfunction genOnce (el, state) {\r\n  el.onceProcessed = true;\r\n  if (el.if && !el.ifProcessed) {\r\n    return genIf(el, state)\r\n  } else if (el.staticInFor) {\r\n    var key = '';\r\n    var parent = el.parent;\r\n    while (parent) {\r\n      if (parent.for) {\r\n        key = parent.key;\r\n        break\r\n      }\r\n      parent = parent.parent;\r\n    }\r\n    if (!key) {\r\n      process.env.NODE_ENV !== 'production' && state.warn(\r\n        \"v-once can only be used inside v-for that is keyed. \"\r\n      );\r\n      return genElement(el, state)\r\n    }\r\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\r\n  } else {\r\n    return genStatic(el, state)\r\n  }\r\n}\r\n\r\nfunction genIf (\r\n  el,\r\n  state,\r\n  altGen,\r\n  altEmpty\r\n) {\r\n  el.ifProcessed = true; // avoid recursion\r\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\r\n}\r\n\r\nfunction genIfConditions (\r\n  conditions,\r\n  state,\r\n  altGen,\r\n  altEmpty\r\n) {\r\n  if (!conditions.length) {\r\n    return altEmpty || '_e()'\r\n  }\r\n\r\n  var condition = conditions.shift();\r\n  if (condition.exp) {\r\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\r\n  } else {\r\n    return (\"\" + (genTernaryExp(condition.block)))\r\n  }\r\n\r\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\r\n  function genTernaryExp (el) {\r\n    return altGen\r\n      ? altGen(el, state)\r\n      : el.once\r\n        ? genOnce(el, state)\r\n        : genElement(el, state)\r\n  }\r\n}\r\n\r\nfunction genFor (\r\n  el,\r\n  state,\r\n  altGen,\r\n  altHelper\r\n) {\r\n  var exp = el.for;\r\n  var alias = el.alias;\r\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\r\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\r\n\r\n  if (process.env.NODE_ENV !== 'production' &&\r\n    state.maybeComponent(el) &&\r\n    el.tag !== 'slot' &&\r\n    el.tag !== 'template' &&\r\n    !el.key\r\n  ) {\r\n    state.warn(\r\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\r\n      \"v-for should have explicit keys. \" +\r\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\r\n      true /* tip */\r\n    );\r\n  }\r\n\r\n  el.forProcessed = true; // avoid recursion\r\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\r\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\r\n      \"return \" + ((altGen || genElement)(el, state)) +\r\n    '})'\r\n}\r\n\r\nfunction genData$2 (el, state) {\r\n  var data = '{';\r\n\r\n  // directives first.\r\n  // directives may mutate the el's other properties before they are generated.\r\n  var dirs = genDirectives(el, state);\r\n  if (dirs) { data += dirs + ','; }\r\n\r\n  // key\r\n  if (el.key) {\r\n    data += \"key:\" + (el.key) + \",\";\r\n  }\r\n  // ref\r\n  if (el.ref) {\r\n    data += \"ref:\" + (el.ref) + \",\";\r\n  }\r\n  if (el.refInFor) {\r\n    data += \"refInFor:true,\";\r\n  }\r\n  // pre\r\n  if (el.pre) {\r\n    data += \"pre:true,\";\r\n  }\r\n  // record original tag name for components using \"is\" attribute\r\n  if (el.component) {\r\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\r\n  }\r\n  // module data generation functions\r\n  for (var i = 0; i < state.dataGenFns.length; i++) {\r\n    data += state.dataGenFns[i](el);\r\n  }\r\n  // attributes\r\n  if (el.attrs) {\r\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\r\n  }\r\n  // DOM props\r\n  if (el.props) {\r\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\r\n  }\r\n  // event handlers\r\n  if (el.events) {\r\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\r\n  }\r\n  if (el.nativeEvents) {\r\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\r\n  }\r\n  // slot target\r\n  if (el.slotTarget) {\r\n    data += \"slot:\" + (el.slotTarget) + \",\";\r\n  }\r\n  // scoped slots\r\n  if (el.scopedSlots) {\r\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\r\n  }\r\n  // component v-model\r\n  if (el.model) {\r\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\r\n  }\r\n  // inline-template\r\n  if (el.inlineTemplate) {\r\n    var inlineTemplate = genInlineTemplate(el, state);\r\n    if (inlineTemplate) {\r\n      data += inlineTemplate + \",\";\r\n    }\r\n  }\r\n  data = data.replace(/,$/, '') + '}';\r\n  // v-bind data wrap\r\n  if (el.wrapData) {\r\n    data = el.wrapData(data);\r\n  }\r\n  // v-on data wrap\r\n  if (el.wrapListeners) {\r\n    data = el.wrapListeners(data);\r\n  }\r\n  return data\r\n}\r\n\r\nfunction genDirectives (el, state) {\r\n  var dirs = el.directives;\r\n  if (!dirs) { return }\r\n  var res = 'directives:[';\r\n  var hasRuntime = false;\r\n  var i, l, dir, needRuntime;\r\n  for (i = 0, l = dirs.length; i < l; i++) {\r\n    dir = dirs[i];\r\n    needRuntime = true;\r\n    var gen = state.directives[dir.name];\r\n    if (gen) {\r\n      // compile-time directive that manipulates AST.\r\n      // returns true if it also needs a runtime counterpart.\r\n      needRuntime = !!gen(el, dir, state.warn);\r\n    }\r\n    if (needRuntime) {\r\n      hasRuntime = true;\r\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\r\n    }\r\n  }\r\n  if (hasRuntime) {\r\n    return res.slice(0, -1) + ']'\r\n  }\r\n}\r\n\r\nfunction genInlineTemplate (el, state) {\r\n  var ast = el.children[0];\r\n  if (process.env.NODE_ENV !== 'production' && (\r\n    el.children.length > 1 || ast.type !== 1\r\n  )) {\r\n    state.warn('Inline-template components must have exactly one child element.');\r\n  }\r\n  if (ast.type === 1) {\r\n    var inlineRenderFns = generate(ast, state.options);\r\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\r\n  }\r\n}\r\n\r\nfunction genScopedSlots (\r\n  slots,\r\n  state\r\n) {\r\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\r\n      return genScopedSlot(key, slots[key], state)\r\n    }).join(',')) + \"])\")\r\n}\r\n\r\nfunction genScopedSlot (\r\n  key,\r\n  el,\r\n  state\r\n) {\r\n  if (el.for && !el.forProcessed) {\r\n    return genForScopedSlot(key, el, state)\r\n  }\r\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\r\n    \"return \" + (el.tag === 'template'\r\n      ? genChildren(el, state) || 'void 0'\r\n      : genElement(el, state)) + \"}}\"\r\n}\r\n\r\nfunction genForScopedSlot (\r\n  key,\r\n  el,\r\n  state\r\n) {\r\n  var exp = el.for;\r\n  var alias = el.alias;\r\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\r\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\r\n  el.forProcessed = true; // avoid recursion\r\n  return \"_l((\" + exp + \"),\" +\r\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\r\n      \"return \" + (genScopedSlot(key, el, state)) +\r\n    '})'\r\n}\r\n\r\nfunction genChildren (\r\n  el,\r\n  state,\r\n  checkSkip,\r\n  altGenElement,\r\n  altGenNode\r\n) {\r\n  var children = el.children;\r\n  if (children.length) {\r\n    var el$1 = children[0];\r\n    // optimize single v-for\r\n    if (children.length === 1 &&\r\n      el$1.for &&\r\n      el$1.tag !== 'template' &&\r\n      el$1.tag !== 'slot'\r\n    ) {\r\n      return (altGenElement || genElement)(el$1, state)\r\n    }\r\n    var normalizationType = checkSkip\r\n      ? getNormalizationType(children, state.maybeComponent)\r\n      : 0;\r\n    var gen = altGenNode || genNode;\r\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\r\n  }\r\n}\r\n\r\n// determine the normalization needed for the children array.\r\n// 0: no normalization needed\r\n// 1: simple normalization needed (possible 1-level deep nested array)\r\n// 2: full normalization needed\r\nfunction getNormalizationType (\r\n  children,\r\n  maybeComponent\r\n) {\r\n  var res = 0;\r\n  for (var i = 0; i < children.length; i++) {\r\n    var el = children[i];\r\n    if (el.type !== 1) {\r\n      continue\r\n    }\r\n    if (needsNormalization(el) ||\r\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\r\n      res = 2;\r\n      break\r\n    }\r\n    if (maybeComponent(el) ||\r\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\r\n      res = 1;\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nfunction needsNormalization (el) {\r\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\r\n}\r\n\r\nfunction genNode (node, state) {\r\n  if (node.type === 1) {\r\n    return genElement(node, state)\r\n  } if (node.type === 3 && node.isComment) {\r\n    return genComment(node)\r\n  } else {\r\n    return genText(node)\r\n  }\r\n}\r\n\r\nfunction genText (text) {\r\n  return (\"_v(\" + (text.type === 2\r\n    ? text.expression // no need for () because already wrapped in _s()\r\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\r\n}\r\n\r\nfunction genComment (comment) {\r\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\r\n}\r\n\r\nfunction genSlot (el, state) {\r\n  var slotName = el.slotName || '\"default\"';\r\n  var children = genChildren(el, state);\r\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\r\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\r\n  var bind$$1 = el.attrsMap['v-bind'];\r\n  if ((attrs || bind$$1) && !children) {\r\n    res += \",null\";\r\n  }\r\n  if (attrs) {\r\n    res += \",\" + attrs;\r\n  }\r\n  if (bind$$1) {\r\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\r\n  }\r\n  return res + ')'\r\n}\r\n\r\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\r\nfunction genComponent (\r\n  componentName,\r\n  el,\r\n  state\r\n) {\r\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\r\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\r\n}\r\n\r\nfunction genProps (props) {\r\n  var res = '';\r\n  for (var i = 0; i < props.length; i++) {\r\n    var prop = props[i];\r\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\r\n  }\r\n  return res.slice(0, -1)\r\n}\r\n\r\n// #3895, #4268\r\nfunction transformSpecialNewlines (text) {\r\n  return text\r\n    .replace(/\\u2028/g, '\\\\u2028')\r\n    .replace(/\\u2029/g, '\\\\u2029')\r\n}\r\n\r\n/*  */\r\n\r\n// these keywords should not appear inside expressions, but operators like\r\n// typeof, instanceof and in are allowed\r\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\r\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\r\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\r\n  'extends,finally,continue,debugger,function,arguments'\r\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\r\n\r\n// these unary operators should not be used as property/method names\r\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\r\n  'delete,typeof,void'\r\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\r\n\r\n// check valid identifier for v-for\r\nvar identRE = /[A-Za-z_$][\\w$]*/;\r\n\r\n// strip strings in expressions\r\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\r\n\r\n// detect problematic expressions in a template\r\nfunction detectErrors (ast) {\r\n  var errors = [];\r\n  if (ast) {\r\n    checkNode(ast, errors);\r\n  }\r\n  return errors\r\n}\r\n\r\nfunction checkNode (node, errors) {\r\n  if (node.type === 1) {\r\n    for (var name in node.attrsMap) {\r\n      if (dirRE.test(name)) {\r\n        var value = node.attrsMap[name];\r\n        if (value) {\r\n          if (name === 'v-for') {\r\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\r\n          } else if (onRE.test(name)) {\r\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\r\n          } else {\r\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (node.children) {\r\n      for (var i = 0; i < node.children.length; i++) {\r\n        checkNode(node.children[i], errors);\r\n      }\r\n    }\r\n  } else if (node.type === 2) {\r\n    checkExpression(node.expression, node.text, errors);\r\n  }\r\n}\r\n\r\nfunction checkEvent (exp, text, errors) {\r\n  var stipped = exp.replace(stripStringRE, '');\r\n  var keywordMatch = stipped.match(unaryOperatorsRE);\r\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\r\n    errors.push(\r\n      \"avoid using JavaScript unary operator as property name: \" +\r\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\r\n    );\r\n  }\r\n  checkExpression(exp, text, errors);\r\n}\r\n\r\nfunction checkFor (node, text, errors) {\r\n  checkExpression(node.for || '', text, errors);\r\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\r\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\r\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\r\n}\r\n\r\nfunction checkIdentifier (ident, type, text, errors) {\r\n  if (typeof ident === 'string' && !identRE.test(ident)) {\r\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\r\n  }\r\n}\r\n\r\nfunction checkExpression (exp, text, errors) {\r\n  try {\r\n    new Function((\"return \" + exp));\r\n  } catch (e) {\r\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\r\n    if (keywordMatch) {\r\n      errors.push(\r\n        \"avoid using JavaScript keyword as property name: \" +\r\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\r\n      );\r\n    } else {\r\n      errors.push((\"invalid expression: \" + (text.trim())));\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction createFunction (code, errors) {\r\n  try {\r\n    return new Function(code)\r\n  } catch (err) {\r\n    errors.push({ err: err, code: code });\r\n    return noop\r\n  }\r\n}\r\n\r\nfunction createCompileToFunctionFn (compile) {\r\n  var cache = Object.create(null);\r\n\r\n  return function compileToFunctions (\r\n    template,\r\n    options,\r\n    vm\r\n  ) {\r\n    options = options || {};\r\n\r\n    /* istanbul ignore if */\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // detect possible CSP restriction\r\n      try {\r\n        new Function('return 1');\r\n      } catch (e) {\r\n        if (e.toString().match(/unsafe-eval|CSP/)) {\r\n          warn(\r\n            'It seems you are using the standalone build of Vue.js in an ' +\r\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\r\n            'The template compiler cannot work in this environment. Consider ' +\r\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\r\n            'templates into render functions.'\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // check cache\r\n    var key = options.delimiters\r\n      ? String(options.delimiters) + template\r\n      : template;\r\n    if (cache[key]) {\r\n      return cache[key]\r\n    }\r\n\r\n    // compile\r\n    var compiled = compile(template, options);\r\n\r\n    // check compilation errors/tips\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (compiled.errors && compiled.errors.length) {\r\n        warn(\r\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\r\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\r\n          vm\r\n        );\r\n      }\r\n      if (compiled.tips && compiled.tips.length) {\r\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\r\n      }\r\n    }\r\n\r\n    // turn code into functions\r\n    var res = {};\r\n    var fnGenErrors = [];\r\n    res.render = createFunction(compiled.render, fnGenErrors);\r\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\r\n      return createFunction(code, fnGenErrors)\r\n    });\r\n\r\n    // check function generation errors.\r\n    // this should only happen if there is a bug in the compiler itself.\r\n    // mostly for codegen development use\r\n    /* istanbul ignore if */\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\r\n        warn(\r\n          \"Failed to generate render function:\\n\\n\" +\r\n          fnGenErrors.map(function (ref) {\r\n            var err = ref.err;\r\n            var code = ref.code;\r\n\r\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\r\n        }).join('\\n'),\r\n          vm\r\n        );\r\n      }\r\n    }\r\n\r\n    return (cache[key] = res)\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction createCompilerCreator (baseCompile) {\r\n  return function createCompiler (baseOptions) {\r\n    function compile (\r\n      template,\r\n      options\r\n    ) {\r\n      var finalOptions = Object.create(baseOptions);\r\n      var errors = [];\r\n      var tips = [];\r\n      finalOptions.warn = function (msg, tip) {\r\n        (tip ? tips : errors).push(msg);\r\n      };\r\n\r\n      if (options) {\r\n        // merge custom modules\r\n        if (options.modules) {\r\n          finalOptions.modules =\r\n            (baseOptions.modules || []).concat(options.modules);\r\n        }\r\n        // merge custom directives\r\n        if (options.directives) {\r\n          finalOptions.directives = extend(\r\n            Object.create(baseOptions.directives),\r\n            options.directives\r\n          );\r\n        }\r\n        // copy other options\r\n        for (var key in options) {\r\n          if (key !== 'modules' && key !== 'directives') {\r\n            finalOptions[key] = options[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      var compiled = baseCompile(template, finalOptions);\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        errors.push.apply(errors, detectErrors(compiled.ast));\r\n      }\r\n      compiled.errors = errors;\r\n      compiled.tips = tips;\r\n      return compiled\r\n    }\r\n\r\n    return {\r\n      compile: compile,\r\n      compileToFunctions: createCompileToFunctionFn(compile)\r\n    }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n// `createCompilerCreator` allows creating compilers that use alternative\r\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\r\n// Here we just export a default compiler using the default parts.\r\nvar createCompiler = createCompilerCreator(function baseCompile (\r\n  template,\r\n  options\r\n) {\r\n  var ast = parse(template.trim(), options);\r\n  optimize(ast, options);\r\n  var code = generate(ast, options);\r\n  return {\r\n    ast: ast,\r\n    render: code.render,\r\n    staticRenderFns: code.staticRenderFns\r\n  }\r\n});\r\n\r\n/*  */\r\n\r\nvar ref$1 = createCompiler(baseOptions);\r\nvar compileToFunctions = ref$1.compileToFunctions;\r\n\r\n/*  */\r\n\r\nvar idToTemplate = cached(function (id) {\r\n  var el = query(id);\r\n  return el && el.innerHTML\r\n});\r\n\r\nvar mount = Vue$3.prototype.$mount;\r\nVue$3.prototype.$mount = function (\r\n  el,\r\n  hydrating\r\n) {\r\n  el = el && query(el);\r\n\r\n  /* istanbul ignore if */\r\n  if (el === document.body || el === document.documentElement) {\r\n    process.env.NODE_ENV !== 'production' && warn(\r\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\r\n    );\r\n    return this\r\n  }\r\n\r\n  var options = this.$options;\r\n  // resolve template/el and convert to render function\r\n  if (!options.render) {\r\n    var template = options.template;\r\n    if (template) {\r\n      if (typeof template === 'string') {\r\n        if (template.charAt(0) === '#') {\r\n          template = idToTemplate(template);\r\n          /* istanbul ignore if */\r\n          if (process.env.NODE_ENV !== 'production' && !template) {\r\n            warn(\r\n              (\"Template element not found or is empty: \" + (options.template)),\r\n              this\r\n            );\r\n          }\r\n        }\r\n      } else if (template.nodeType) {\r\n        template = template.innerHTML;\r\n      } else {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          warn('invalid template option:' + template, this);\r\n        }\r\n        return this\r\n      }\r\n    } else if (el) {\r\n      template = getOuterHTML(el);\r\n    }\r\n    if (template) {\r\n      /* istanbul ignore if */\r\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\r\n        mark('compile');\r\n      }\r\n\r\n      var ref = compileToFunctions(template, {\r\n        shouldDecodeNewlines: shouldDecodeNewlines,\r\n        delimiters: options.delimiters,\r\n        comments: options.comments\r\n      }, this);\r\n      var render = ref.render;\r\n      var staticRenderFns = ref.staticRenderFns;\r\n      options.render = render;\r\n      options.staticRenderFns = staticRenderFns;\r\n\r\n      /* istanbul ignore if */\r\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\r\n        mark('compile end');\r\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\r\n      }\r\n    }\r\n  }\r\n  return mount.call(this, el, hydrating)\r\n};\r\n\r\n/**\r\n * Get outerHTML of elements, taking care\r\n * of SVG elements in IE as well.\r\n */\r\nfunction getOuterHTML (el) {\r\n  if (el.outerHTML) {\r\n    return el.outerHTML\r\n  } else {\r\n    var container = document.createElement('div');\r\n    container.appendChild(el.cloneNode(true));\r\n    return container.innerHTML\r\n  }\r\n}\r\n\r\nVue$3.compile = compileToFunctions;\r\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\r\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2), __webpack_require__(6)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9lZmViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQ0FBaUMsRUFBRTtBQUNyRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjOztBQUUzQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx1Q0FBdUMsd0JBQXdCLEVBQUU7QUFDakUsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RCxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pELG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QjtBQUN6QjtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsK0JBQStCO0FBQzNELDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0RBQWtEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1RkFBdUY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0YsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQTZDO0FBQzlFO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDOztBQUV6RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMkRBQTJELDJCQUEyQixFQUFFO0FBQ3hGLEtBQUs7QUFDTDtBQUNBLDJEQUEyRCw0QkFBNEIsRUFBRTtBQUN6RjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixzQkFBc0I7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RCw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FLGlCQUFpQix3QkFBd0IsT0FBTyx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0RBQWtEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrREFBa0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUNBQW1DLGdFQUFnRTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUIsT0FBTyxnQ0FBZ0M7QUFDL0Usd0RBQXdELG9CQUFvQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0VBQWdFO0FBQzNGLE9BQU87QUFDUCxtQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG9CQUFvQjtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRCxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQsS0FBSztBQUNMLHdDQUF3QyxrQkFBa0I7QUFDMUQsS0FBSztBQUNMLHdDQUF3QywwQkFBMEI7QUFDbEUsS0FBSztBQUNMLHdDQUF3QyxpQkFBaUI7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlLEVBQUUsdUJBQXVCLFVBQVUsRUFBRTtBQUNwRjtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLDJCQUEyQjtBQUNqRTs7QUFFQTtBQUNBLHNDQUFzQywyQkFBMkI7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw2RUFBNkU7QUFDN0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELEdBQUc7QUFDSCx5Q0FBeUM7QUFDekM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRiw0QkFBNEI7QUFDNUI7QUFDQSwyQkFBMkI7QUFDM0Isd0JBQXdCLHlDQUF5QztBQUNqRSxZQUFZLGtFQUFrRTtBQUM5RSxNQUFNLEtBQUssMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRCxzQkFBc0IsK0NBQStDO0FBQ3JFLGlEQUFpRDs7QUFFakQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2Q0FBNkMsRUFBRTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCLEVBQUU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCLEVBQUU7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QyxFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkMsRUFBRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsOEJBQThCLEVBQUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsdUNBQXVDLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFLDBCQUEwQixFQUFFO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsRUFBRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QixFQUFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7O0FBRUEsc0JBQXNCLEVBQUUsY0FBYyxFQUFFO0FBQ3hDLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLFNBQVM7QUFDVCxRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBLHFEQUFxRCwyREFBMkQ7O0FBRWhIO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCLEVBQUU7QUFDMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0MsNkJBQTZCLGdCQUFnQjtBQUM3Qyw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1FQUFtRTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QyxzQkFBc0IsYUFBYTs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsR0FBRyxJQUFJOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQSx1REFBdUQsNkRBQTZEO0FBQ3BILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sNEJBQTRCO0FBQ25DO0FBQ0E7QUFDQSxPQUFPLE9BQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QixFQUFFO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyQ0FBMkMsR0FBRzs7QUFFbkY7QUFDQSxrQ0FBa0M7QUFDbEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0EsbURBQW1ELGtDQUFrQyxFQUFFO0FBQ3ZGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0EsOEZBQThGO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaURBQWlEO0FBQ3ZGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsdUNBQXVDLCtCQUErQjtBQUN0RTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9COztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkdBQTZHO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ1NBQWdTO0FBQy9TO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCLGlDQUFpQyw0RUFBNEUscUJBQXFCLGFBQWEsR0FBRyxFQUFFLGtCQUFrQjtBQUNyTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpRUFBaUU7QUFDNUU7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCLEVBQUU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsb0NBQW9DLEVBQUU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZ0NBQWdDLEVBQUU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0MsK0NBQStDLEVBQUUsaUJBQWlCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RSxHQUFHOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUIsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUIsRUFBRTtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBWdWUuanMgdjIuNC40XHJcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyogICovXHJcblxyXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXHJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcclxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xyXG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0RlZiAodikge1xyXG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcclxuICByZXR1cm4gdiA9PT0gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XHJcbiAgcmV0dXJuIHYgPT09IGZhbHNlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcclxuICovXHJcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XHJcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxyXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXHJcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcclxuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXHJcbn1cclxuXHJcbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcclxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xyXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xyXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xyXG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cclxuICovXHJcbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcclxuICByZXR1cm4gdmFsID09IG51bGxcclxuICAgID8gJydcclxuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcclxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXHJcbiAgICAgIDogU3RyaW5nKHZhbClcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXHJcbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xyXG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxyXG4gKiBpcyBpbiB0aGF0IG1hcC5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNYXAgKFxyXG4gIHN0cixcclxuICBleHBlY3RzTG93ZXJDYXNlXHJcbikge1xyXG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxyXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XHJcbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cclxuICovXHJcbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxyXG4gKi9cclxudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3QsaXMnKTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xyXG4gIGlmIChhcnIubGVuZ3RoKSB7XHJcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcclxuICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxyXG4gKi9cclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xyXG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FjaGVkIChmbikge1xyXG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XHJcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxyXG4gIH0pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxyXG4gKi9cclxudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXHJcbiAqL1xyXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxyXG4gKi9cclxudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcclxudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XHJcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xyXG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGxcclxuICAgICAgPyBsID4gMVxyXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXHJcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcclxuICAgICAgOiBmbi5jYWxsKGN0eClcclxuICB9XHJcbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxyXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcclxuICByZXR1cm4gYm91bmRGblxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xyXG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcclxuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XHJcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XHJcbiAgfVxyXG4gIHJldHVybiByZXRcclxufVxyXG5cclxuLyoqXHJcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XHJcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIHRvXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xyXG4gIHZhciByZXMgPSB7fTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGFycltpXSkge1xyXG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cclxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXHJcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxyXG4gKi9cclxuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cclxuXHJcbi8qKlxyXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBzYW1lIHZhbHVlXHJcbiAqL1xyXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XHJcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XHJcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxyXG4gIH0sIFtdKS5qb2luKCcsJylcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxyXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XHJcbiAqL1xyXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XHJcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxyXG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcclxuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XHJcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XHJcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XHJcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xyXG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xyXG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcclxuICAgICAgICB9KVxyXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcclxuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcclxuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXHJcbiAgICAgICAgfSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XHJcbiAgfVxyXG4gIHJldHVybiAtMVxyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cclxuICovXHJcbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XHJcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIWNhbGxlZCkge1xyXG4gICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcclxuXHJcbnZhciBBU1NFVF9UWVBFUyA9IFtcclxuICAnY29tcG9uZW50JyxcclxuICAnZGlyZWN0aXZlJyxcclxuICAnZmlsdGVyJ1xyXG5dO1xyXG5cclxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcclxuICAnYmVmb3JlQ3JlYXRlJyxcclxuICAnY3JlYXRlZCcsXHJcbiAgJ2JlZm9yZU1vdW50JyxcclxuICAnbW91bnRlZCcsXHJcbiAgJ2JlZm9yZVVwZGF0ZScsXHJcbiAgJ3VwZGF0ZWQnLFxyXG4gICdiZWZvcmVEZXN0cm95JyxcclxuICAnZGVzdHJveWVkJyxcclxuICAnYWN0aXZhdGVkJyxcclxuICAnZGVhY3RpdmF0ZWQnXHJcbl07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBjb25maWcgPSAoe1xyXG4gIC8qKlxyXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxyXG4gICAqL1xyXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cclxuICAgKi9cclxuICBzaWxlbnQ6IGZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xyXG4gICAqL1xyXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXHJcbiAgICovXHJcbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcclxuICAgKi9cclxuICBwZXJmb3JtYW5jZTogZmFsc2UsXHJcblxyXG4gIC8qKlxyXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXHJcbiAgICovXHJcbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxyXG5cclxuICAvKipcclxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcclxuICAgKi9cclxuICB3YXJuSGFuZGxlcjogbnVsbCxcclxuXHJcbiAgLyoqXHJcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXHJcbiAgICovXHJcbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cclxuICAgKi9cclxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXHJcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxyXG4gICAqL1xyXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxyXG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICovXHJcbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXHJcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxyXG4gICAqL1xyXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XHJcbiAgICovXHJcbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxyXG5cclxuICAvKipcclxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxyXG4gICAqL1xyXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcclxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXHJcbiAgICovXHJcbiAgbXVzdFVzZVByb3A6IG5vLFxyXG5cclxuICAvKipcclxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xyXG4gICAqL1xyXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXHJcbn0pO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cclxuICovXHJcbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xyXG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xyXG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmluZSBhIHByb3BlcnR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICB2YWx1ZTogdmFsLFxyXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWVcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxyXG4gKi9cclxudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XHJcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xyXG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxyXG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9ialxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgd2FybiA9IG5vb3A7XHJcbnZhciB0aXAgPSBub29wO1xyXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChudWxsKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcclxuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcclxuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcclxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXHJcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XHJcblxyXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xyXG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xyXG5cclxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcclxuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xyXG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcclxuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcclxuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcclxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcclxuICAgICAgKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcclxuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcclxuICAgICAgcmV0dXJuICc8Um9vdD4nXHJcbiAgICB9XHJcbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcclxuICAgICAgPyB2bVxyXG4gICAgICA6IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXHJcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcclxuICAgICAgICA6IHZtLl9pc1Z1ZVxyXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcclxuICAgICAgICAgIDogdm0ubmFtZTtcclxuXHJcbiAgICB2YXIgZmlsZSA9IHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGU7XHJcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xyXG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcclxuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xyXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxyXG4gICAgKVxyXG4gIH07XHJcblxyXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XHJcbiAgICB2YXIgcmVzID0gJyc7XHJcbiAgICB3aGlsZSAobikge1xyXG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxyXG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxyXG4gICAgICBuID4+PSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH07XHJcblxyXG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XHJcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcclxuICAgICAgdmFyIHRyZWUgPSBbXTtcclxuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XHJcbiAgICAgIHdoaWxlICh2bSkge1xyXG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xyXG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcclxuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XHJcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyZWUucHVzaCh2bSk7XHJcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXHJcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxyXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXHJcbiAgICAgICAgLmpvaW4oJ1xcbicpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcclxuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xyXG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXHJcblxyXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cclxudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XHJcblxyXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXHJcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcclxudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XHJcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XHJcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xyXG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XHJcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xyXG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xyXG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcclxuXHJcbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cclxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcclxuXHJcbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcclxuaWYgKGluQnJvd3Nlcikge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgb3B0cyA9IHt9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XHJcbiAgfSBjYXRjaCAoZSkge31cclxufVxyXG5cclxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXHJcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXHJcbnZhciBfaXNTZXJ2ZXI7XHJcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXHJcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcclxuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBfaXNTZXJ2ZXJcclxufTtcclxuXHJcbi8vIGRldGVjdCBkZXZ0b29sc1xyXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xyXG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxyXG59XHJcblxyXG52YXIgaGFzU3ltYm9sID1cclxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXHJcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XHJcblxyXG4vKipcclxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXHJcbiAqL1xyXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBjYWxsYmFja3MgPSBbXTtcclxuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xyXG4gIHZhciB0aW1lckZ1bmM7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XHJcbiAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb3BpZXNbaV0oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXHJcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXHJcbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXHJcbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcclxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXHJcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcclxuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcclxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xyXG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcclxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXHJcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXHJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxyXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cclxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cclxuICAgIH07XHJcbiAgfSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxyXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcclxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxyXG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xyXG4gICkpIHtcclxuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXHJcbiAgICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcclxuICAgIHZhciBjb3VudGVyID0gMTtcclxuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XHJcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xyXG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xyXG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XHJcbiAgICB2YXIgX3Jlc29sdmU7XHJcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChjYikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjYi5jYWxsKGN0eCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcclxuICAgICAgICBfcmVzb2x2ZShjdHgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmICghcGVuZGluZykge1xyXG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgdGltZXJGdW5jKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9XHJcbn0pKCk7XHJcblxyXG52YXIgX1NldDtcclxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XHJcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXHJcbiAgX1NldCA9IFNldDtcclxufSBlbHNlIHtcclxuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXHJcbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xyXG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXHJcbiAgICB9O1xyXG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xyXG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xyXG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBTZXQ7XHJcbiAgfSgpKTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5cclxudmFyIHVpZCA9IDA7XHJcblxyXG4vKipcclxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXHJcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXHJcbiAqL1xyXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcclxuICB0aGlzLmlkID0gdWlkKys7XHJcbiAgdGhpcy5zdWJzID0gW107XHJcbn07XHJcblxyXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XHJcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcclxufTtcclxuXHJcbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcclxuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xyXG59O1xyXG5cclxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xyXG4gIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcclxuICB9XHJcbn07XHJcblxyXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XHJcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcclxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHN1YnNbaV0udXBkYXRlKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxyXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXHJcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxyXG5EZXAudGFyZ2V0ID0gbnVsbDtcclxudmFyIHRhcmdldFN0YWNrID0gW107XHJcblxyXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XHJcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxyXG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xyXG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcclxufVxyXG5cclxuLypcclxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXHJcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxyXG4gKi9cclxuXHJcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xyXG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXHJcbiAgJ3B1c2gnLFxyXG4gICdwb3AnLFxyXG4gICdzaGlmdCcsXHJcbiAgJ3Vuc2hpZnQnLFxyXG4gICdzcGxpY2UnLFxyXG4gICdzb3J0JyxcclxuICAncmV2ZXJzZSdcclxuXVxyXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXHJcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xyXG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcclxuICAgIHZhciBpbnNlcnRlZDtcclxuICAgIHN3aXRjaCAobWV0aG9kKSB7XHJcbiAgICAgIGNhc2UgJ3B1c2gnOlxyXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcclxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAnc3BsaWNlJzpcclxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XHJcbiAgICAvLyBub3RpZnkgY2hhbmdlXHJcbiAgICBvYi5kZXAubm90aWZ5KCk7XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcclxuXHJcbi8qKlxyXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXHJcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcclxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxyXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cclxuICovXHJcbnZhciBvYnNlcnZlclN0YXRlID0ge1xyXG4gIHNob3VsZENvbnZlcnQ6IHRydWVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXHJcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxyXG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxyXG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxyXG4gKi9cclxudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XHJcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xyXG4gIHRoaXMudm1Db3VudCA9IDA7XHJcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXHJcbiAgICAgID8gcHJvdG9BdWdtZW50XHJcbiAgICAgIDogY29weUF1Z21lbnQ7XHJcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XHJcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMud2Fsayh2YWx1ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xyXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cclxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXHJcbiAqL1xyXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xyXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXHJcbiAqL1xyXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBoZWxwZXJzXHJcblxyXG4vKipcclxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xyXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xyXG4gKi9cclxuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xyXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXHJcbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcclxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcclxuICogaGlkZGVuIHByb3BlcnRpZXMuXHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxyXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxyXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cclxuICovXHJcbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XHJcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgb2I7XHJcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XHJcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcclxuICB9IGVsc2UgaWYgKFxyXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXHJcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxyXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxyXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcclxuICAgICF2YWx1ZS5faXNWdWVcclxuICApIHtcclxuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcclxuICB9XHJcbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcclxuICAgIG9iLnZtQ291bnQrKztcclxuICB9XHJcbiAgcmV0dXJuIG9iXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXHJcbiAgb2JqLFxyXG4gIGtleSxcclxuICB2YWwsXHJcbiAgY3VzdG9tU2V0dGVyLFxyXG4gIHNoYWxsb3dcclxuKSB7XHJcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcclxuXHJcbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XHJcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXHJcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcclxuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xyXG5cclxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcclxuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcclxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICBkZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcclxuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xyXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xyXG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZXR0ZXIpIHtcclxuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsID0gbmV3VmFsO1xyXG4gICAgICB9XHJcbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XHJcbiAgICAgIGRlcC5ub3RpZnkoKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxyXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XHJcbiAqIGFscmVhZHkgZXhpc3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcclxuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xyXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XHJcbiAgICByZXR1cm4gdmFsXHJcbiAgfVxyXG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XHJcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcclxuICAgIHJldHVybiB2YWxcclxuICB9XHJcbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xyXG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXHJcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHZhbFxyXG4gIH1cclxuICBpZiAoIW9iKSB7XHJcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcclxuICAgIHJldHVybiB2YWxcclxuICB9XHJcbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcclxuICBvYi5kZXAubm90aWZ5KCk7XHJcbiAgcmV0dXJuIHZhbFxyXG59XHJcblxyXG4vKipcclxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcclxuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XHJcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xyXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcclxuICAgICk7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgZGVsZXRlIHRhcmdldFtrZXldO1xyXG4gIGlmICghb2IpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBvYi5kZXAubm90aWZ5KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxyXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xyXG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIGUgPSB2YWx1ZVtpXTtcclxuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgZGVwZW5kQXJyYXkoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXHJcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXHJcbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxyXG4gKi9cclxudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XHJcblxyXG4vKipcclxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xyXG4gKi9cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcclxuICAgIGlmICghdm0pIHtcclxuICAgICAgd2FybihcclxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xyXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XHJcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XHJcbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGtleSA9IGtleXNbaV07XHJcbiAgICB0b1ZhbCA9IHRvW2tleV07XHJcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xyXG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcclxuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xyXG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XHJcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0b1xyXG59XHJcblxyXG4vKipcclxuICogRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXHJcbiAgcGFyZW50VmFsLFxyXG4gIGNoaWxkVmFsLFxyXG4gIHZtXHJcbikge1xyXG4gIGlmICghdm0pIHtcclxuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXHJcbiAgICBpZiAoIWNoaWxkVmFsKSB7XHJcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcclxuICAgIH1cclxuICAgIGlmICghcGFyZW50VmFsKSB7XHJcbiAgICAgIHJldHVybiBjaGlsZFZhbFxyXG4gICAgfVxyXG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxyXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXHJcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cclxuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxyXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcclxuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcclxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsXHJcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMpIDogcGFyZW50VmFsXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcclxuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcclxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcclxuICAgICAgICA6IGNoaWxkVmFsO1xyXG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcclxuICAgICAgICA6IHBhcmVudFZhbDtcclxuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xyXG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXHJcbiAgcGFyZW50VmFsLFxyXG4gIGNoaWxkVmFsLFxyXG4gIHZtXHJcbikge1xyXG4gIGlmICghdm0pIHtcclxuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xyXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gcGFyZW50VmFsXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbi5jYWxsKHRoaXMsIHBhcmVudFZhbCwgY2hpbGRWYWwpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxyXG4gIHBhcmVudFZhbCxcclxuICBjaGlsZFZhbFxyXG4pIHtcclxuICByZXR1cm4gY2hpbGRWYWxcclxuICAgID8gcGFyZW50VmFsXHJcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcclxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxyXG4gICAgICAgID8gY2hpbGRWYWxcclxuICAgICAgICA6IFtjaGlsZFZhbF1cclxuICAgIDogcGFyZW50VmFsXHJcbn1cclxuXHJcbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XHJcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBBc3NldHNcclxuICpcclxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xyXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXHJcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcclxuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XHJcbiAgcmV0dXJuIGNoaWxkVmFsXHJcbiAgICA/IGV4dGVuZChyZXMsIGNoaWxkVmFsKVxyXG4gICAgOiByZXNcclxufVxyXG5cclxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBXYXRjaGVycy5cclxuICpcclxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxyXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cclxuICovXHJcbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cclxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cclxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxyXG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XHJcbiAgdmFyIHJldCA9IHt9O1xyXG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XHJcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XHJcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xyXG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XHJcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xyXG4gICAgfVxyXG4gICAgcmV0W2tleV0gPSBwYXJlbnRcclxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxyXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn07XHJcblxyXG4vKipcclxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cclxuICovXHJcbnN0cmF0cy5wcm9wcyA9XHJcbnN0cmF0cy5tZXRob2RzID1cclxuc3RyYXRzLmluamVjdCA9XHJcbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cclxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cclxuICByZXR1cm4gcmV0XHJcbn07XHJcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxyXG4gKi9cclxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcclxuICAgID8gcGFyZW50VmFsXHJcbiAgICA6IGNoaWxkVmFsXHJcbn07XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcclxuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XHJcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xyXG4gICAgICAgICdpZDogJyArIGtleVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxyXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcclxuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xyXG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cclxuICB2YXIgcmVzID0ge307XHJcbiAgdmFyIGksIHZhbCwgbmFtZTtcclxuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcclxuICAgIGkgPSBwcm9wcy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xyXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcclxuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcclxuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XHJcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XHJcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcclxuICAgICAgICA/IHZhbFxyXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcclxuICAgIH1cclxuICB9XHJcbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucykge1xyXG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcclxuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSBpbmplY3RbaV07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcclxuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcclxuICBpZiAoZGlycykge1xyXG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcclxuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcclxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cclxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXHJcbiAgcGFyZW50LFxyXG4gIGNoaWxkLFxyXG4gIHZtXHJcbikge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xyXG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCk7XHJcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XHJcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcclxuICBpZiAoZXh0ZW5kc0Zyb20pIHtcclxuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XHJcbiAgfVxyXG4gIGlmIChjaGlsZC5taXhpbnMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICB2YXIga2V5O1xyXG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xyXG4gICAgbWVyZ2VGaWVsZChrZXkpO1xyXG4gIH1cclxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xyXG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XHJcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XHJcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XHJcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XHJcbiAgfVxyXG4gIHJldHVybiBvcHRpb25zXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcclxuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcclxuICBvcHRpb25zLFxyXG4gIHR5cGUsXHJcbiAgaWQsXHJcbiAgd2Fybk1pc3NpbmdcclxuKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcclxuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxyXG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxyXG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcclxuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cclxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XHJcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cclxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cclxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXHJcbiAgICAgIG9wdGlvbnNcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxyXG4gIGtleSxcclxuICBwcm9wT3B0aW9ucyxcclxuICBwcm9wc0RhdGEsXHJcbiAgdm1cclxuKSB7XHJcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xyXG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcclxuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcclxuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xyXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xyXG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcclxuICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XHJcbiAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxyXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XHJcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXHJcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cclxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcclxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XHJcbiAgICBvYnNlcnZlKHZhbHVlKTtcclxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xyXG4gIH1cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xyXG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcclxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgfVxyXG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XHJcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcclxuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xyXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gIH1cclxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxyXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcclxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcclxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcclxuICApIHtcclxuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxyXG4gIH1cclxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xyXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcclxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcclxuICAgID8gZGVmLmNhbGwodm0pXHJcbiAgICA6IGRlZlxyXG59XHJcblxyXG4vKipcclxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXHJcbiAgcHJvcCxcclxuICBuYW1lLFxyXG4gIHZhbHVlLFxyXG4gIHZtLFxyXG4gIGFic2VudFxyXG4pIHtcclxuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xyXG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XHJcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcclxuICBpZiAodHlwZSkge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XHJcbiAgICAgIHR5cGUgPSBbdHlwZV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XHJcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcclxuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xyXG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCF2YWxpZCkge1xyXG4gICAgd2FybihcclxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcclxuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXHJcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcclxuICBpZiAodmFsaWRhdG9yKSB7XHJcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcclxuXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XHJcbiAgdmFyIHZhbGlkO1xyXG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xyXG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xyXG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XHJcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xyXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XHJcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHZhbGlkOiB2YWxpZCxcclxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxyXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcclxuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcclxuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xyXG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcclxufVxyXG5cclxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxyXG4gIH1cclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBtYXJrO1xyXG52YXIgbWVhc3VyZTtcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChcclxuICAgIHBlcmYgJiZcclxuICAgIHBlcmYubWFyayAmJlxyXG4gICAgcGVyZi5tZWFzdXJlICYmXHJcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcclxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xyXG4gICkge1xyXG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xyXG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XHJcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcclxuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XHJcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cclxuXHJcbnZhciBpbml0UHJveHk7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXHJcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcclxuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcclxuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXHJcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxyXG4gICk7XHJcblxyXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgd2FybihcclxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xyXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXHJcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXHJcbiAgICAgIHRhcmdldFxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICB2YXIgaGFzUHJveHkgPVxyXG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcclxuXHJcbiAgaWYgKGhhc1Byb3h5KSB7XHJcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XHJcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XHJcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xyXG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFzSGFuZGxlciA9IHtcclxuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xyXG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcclxuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xyXG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBnZXRIYW5kbGVyID0ge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XHJcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XHJcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcclxuICAgIGlmIChoYXNQcm94eSkge1xyXG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcclxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxyXG4gICAgICAgID8gZ2V0SGFuZGxlclxyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcclxuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcclxuICB0YWcsXHJcbiAgZGF0YSxcclxuICBjaGlsZHJlbixcclxuICB0ZXh0LFxyXG4gIGVsbSxcclxuICBjb250ZXh0LFxyXG4gIGNvbXBvbmVudE9wdGlvbnMsXHJcbiAgYXN5bmNGYWN0b3J5XHJcbikge1xyXG4gIHRoaXMudGFnID0gdGFnO1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgdGhpcy5lbG0gPSBlbG07XHJcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcclxuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xyXG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XHJcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICB0aGlzLnJhdyA9IGZhbHNlO1xyXG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcclxuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XHJcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcclxuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XHJcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcclxuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcclxuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcclxuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xyXG59O1xyXG5cclxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XHJcblxyXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2VcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xyXG5cclxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xyXG5cclxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xyXG4gIG5vZGUudGV4dCA9IHRleHQ7XHJcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xyXG4gIHJldHVybiBub2RlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xyXG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXHJcbn1cclxuXHJcbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXHJcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3NcclxuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XHJcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXHJcbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlLCBkZWVwKSB7XHJcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcclxuICAgIHZub2RlLnRhZyxcclxuICAgIHZub2RlLmRhdGEsXHJcbiAgICB2bm9kZS5jaGlsZHJlbixcclxuICAgIHZub2RlLnRleHQsXHJcbiAgICB2bm9kZS5lbG0sXHJcbiAgICB2bm9kZS5jb250ZXh0LFxyXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcclxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxyXG4gICk7XHJcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XHJcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XHJcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcclxuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xyXG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XHJcbiAgaWYgKGRlZXAgJiYgdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgIGNsb25lZC5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKHZub2RlLmNoaWxkcmVuKTtcclxuICB9XHJcbiAgcmV0dXJuIGNsb25lZFxyXG59XHJcblxyXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzLCBkZWVwKSB7XHJcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XHJcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldLCBkZWVwKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xyXG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcclxuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xyXG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxyXG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xyXG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgdmFyIHBsYWluID0gIShwYXNzaXZlIHx8IG9uY2UkJDEgfHwgY2FwdHVyZSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6IG5hbWUsXHJcbiAgICBwbGFpbjogcGxhaW4sXHJcbiAgICBvbmNlOiBvbmNlJCQxLFxyXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcclxuICAgIHBhc3NpdmU6IHBhc3NpdmVcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcclxuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcclxuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcclxuXHJcbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XHJcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xyXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcclxuICAgIH1cclxuICB9XHJcbiAgaW52b2tlci5mbnMgPSBmbnM7XHJcbiAgcmV0dXJuIGludm9rZXJcclxufVxyXG5cclxuLy8gIzY1NTJcclxuZnVuY3Rpb24gcHJpb3JpdGl6ZVBsYWluRXZlbnRzIChhLCBiKSB7XHJcbiAgcmV0dXJuIGEucGxhaW4gPyAtMSA6IGIucGxhaW4gPyAxIDogMFxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxyXG4gIG9uLFxyXG4gIG9sZE9uLFxyXG4gIGFkZCxcclxuICByZW1vdmUkJDEsXHJcbiAgdm1cclxuKSB7XHJcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcclxuICB2YXIgdG9BZGQgPSBbXTtcclxuICB2YXIgaGFzTW9kaWZpZXIgPSBmYWxzZTtcclxuICBmb3IgKG5hbWUgaW4gb24pIHtcclxuICAgIGN1ciA9IG9uW25hbWVdO1xyXG4gICAgb2xkID0gb2xkT25bbmFtZV07XHJcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xyXG4gICAgaWYgKCFldmVudC5wbGFpbikgeyBoYXNNb2RpZmllciA9IHRydWU7IH1cclxuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcclxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xyXG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xyXG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XHJcbiAgICAgIH1cclxuICAgICAgZXZlbnQuaGFuZGxlciA9IGN1cjtcclxuICAgICAgdG9BZGQucHVzaChldmVudCk7XHJcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XHJcbiAgICAgIG9sZC5mbnMgPSBjdXI7XHJcbiAgICAgIG9uW25hbWVdID0gb2xkO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAodG9BZGQubGVuZ3RoKSB7XHJcbiAgICBpZiAoaGFzTW9kaWZpZXIpIHsgdG9BZGQuc29ydChwcmlvcml0aXplUGxhaW5FdmVudHMpOyB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBldmVudCQxID0gdG9BZGRbaV07XHJcbiAgICAgIGFkZChldmVudCQxLm5hbWUsIGV2ZW50JDEuaGFuZGxlciwgZXZlbnQkMS5vbmNlLCBldmVudCQxLmNhcHR1cmUsIGV2ZW50JDEucGFzc2l2ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xyXG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XHJcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XHJcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcclxuICB2YXIgaW52b2tlcjtcclxuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcclxuXHJcbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xyXG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxyXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcclxuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcclxuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcclxuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XHJcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcclxuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXHJcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XHJcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcclxuICBkYXRhLFxyXG4gIEN0b3IsXHJcbiAgdGFnXHJcbikge1xyXG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxyXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxyXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xyXG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciByZXMgPSB7fTtcclxuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xyXG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XHJcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xyXG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxyXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRpcChcclxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xyXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xyXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcclxuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcclxuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcclxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxyXG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxyXG4gIHJlcyxcclxuICBoYXNoLFxyXG4gIGtleSxcclxuICBhbHRLZXksXHJcbiAgcHJlc2VydmVcclxuKSB7XHJcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XHJcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcclxuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XHJcbiAgICAgIGlmICghcHJlc2VydmUpIHtcclxuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XHJcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xyXG4gICAgICBpZiAoIXByZXNlcnZlKSB7XHJcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcclxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cclxuLy9cclxuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcclxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxyXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XHJcblxyXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcclxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXHJcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxyXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXHJcbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjaGlsZHJlblxyXG59XHJcblxyXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxyXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxyXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XHJcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxyXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cclxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxyXG4gICAgICA6IHVuZGVmaW5lZFxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XHJcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIHZhciBpLCBjLCBsYXN0O1xyXG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgYyA9IGNoaWxkcmVuW2ldO1xyXG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XHJcbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcclxuICAgIC8vICBuZXN0ZWRcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XHJcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcclxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcclxuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcclxuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXHJcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxyXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xyXG4gICAgICAgIChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcclxuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xyXG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXHJcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xyXG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcclxuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcclxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxyXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXHJcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxyXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcy5wdXNoKGMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XHJcbiAgaWYgKGNvbXAuX19lc01vZHVsZSAmJiBjb21wLmRlZmF1bHQpIHtcclxuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiBpc09iamVjdChjb21wKVxyXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxyXG4gICAgOiBjb21wXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxyXG4gIGZhY3RvcnksXHJcbiAgZGF0YSxcclxuICBjb250ZXh0LFxyXG4gIGNoaWxkcmVuLFxyXG4gIHRhZ1xyXG4pIHtcclxuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcclxuICByZXR1cm4gbm9kZVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxyXG4gIGZhY3RvcnksXHJcbiAgYmFzZUN0b3IsXHJcbiAgY29udGV4dFxyXG4pIHtcclxuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xyXG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXHJcbiAgfVxyXG5cclxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXHJcbiAgfVxyXG5cclxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcclxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXHJcbiAgfVxyXG5cclxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcclxuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xyXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xyXG4gICAgdmFyIHN5bmMgPSB0cnVlO1xyXG5cclxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxyXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcclxuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxyXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcclxuICAgICAgaWYgKCFzeW5jKSB7XHJcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xyXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxyXG4gICAgICApO1xyXG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XHJcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XHJcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcclxuXHJcbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xyXG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxyXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XHJcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcblxyXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XHJcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XHJcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xyXG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xyXG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgICAgICAgIHJlamVjdChcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcclxuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxyXG4gICAgICAgICAgICAgICAgICA6IG51bGxcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3luYyA9IGZhbHNlO1xyXG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxyXG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xyXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcclxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xyXG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XHJcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XHJcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xyXG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xyXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xyXG4gIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciB0YXJnZXQ7XHJcblxyXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xyXG4gIGlmIChvbmNlJCQxKSB7XHJcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xyXG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXHJcbiAgdm0sXHJcbiAgbGlzdGVuZXJzLFxyXG4gIG9sZExpc3RlbmVyc1xyXG4pIHtcclxuICB0YXJnZXQgPSB2bTtcclxuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xyXG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcclxuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xyXG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxyXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcclxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xyXG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm1cclxuICB9O1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIGZ1bmN0aW9uIG9uICgpIHtcclxuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xyXG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIG9uLmZuID0gZm47XHJcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAvLyBhbGxcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgcmV0dXJuIHZtXHJcbiAgICB9XHJcbiAgICAvLyBhcnJheSBvZiBldmVudHNcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2ldLCBmbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZtXHJcbiAgICB9XHJcbiAgICAvLyBzcGVjaWZpYyBldmVudFxyXG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xyXG4gICAgaWYgKCFjYnMpIHtcclxuICAgICAgcmV0dXJuIHZtXHJcbiAgICB9XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XHJcbiAgICAgIHJldHVybiB2bVxyXG4gICAgfVxyXG4gICAgaWYgKGZuKSB7XHJcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcclxuICAgICAgdmFyIGNiO1xyXG4gICAgICB2YXIgaSQxID0gY2JzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkkMS0tKSB7XHJcbiAgICAgICAgY2IgPSBjYnNbaSQxXTtcclxuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XHJcbiAgICAgICAgdGlwKFxyXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXHJcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXHJcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcclxuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcclxuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XHJcbiAgICBpZiAoY2JzKSB7XHJcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xyXG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxyXG4gIGNoaWxkcmVuLFxyXG4gIGNvbnRleHRcclxuKSB7XHJcbiAgdmFyIHNsb3RzID0ge307XHJcbiAgaWYgKCFjaGlsZHJlbikge1xyXG4gICAgcmV0dXJuIHNsb3RzXHJcbiAgfVxyXG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcclxuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcclxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XHJcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XHJcbiAgICB9XHJcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcclxuICAgIC8vIHNhbWUgY29udGV4dC5cclxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcclxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxyXG4gICAgKSB7XHJcbiAgICAgIHZhciBuYW1lID0gY2hpbGQuZGF0YS5zbG90O1xyXG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xyXG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcclxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcclxuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcclxuICB9XHJcbiAgcmV0dXJuIHNsb3RzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xyXG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxyXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcclxuICByZXNcclxuKSB7XHJcbiAgcmVzID0gcmVzIHx8IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XHJcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xyXG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xyXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XHJcblxyXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XHJcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xyXG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcclxuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcclxuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xyXG4gIH1cclxuXHJcbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcclxuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xyXG5cclxuICB2bS4kY2hpbGRyZW4gPSBbXTtcclxuICB2bS4kcmVmcyA9IHt9O1xyXG5cclxuICB2bS5fd2F0Y2hlciA9IG51bGw7XHJcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcclxuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcclxuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XHJcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XHJcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xyXG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcclxuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcclxuICAgIH1cclxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XHJcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xyXG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xyXG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcclxuICAgIHZtLl92bm9kZSA9IHZub2RlO1xyXG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXHJcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cclxuICAgIGlmICghcHJldlZub2RlKSB7XHJcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcclxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXHJcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcclxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxyXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxyXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB1cGRhdGVzXHJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcclxuICAgIH1cclxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xyXG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXHJcbiAgICBpZiAocHJldkVsKSB7XHJcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh2bS4kZWwpIHtcclxuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcclxuICAgIH1cclxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcclxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XHJcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xyXG4gICAgfVxyXG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxyXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cclxuICB9O1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcclxuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcclxuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcclxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XHJcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcclxuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcclxuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcclxuICAgIH1cclxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXHJcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcclxuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcclxuICAgIH1cclxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XHJcbiAgICB9XHJcbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxyXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXHJcbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XHJcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XHJcbiAgICB9XHJcbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cclxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcclxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xyXG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xyXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcclxuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXHJcbiAgICB2bS4kb2ZmKCk7XHJcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcclxuICAgIGlmICh2bS4kZWwpIHtcclxuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcclxuICB2bSxcclxuICBlbCxcclxuICBoeWRyYXRpbmdcclxuKSB7XHJcbiAgdm0uJGVsID0gZWw7XHJcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcclxuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcclxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXHJcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcclxuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XHJcblxyXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcclxuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcclxuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xyXG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcclxuXHJcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xyXG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XHJcbiAgICAgIG1hcmsoZW5kVGFnKTtcclxuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcblxyXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcclxuICAgICAgbWFyayhlbmRUYWcpO1xyXG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xyXG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xyXG5cclxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxyXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXHJcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XHJcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcclxuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xyXG4gIH1cclxuICByZXR1cm4gdm1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxyXG4gIHZtLFxyXG4gIHByb3BzRGF0YSxcclxuICBsaXN0ZW5lcnMsXHJcbiAgcGFyZW50Vm5vZGUsXHJcbiAgcmVuZGVyQ2hpbGRyZW5cclxuKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cclxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxyXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxyXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xyXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xyXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xyXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xyXG4gICk7XHJcblxyXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xyXG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXHJcblxyXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcclxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcclxuICB9XHJcbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XHJcblxyXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxyXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxyXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXHJcbiAgdm0uJGF0dHJzID0gKHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3Q7XHJcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcclxuXHJcbiAgLy8gdXBkYXRlIHByb3BzXHJcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xyXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XHJcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XHJcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcclxuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcclxuICAgIH1cclxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XHJcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXHJcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XHJcbiAgfVxyXG5cclxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXHJcbiAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xyXG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XHJcbiAgfVxyXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXHJcbiAgaWYgKGhhc0NoaWxkcmVuKSB7XHJcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xyXG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xyXG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xyXG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XHJcbiAgaWYgKGRpcmVjdCkge1xyXG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XHJcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xyXG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XHJcbiAgICB9XHJcbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XHJcbiAgaWYgKGRpcmVjdCkge1xyXG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcclxuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcclxuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcclxuICAgIH1cclxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xyXG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xyXG4gIGlmIChoYW5kbGVycykge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XHJcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcblxyXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcclxuXHJcbnZhciBxdWV1ZSA9IFtdO1xyXG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcclxudmFyIGhhcyA9IHt9O1xyXG52YXIgY2lyY3VsYXIgPSB7fTtcclxudmFyIHdhaXRpbmcgPSBmYWxzZTtcclxudmFyIGZsdXNoaW5nID0gZmFsc2U7XHJcbnZhciBpbmRleCA9IDA7XHJcblxyXG4vKipcclxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XHJcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gIGhhcyA9IHt9O1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBjaXJjdWxhciA9IHt9O1xyXG4gIH1cclxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XHJcbiAgZmx1c2hpbmcgPSB0cnVlO1xyXG4gIHZhciB3YXRjaGVyLCBpZDtcclxuXHJcbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXHJcbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XHJcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcclxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXHJcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxyXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXHJcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxyXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcclxuXHJcbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXHJcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXHJcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xyXG4gICAgaWQgPSB3YXRjaGVyLmlkO1xyXG4gICAgaGFzW2lkXSA9IG51bGw7XHJcbiAgICB3YXRjaGVyLnJ1bigpO1xyXG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XHJcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xyXG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXHJcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcclxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgd2F0Y2hlci52bVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxyXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XHJcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XHJcblxyXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcclxuXHJcbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXHJcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcclxuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XHJcblxyXG4gIC8vIGRldnRvb2wgaG9va1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcclxuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xyXG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XHJcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xyXG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcclxuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxyXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcclxuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXHJcbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcclxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcclxuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XHJcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXHJcbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xyXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xyXG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XHJcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xyXG4gICAgaGFzW2lkXSA9IHRydWU7XHJcbiAgICBpZiAoIWZsdXNoaW5nKSB7XHJcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXHJcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXHJcbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcclxuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcclxuICAgICAgICBpLS07XHJcbiAgICAgIH1cclxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcclxuICAgIH1cclxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxyXG4gICAgaWYgKCF3YWl0aW5nKSB7XHJcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xyXG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHVpZCQyID0gMDtcclxuXHJcbi8qKlxyXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcclxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cclxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXHJcbiAqL1xyXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxyXG4gIHZtLFxyXG4gIGV4cE9yRm4sXHJcbiAgY2IsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICB0aGlzLnZtID0gdm07XHJcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XHJcbiAgLy8gb3B0aW9uc1xyXG4gIGlmIChvcHRpb25zKSB7XHJcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcclxuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xyXG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XHJcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XHJcbiAgfVxyXG4gIHRoaXMuY2IgPSBjYjtcclxuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xyXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xyXG4gIHRoaXMuZGVwcyA9IFtdO1xyXG4gIHRoaXMubmV3RGVwcyA9IFtdO1xyXG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcclxuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XHJcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xyXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcclxuICAgIDogJyc7XHJcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXHJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xyXG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xyXG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXHJcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcclxuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcclxuICAgID8gdW5kZWZpbmVkXHJcbiAgICA6IHRoaXMuZ2V0KCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcclxuICBwdXNoVGFyZ2V0KHRoaXMpO1xyXG4gIHZhciB2YWx1ZTtcclxuICB2YXIgdm0gPSB0aGlzLnZtO1xyXG4gIHRyeSB7XHJcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAodGhpcy51c2VyKSB7XHJcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgZVxyXG4gICAgfVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcclxuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xyXG4gICAgaWYgKHRoaXMuZGVlcCkge1xyXG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBwb3BUYXJnZXQoKTtcclxuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlXHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XHJcbiAgdmFyIGlkID0gZGVwLmlkO1xyXG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xyXG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcclxuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XHJcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcclxuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XHJcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcclxuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XHJcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcclxuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcclxuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xyXG4gIHRtcCA9IHRoaXMuZGVwcztcclxuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XHJcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xyXG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxyXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmICh0aGlzLmxhenkpIHtcclxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XHJcbiAgICB0aGlzLnJ1bigpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxyXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcclxuICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgICBpZiAoXHJcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XHJcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxyXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XHJcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cclxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XHJcbiAgICAgIHRoaXMuZGVlcFxyXG4gICAgKSB7XHJcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcclxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICBpZiAodGhpcy51c2VyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxyXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcclxuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcclxuICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcclxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcclxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXHJcbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcclxuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcclxuICAgIH1cclxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxyXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxyXG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxyXG4gKi9cclxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcclxuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xyXG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XHJcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xyXG4gIHZhciBpLCBrZXlzO1xyXG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XHJcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKHZhbC5fX29iX18pIHtcclxuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xyXG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHNlZW4uYWRkKGRlcElkKTtcclxuICB9XHJcbiAgaWYgKGlzQSkge1xyXG4gICAgaSA9IHZhbC5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xyXG4gICAgaSA9IGtleXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gIGdldDogbm9vcCxcclxuICBzZXQ6IG5vb3BcclxufTtcclxuXHJcbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XHJcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcclxuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxyXG4gIH07XHJcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcclxuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xyXG4gIH07XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XHJcbiAgdm0uX3dhdGNoZXJzID0gW107XHJcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcclxuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XHJcbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxyXG4gIGlmIChvcHRzLmRhdGEpIHtcclxuICAgIGluaXREYXRhKHZtKTtcclxuICB9IGVsc2Uge1xyXG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xyXG4gIH1cclxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XHJcbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcclxuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja09wdGlvblR5cGUgKHZtLCBuYW1lKSB7XHJcbiAgdmFyIG9wdGlvbiA9IHZtLiRvcHRpb25zW25hbWVdO1xyXG4gIGlmICghaXNQbGFpbk9iamVjdChvcHRpb24pKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAoXCJjb21wb25lbnQgb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgc2hvdWxkIGJlIGFuIG9iamVjdC5cIiksXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XHJcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcclxuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcclxuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxyXG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxyXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XHJcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xyXG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxyXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcclxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xyXG4gICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGtleSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGtleSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXHJcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xyXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXHJcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXHJcbiAgICAgICAgICAgIHZtXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXHJcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxyXG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxyXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xyXG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcclxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcclxuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XHJcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcclxuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcclxuICAgIDogZGF0YSB8fCB7fTtcclxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcclxuICAgIGRhdGEgPSB7fTtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xyXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcclxuICAgICAgdm1cclxuICAgICk7XHJcbiAgfVxyXG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xyXG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xyXG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcclxuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcclxuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcclxuICAgICAgICB2bVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XHJcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIG9ic2VydmUgZGF0YVxyXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XHJcbiAgICByZXR1cm4ge31cclxuICB9XHJcbn1cclxuXHJcbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XHJcblxyXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xyXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnY29tcHV0ZWQnKTtcclxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcclxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xyXG5cclxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcclxuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcclxuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzU1NSKSB7XHJcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXHJcbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcclxuICAgICAgICB2bSxcclxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcclxuICAgICAgICBub29wLFxyXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXHJcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxyXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxyXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xyXG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcclxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XHJcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xyXG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXHJcbiAgdGFyZ2V0LFxyXG4gIGtleSxcclxuICB1c2VyRGVmXHJcbikge1xyXG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xyXG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXHJcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxyXG4gICAgICA6IHVzZXJEZWY7XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcclxuICB9IGVsc2Uge1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XHJcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcclxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcclxuICAgICAgICA6IHVzZXJEZWYuZ2V0XHJcbiAgICAgIDogbm9vcDtcclxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxyXG4gICAgICA/IHVzZXJEZWYuc2V0XHJcbiAgICAgIDogbm9vcDtcclxuICB9XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gIH1cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xyXG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcclxuICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XHJcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XHJcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGVja09wdGlvblR5cGUodm0sICdtZXRob2RzJyk7XHJcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XHJcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcclxuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xyXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xyXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnd2F0Y2gnKTtcclxuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcclxuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcclxuICB2bSxcclxuICBrZXlPckZuLFxyXG4gIGhhbmRsZXIsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xyXG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XHJcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XHJcbiAgfVxyXG4gIHJldHVybiB2bS4kd2F0Y2goa2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucylcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XHJcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XHJcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXHJcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxyXG4gIHZhciBkYXRhRGVmID0ge307XHJcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XHJcbiAgdmFyIHByb3BzRGVmID0ge307XHJcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXHJcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xyXG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXHJcbiAgICBleHBPckZuLFxyXG4gICAgY2IsXHJcbiAgICBvcHRpb25zXHJcbiAgKSB7XHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XHJcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcclxuICAgIH1cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcclxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcclxuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xyXG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xyXG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcclxuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XHJcbiAgaWYgKHByb3ZpZGUpIHtcclxuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxyXG4gICAgICA6IHByb3ZpZGU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcclxuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcclxuICBpZiAocmVzdWx0KSB7XHJcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcclxuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXHJcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXHJcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxyXG4gICAgICAgICAgICB2bVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcclxuICBpZiAoaW5qZWN0KSB7XHJcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxyXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxyXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmplY3QsIGtleSkuZW51bWVyYWJsZVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XTtcclxuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xyXG4gICAgICB3aGlsZSAoc291cmNlKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XHJcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc291cmNlKSB7XHJcbiAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxyXG4gIEN0b3IsXHJcbiAgcHJvcHNEYXRhLFxyXG4gIGRhdGEsXHJcbiAgY29udGV4dCxcclxuICBjaGlsZHJlblxyXG4pIHtcclxuICB2YXIgcHJvcHMgPSB7fTtcclxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XHJcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XHJcbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cclxuICB9XHJcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xyXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcclxuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xyXG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xyXG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XHJcbiAgICBkYXRhOiBkYXRhLFxyXG4gICAgcHJvcHM6IHByb3BzLFxyXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgcGFyZW50OiBjb250ZXh0LFxyXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0LFxyXG4gICAgaW5qZWN0aW9uczogcmVzb2x2ZUluamVjdChDdG9yLm9wdGlvbnMuaW5qZWN0LCBjb250ZXh0KSxcclxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XHJcbiAgfSk7XHJcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcclxuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gICAgaWYgKGRhdGEuc2xvdCkge1xyXG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHZub2RlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcclxuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXHJcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xyXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxyXG4gICAgdm5vZGUsXHJcbiAgICBoeWRyYXRpbmcsXHJcbiAgICBwYXJlbnRFbG0sXHJcbiAgICByZWZFbG1cclxuICApIHtcclxuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XHJcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcclxuICAgICAgICBwYXJlbnRFbG0sXHJcbiAgICAgICAgcmVmRWxtXHJcbiAgICAgICk7XHJcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XHJcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XHJcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxyXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xyXG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcclxuICAgICAgY2hpbGQsXHJcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXHJcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xyXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxyXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxyXG4gICAgKTtcclxuICB9LFxyXG5cclxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcclxuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcclxuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XHJcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcclxuICAgIH1cclxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xyXG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XHJcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXHJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxyXG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xyXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcclxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXHJcbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XHJcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XHJcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcclxuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcclxuICBDdG9yLFxyXG4gIGRhdGEsXHJcbiAgY29udGV4dCxcclxuICBjaGlsZHJlbixcclxuICB0YWdcclxuKSB7XHJcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcclxuXHJcbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXHJcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XHJcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xyXG4gIH1cclxuXHJcbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxyXG4gIC8vIHJlamVjdC5cclxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvLyBhc3luYyBjb21wb25lbnRcclxuICB2YXIgYXN5bmNGYWN0b3J5O1xyXG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xyXG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcclxuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XHJcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcclxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXHJcbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cclxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXHJcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICB0YWdcclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGF0YSA9IGRhdGEgfHwge307XHJcblxyXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cclxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xyXG5cclxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXHJcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XHJcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgLy8gZXh0cmFjdCBwcm9wc1xyXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XHJcblxyXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcclxuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXHJcbiAgfVxyXG5cclxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xyXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXHJcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XHJcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cclxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcclxuXHJcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XHJcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXHJcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxyXG5cclxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcclxuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xyXG4gICAgZGF0YSA9IHt9O1xyXG4gICAgaWYgKHNsb3QpIHtcclxuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcclxuICBtZXJnZUhvb2tzKGRhdGEpO1xyXG5cclxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxyXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xyXG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcclxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXHJcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxyXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcclxuICAgIGFzeW5jRmFjdG9yeVxyXG4gICk7XHJcbiAgcmV0dXJuIHZub2RlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxyXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcclxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxyXG4gIHBhcmVudEVsbSxcclxuICByZWZFbG1cclxuKSB7XHJcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXHJcbiAgICBwYXJlbnQ6IHBhcmVudCxcclxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcclxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXHJcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxyXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcclxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxyXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXHJcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxyXG4gIH07XHJcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcclxuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xyXG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcclxuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xyXG4gIGlmICghZGF0YS5ob29rKSB7XHJcbiAgICBkYXRhLmhvb2sgPSB7fTtcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XHJcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xyXG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XHJcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgIG9uZShhLCBiLCBjLCBkKTtcclxuICAgIHR3byhhLCBiLCBjLCBkKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cclxuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XHJcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XHJcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xyXG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XHJcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcclxuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xyXG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XHJcblxyXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxyXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXHJcbiAgY29udGV4dCxcclxuICB0YWcsXHJcbiAgZGF0YSxcclxuICBjaGlsZHJlbixcclxuICBub3JtYWxpemF0aW9uVHlwZSxcclxuICBhbHdheXNOb3JtYWxpemVcclxuKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcclxuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XHJcbiAgICBjaGlsZHJlbiA9IGRhdGE7XHJcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcclxuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcclxuICB9XHJcbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXHJcbiAgY29udGV4dCxcclxuICB0YWcsXHJcbiAgZGF0YSxcclxuICBjaGlsZHJlbixcclxuICBub3JtYWxpemF0aW9uVHlwZVxyXG4pIHtcclxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcclxuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXHJcbiAgICAgIGNvbnRleHRcclxuICAgICk7XHJcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXHJcbiAgfVxyXG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXHJcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XHJcbiAgICB0YWcgPSBkYXRhLmlzO1xyXG4gIH1cclxuICBpZiAoIXRhZykge1xyXG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxyXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxyXG4gIH1cclxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcclxuICApIHtcclxuICAgIHdhcm4oXHJcbiAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXHJcbiAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXHJcbiAgICAgIGNvbnRleHRcclxuICAgICk7XHJcbiAgfVxyXG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcclxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcclxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICkge1xyXG4gICAgZGF0YSA9IGRhdGEgfHwge307XHJcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xyXG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICB9XHJcbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XHJcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcclxuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XHJcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcclxuICB9XHJcbiAgdmFyIHZub2RlLCBucztcclxuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBDdG9yO1xyXG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcclxuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XHJcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXHJcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxyXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcclxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmIChpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcclxuICAgICAgLy8gY29tcG9uZW50XHJcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXHJcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXHJcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXHJcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxyXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXHJcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xyXG4gIH1cclxuICBpZiAoaXNEZWYodm5vZGUpKSB7XHJcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XHJcbiAgICByZXR1cm4gdm5vZGVcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XHJcbiAgdm5vZGUubnMgPSBucztcclxuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcclxuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiBpc1VuZGVmKGNoaWxkLm5zKSkge1xyXG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxyXG4gIHZhbCxcclxuICByZW5kZXJcclxuKSB7XHJcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XHJcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XHJcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcclxuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaXNEZWYocmV0KSkge1xyXG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90IChcclxuICBuYW1lLFxyXG4gIGZhbGxiYWNrLFxyXG4gIHByb3BzLFxyXG4gIGJpbmRPYmplY3RcclxuKSB7XHJcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xyXG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcclxuICAgIHByb3BzID0gcHJvcHMgfHwge307XHJcbiAgICBpZiAoYmluZE9iamVjdCkge1xyXG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XHJcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXHJcbiAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxyXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXHJcbiAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xyXG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXHJcbiAgZXZlbnRLZXlDb2RlLFxyXG4gIGtleSxcclxuICBidWlsdEluQWxpYXNcclxuKSB7XHJcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xyXG4gICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxyXG4gIGRhdGEsXHJcbiAgdGFnLFxyXG4gIHZhbHVlLFxyXG4gIGFzUHJvcCxcclxuICBpc1N5bmNcclxuKSB7XHJcbiAgaWYgKHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaGFzaDtcclxuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcclxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxyXG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBoYXNoID0gZGF0YTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcclxuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxyXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcclxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcclxuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XHJcblxyXG4gICAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xyXG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcclxuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBkYXRhXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcclxuICBpbmRleCxcclxuICBpc0luRm9yXHJcbikge1xyXG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xyXG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxyXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cclxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcclxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxyXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcclxuICB9XHJcbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxyXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxyXG4gICAgdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xyXG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XHJcbiAgcmV0dXJuIHRyZWVcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXHJcbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxyXG4gKi9cclxuZnVuY3Rpb24gbWFya09uY2UgKFxyXG4gIHRyZWUsXHJcbiAgaW5kZXgsXHJcbiAga2V5XHJcbikge1xyXG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xyXG4gIHJldHVybiB0cmVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxyXG4gIHRyZWUsXHJcbiAga2V5LFxyXG4gIGlzT25jZVxyXG4pIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xyXG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xyXG4gIG5vZGUua2V5ID0ga2V5O1xyXG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcclxuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KG91cnMsIGV4aXN0aW5nKSA6IG91cnM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xyXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXHJcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcclxuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXHJcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xyXG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xyXG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xyXG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxyXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXHJcbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxyXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXHJcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xyXG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxyXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxyXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xyXG5cclxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxyXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcclxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XHJcblxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xyXG4gICAgfSwgdHJ1ZSk7XHJcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcclxuICAgIH0sIHRydWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcclxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XHJcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcclxuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xyXG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XHJcblxyXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcclxuICAgICAgLy8gaWYgdGhlIHBhcmVudCBkaWRuJ3QgdXBkYXRlLCB0aGUgc2xvdCBub2RlcyB3aWxsIGJlIHRoZSBvbmVzIGZyb21cclxuICAgICAgLy8gbGFzdCByZW5kZXIuIFRoZXkgbmVlZCB0byBiZSBjbG9uZWQgdG8gZW5zdXJlIFwiZnJlc2huZXNzXCIgZm9yIHRoaXMgcmVuZGVyLlxyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XHJcbiAgICAgICAgdmFyIHNsb3QgPSB2bS4kc2xvdHNba2V5XTtcclxuICAgICAgICBpZiAoc2xvdC5fcmVuZGVyZWQpIHtcclxuICAgICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXMoc2xvdCwgdHJ1ZSAvKiBkZWVwICovKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcclxuXHJcbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcclxuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XHJcbiAgICB9XHJcbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXHJcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cclxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcclxuICAgIC8vIHJlbmRlciBzZWxmXHJcbiAgICB2YXIgdm5vZGU7XHJcbiAgICB0cnkge1xyXG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXIgZnVuY3Rpb25cIik7XHJcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxyXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcclxuICAgICAgICAgID8gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKVxyXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcclxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXHJcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICAgIH1cclxuICAgIC8vIHNldCBwYXJlbnRcclxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcclxuICAgIHJldHVybiB2bm9kZVxyXG4gIH07XHJcblxyXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxyXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcclxuICAvLyBjb2RlIHNpemUuXHJcbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xyXG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcclxuICBWdWUucHJvdG90eXBlLl9zID0gdG9TdHJpbmc7XHJcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XHJcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XHJcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XHJcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcclxuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xyXG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xyXG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xyXG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XHJcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcclxuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcclxuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xyXG4gIFZ1ZS5wcm90b3R5cGUuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB1aWQkMSA9IDA7XHJcblxyXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xyXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIC8vIGEgdWlkXHJcbiAgICB2bS5fdWlkID0gdWlkJDErKztcclxuXHJcbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLWluaXQ6XCIgKyAodm0uX3VpZCk7XHJcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xyXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxyXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcclxuICAgIC8vIG1lcmdlIG9wdGlvbnNcclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XHJcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXHJcbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcclxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXHJcbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcclxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcclxuICAgICAgICBvcHRpb25zIHx8IHt9LFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaW5pdFByb3h5KHZtKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xyXG4gICAgfVxyXG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxyXG4gICAgdm0uX3NlbGYgPSB2bTtcclxuICAgIGluaXRMaWZlY3ljbGUodm0pO1xyXG4gICAgaW5pdEV2ZW50cyh2bSk7XHJcbiAgICBpbml0UmVuZGVyKHZtKTtcclxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XHJcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xyXG4gICAgaW5pdFN0YXRlKHZtKTtcclxuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcclxuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XHJcbiAgICAgIG1hcmsoZW5kVGFnKTtcclxuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xyXG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcclxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcclxuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxyXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcclxuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xyXG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcclxuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xyXG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcclxuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XHJcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xyXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xyXG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcclxuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XHJcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcclxuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xyXG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xyXG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XHJcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxyXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXHJcbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xyXG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXHJcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xyXG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xyXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XHJcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcclxuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xyXG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gb3B0aW9uc1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XHJcbiAgdmFyIG1vZGlmaWVkO1xyXG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XHJcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xyXG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XHJcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xyXG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xyXG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cclxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbW9kaWZpZWRcclxufVxyXG5cclxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcclxuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxyXG4gIC8vIGJldHdlZW4gbWVyZ2VzXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XHJcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcclxuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XHJcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbGF0ZXN0XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcclxuICApIHtcclxuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcclxuICB9XHJcbiAgdGhpcy5faW5pdChvcHRpb25zKTtcclxufVxyXG5cclxuaW5pdE1peGluKFZ1ZSQzKTtcclxuc3RhdGVNaXhpbihWdWUkMyk7XHJcbmV2ZW50c01peGluKFZ1ZSQzKTtcclxubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xyXG5yZW5kZXJNaXhpbihWdWUkMyk7XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xyXG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XHJcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcclxuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXHJcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcclxuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XHJcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XHJcbiAgLyoqXHJcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXHJcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxyXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxyXG4gICAqL1xyXG4gIFZ1ZS5jaWQgPSAwO1xyXG4gIHZhciBjaWQgPSAxO1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxyXG4gICAqL1xyXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xyXG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XHJcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xyXG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XHJcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xyXG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXHJcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXHJcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xyXG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcclxuICAgIFN1Yi5jaWQgPSBjaWQrKztcclxuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxyXG4gICAgICBTdXBlci5vcHRpb25zLFxyXG4gICAgICBleHRlbmRPcHRpb25zXHJcbiAgICApO1xyXG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XHJcblxyXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cclxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXHJcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXHJcbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcclxuICAgIH1cclxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xyXG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxyXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcclxuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xyXG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcclxuXHJcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXHJcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXHJcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xyXG4gICAgfSk7XHJcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXHJcbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxyXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxyXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XHJcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XHJcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xyXG5cclxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXHJcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcclxuICAgIHJldHVybiBTdWJcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xyXG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcclxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcclxuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XHJcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XHJcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXHJcbiAgICovXHJcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxyXG4gICAgICBpZCxcclxuICAgICAgZGVmaW5pdGlvblxyXG4gICAgKSB7XHJcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcclxuICAgICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcclxuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xyXG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xyXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xyXG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xyXG5cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xyXG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxyXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGN1cnJlbnQsIGZpbHRlcikge1xyXG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xyXG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xyXG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcclxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XHJcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcclxuICAgICAgICBpZiAoY2FjaGVkTm9kZSAhPT0gY3VycmVudCkge1xyXG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xyXG4gIGlmICh2bm9kZSkge1xyXG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBLZWVwQWxpdmUgPSB7XHJcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxyXG4gIGFic3RyYWN0OiB0cnVlLFxyXG5cclxuICBwcm9wczoge1xyXG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxyXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XHJcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICB9LFxyXG5cclxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XHJcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgd2F0Y2g6IHtcclxuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xyXG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcclxuICAgIH0sXHJcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcclxuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcclxuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XHJcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xyXG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXHJcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcclxuICAgICAgaWYgKG5hbWUgJiYgKFxyXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcclxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcclxuICAgICAgKSkge1xyXG4gICAgICAgIHJldHVybiB2bm9kZVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxyXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXHJcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxyXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxyXG4gICAgICAgIDogdm5vZGUua2V5O1xyXG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XHJcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XHJcbiAgICAgIH1cclxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlXHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xyXG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xyXG4gIC8vIGNvbmZpZ1xyXG4gIHZhciBjb25maWdEZWYgPSB7fTtcclxuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xyXG5cclxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cclxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cclxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxyXG4gIFZ1ZS51dGlsID0ge1xyXG4gICAgd2Fybjogd2FybixcclxuICAgIGV4dGVuZDogZXh0ZW5kLFxyXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXHJcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcclxuICB9O1xyXG5cclxuICBWdWUuc2V0ID0gc2V0O1xyXG4gIFZ1ZS5kZWxldGUgPSBkZWw7XHJcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XHJcblxyXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcclxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cclxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcclxuXHJcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcclxuXHJcbiAgaW5pdFVzZShWdWUpO1xyXG4gIGluaXRNaXhpbiQxKFZ1ZSk7XHJcbiAgaW5pdEV4dGVuZChWdWUpO1xyXG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xyXG59XHJcblxyXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XHJcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcclxuICB9XHJcbn0pO1xyXG5cclxuVnVlJDMudmVyc2lvbiA9ICcyLjQuNCc7XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxyXG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cclxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcclxuXHJcbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcclxudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xyXG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XHJcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxyXG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XHJcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXHJcbiAgKVxyXG59O1xyXG5cclxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcclxuXHJcbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcclxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcclxuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xyXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xyXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xyXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xyXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xyXG4pO1xyXG5cclxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcblxyXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xyXG59O1xyXG5cclxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXHJcbn07XHJcblxyXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xyXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xyXG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcclxuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xyXG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xyXG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xyXG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xyXG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXHJcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXHJcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXHJcbiAgICAgIDogcGFyZW50LmNsYXNzXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXHJcbiAgc3RhdGljQ2xhc3MsXHJcbiAgZHluYW1pY0NsYXNzXHJcbikge1xyXG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xyXG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gJydcclxufVxyXG5cclxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXHJcbiAgfVxyXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdmFsdWVcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gJydcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIHZhciBzdHJpbmdpZmllZDtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcclxuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XHJcbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlW2tleV0pIHtcclxuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XHJcbiAgICAgIHJlcyArPSBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgbmFtZXNwYWNlTWFwID0ge1xyXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcclxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcclxufTtcclxuXHJcbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxyXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcclxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xyXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcclxuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xyXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcclxuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXHJcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xyXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xyXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xyXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXHJcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXHJcbik7XHJcblxyXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcclxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cclxudmFyIGlzU1ZHID0gbWFrZU1hcChcclxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xyXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcclxuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXHJcbiAgdHJ1ZVxyXG4pO1xyXG5cclxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcclxuXHJcbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xyXG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xyXG4gIGlmIChpc1NWRyh0YWcpKSB7XHJcbiAgICByZXR1cm4gJ3N2ZydcclxuICB9XHJcbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXHJcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xyXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xyXG4gICAgcmV0dXJuICdtYXRoJ1xyXG4gIH1cclxufVxyXG5cclxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoIWluQnJvd3Nlcikge1xyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxyXG4gIH1cclxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xyXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxyXG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXHJcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XHJcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcclxuICAgICkpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcclxuICB9XHJcbn1cclxuXHJcbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcclxuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XHJcbiAgICBpZiAoIXNlbGVjdGVkKSB7XHJcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlbGVjdGVkXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBlbFxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XHJcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XHJcbiAgICByZXR1cm4gZWxtXHJcbiAgfVxyXG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XHJcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XHJcbiAgfVxyXG4gIHJldHVybiBlbG1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcclxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xyXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XHJcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xyXG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcclxuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xyXG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcclxufVxyXG5cclxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xyXG59XHJcblxyXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xyXG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XHJcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xyXG59XHJcblxyXG5cclxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcclxuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXHJcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXHJcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxyXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXHJcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXHJcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxyXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcclxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxyXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcclxuXHR0YWdOYW1lOiB0YWdOYW1lLFxyXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcclxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxyXG59KTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHJlZiA9IHtcclxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcclxuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcclxuICB9LFxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcclxuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xyXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xyXG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XHJcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xyXG4gIGlmICgha2V5KSB7IHJldHVybiB9XHJcblxyXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XHJcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcclxuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xyXG4gIGlmIChpc1JlbW92YWwpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcclxuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcclxuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcclxuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xyXG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XHJcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVmc1trZXldID0gcmVmO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxyXG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICpcclxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXHJcbiAqXHJcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcclxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXHJcbiAqL1xyXG5cclxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcclxuXHJcbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xyXG5cclxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXHJcbiAgICAgIChcclxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcclxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcclxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXHJcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxyXG4gICAgICApIHx8IChcclxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXHJcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXHJcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcclxuICAgICAgKVxyXG4gICAgKVxyXG4gIClcclxufVxyXG5cclxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xyXG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgdmFyIGk7XHJcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcclxuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xyXG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xyXG4gIHZhciBpLCBrZXk7XHJcbiAgdmFyIG1hcCA9IHt9O1xyXG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XHJcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XHJcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cclxuICB9XHJcbiAgcmV0dXJuIG1hcFxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XHJcbiAgdmFyIGksIGo7XHJcbiAgdmFyIGNicyA9IHt9O1xyXG5cclxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcclxuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBjYnNbaG9va3NbaV1dID0gW107XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xyXG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XHJcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xyXG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xyXG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcclxuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xyXG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xyXG4gICAgcmV0dXJuIHJlbW92ZSQkMVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcclxuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xyXG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XHJcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xyXG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGluUHJlID0gMDtcclxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcclxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXHJcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XHJcbiAgICBpZiAoaXNEZWYodGFnKSkge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XHJcbiAgICAgICAgICBpblByZSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAhaW5QcmUgJiZcclxuICAgICAgICAgICF2bm9kZS5ucyAmJlxyXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxyXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xyXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXHJcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXHJcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXHJcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxyXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xyXG4gICAgICBzZXRTY29wZSh2bm9kZSk7XHJcblxyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAge1xyXG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcclxuICAgICAgICBpblByZS0tO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XHJcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcclxuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcclxuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xyXG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xyXG4gICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcclxuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxyXG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcclxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXHJcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXHJcbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcclxuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xyXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XHJcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XHJcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XHJcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICBzZXRTY29wZSh2bm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cclxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxyXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXHJcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cclxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcclxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxyXG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cclxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcclxuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxyXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcclxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xyXG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcclxuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcclxuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xyXG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcclxuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XHJcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xyXG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XHJcbiAgICB9XHJcbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxyXG4gICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cclxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXHJcbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcclxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXHJcbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xyXG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XHJcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XHJcbiAgICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XHJcbiAgICAgIH1cclxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXHJcbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxyXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXHJcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxyXG4gICAgKSB7XHJcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcclxuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XHJcbiAgICB2YXIgaSwgajtcclxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cclxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XHJcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XHJcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XHJcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcclxuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xyXG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XHJcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XHJcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXHJcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcclxuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XHJcbiAgICAgIGlmIChpc0RlZihybSkpIHtcclxuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcclxuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XHJcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xyXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcclxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XHJcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcclxuICAgICAgICBpKHZub2RlLCBybSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcm0oKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcclxuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XHJcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xyXG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xyXG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcclxuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xyXG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcclxuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XHJcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcclxuXHJcbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cclxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcclxuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXHJcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xyXG5cclxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XHJcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcclxuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcclxuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcclxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xyXG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xyXG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xyXG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xyXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcclxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcclxuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XHJcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XHJcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XHJcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XHJcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XHJcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxyXG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXHJcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxyXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxyXG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcclxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xyXG4gICAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXHJcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcclxuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcclxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XHJcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcclxuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcclxuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xyXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcclxuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xyXG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xyXG5cclxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xyXG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cclxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxyXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXHJcbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxyXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcclxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxyXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxyXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcclxuICAgICkge1xyXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcclxuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xyXG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxyXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cclxuICAgIH1cclxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XHJcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XHJcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxyXG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xyXG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XHJcbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XHJcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XHJcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XHJcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xyXG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXHJcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxyXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xyXG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XHJcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cclxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xyXG5cclxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxyXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xyXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcclxuICAgICAgdm5vZGUuZWxtID0gZWxtO1xyXG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm5vZGUuZWxtID0gZWxtO1xyXG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcclxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cclxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cclxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0RlZih0YWcpKSB7XHJcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcclxuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cclxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXHJcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XHJcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgIWJhaWxlZFxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xyXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgIWJhaWxlZFxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xyXG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcclxuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcclxuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxyXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxyXG4gICAgICApXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcclxuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xyXG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcclxuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcclxuXHJcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcclxuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxyXG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XHJcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcclxuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XHJcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXHJcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcclxuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XHJcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxyXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cclxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XHJcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XHJcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcclxuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XHJcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXHJcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xyXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcclxuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXHJcbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxyXG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XHJcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcclxuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcclxuICAgICAgICBjcmVhdGVFbG0oXHJcbiAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcclxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXHJcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcclxuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXHJcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXHJcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cclxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxyXG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xyXG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcclxuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcclxuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xyXG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAvLyAjNjUxM1xyXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXHJcbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxyXG4gICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xyXG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xyXG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XHJcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xyXG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xyXG4gICAgcmV0dXJuIHZub2RlLmVsbVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgZGlyZWN0aXZlcyA9IHtcclxuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxyXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XHJcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XHJcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xyXG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xyXG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XHJcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcclxuXHJcbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XHJcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XHJcblxyXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xyXG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcclxuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcclxuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcclxuICAgIGlmICghb2xkRGlyKSB7XHJcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcclxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xyXG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcclxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xyXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XHJcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xyXG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xyXG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGlzQ3JlYXRlKSB7XHJcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYWxsSW5zZXJ0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XHJcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWlzQ3JlYXRlKSB7XHJcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XHJcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XHJcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxyXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcclxuICBkaXJzLFxyXG4gIHZtXHJcbikge1xyXG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGlmICghZGlycykge1xyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH1cclxuICB2YXIgaSwgZGlyO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBkaXIgPSBkaXJzW2ldO1xyXG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XHJcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcclxuICAgIH1cclxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xyXG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XHJcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xyXG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcclxuICBpZiAoZm4pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBiYXNlTW9kdWxlcyA9IFtcclxuICByZWYsXHJcbiAgZGlyZWN0aXZlc1xyXG5dO1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBrZXksIGN1ciwgb2xkO1xyXG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XHJcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcclxuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xyXG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxyXG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XHJcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcclxuICB9XHJcblxyXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XHJcbiAgICBjdXIgPSBhdHRyc1trZXldO1xyXG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcclxuICAgIGlmIChvbGQgIT09IGN1cikge1xyXG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcclxuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XHJcbiAgfVxyXG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XHJcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xyXG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XHJcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcclxuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XHJcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xyXG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcclxuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXHJcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxyXG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XHJcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxyXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xyXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xyXG4gICAgICAgID8gJ3RydWUnXHJcbiAgICAgICAgOiBrZXk7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xyXG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcclxuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xyXG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XHJcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgYXR0cnMgPSB7XHJcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcclxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICB2YXIgZWwgPSB2bm9kZS5lbG07XHJcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcclxuICBpZiAoXHJcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXHJcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcclxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXHJcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxyXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcclxuICAgICAgKVxyXG4gICAgKVxyXG4gICkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XHJcblxyXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcclxuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xyXG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XHJcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcclxuICB9XHJcblxyXG4gIC8vIHNldCB0aGUgY2xhc3NcclxuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcclxuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XHJcbiAgfVxyXG59XHJcblxyXG52YXIga2xhc3MgPSB7XHJcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcclxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcclxuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcclxuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcclxuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xyXG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XHJcbiAgdmFyIGN1cmx5ID0gMDtcclxuICB2YXIgc3F1YXJlID0gMDtcclxuICB2YXIgcGFyZW4gPSAwO1xyXG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xyXG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBwcmV2ID0gYztcclxuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcclxuICAgIGlmIChpblNpbmdsZSkge1xyXG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cclxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcclxuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XHJcbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcclxuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cclxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xyXG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXHJcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxyXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcclxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXHJcbiAgICApIHtcclxuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cclxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcclxuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXHJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xyXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcclxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXHJcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxyXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcclxuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXHJcbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXHJcbiAgICAgICAgdmFyIGogPSBpIC0gMTtcclxuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xyXG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXHJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcclxuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xyXG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xyXG4gICAgcHVzaEZpbHRlcigpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XHJcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xyXG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgfVxyXG5cclxuICBpZiAoZmlsdGVycykge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXhwcmVzc2lvblxyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xyXG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcclxuICBpZiAoaSA8IDApIHtcclxuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXHJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcclxuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xyXG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxyXG4gIG1vZHVsZXMsXHJcbiAga2V5XHJcbikge1xyXG4gIHJldHVybiBtb2R1bGVzXHJcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcclxuICAgIDogW11cclxufVxyXG5cclxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcclxuICBlbCxcclxuICBuYW1lLFxyXG4gIHJhd05hbWUsXHJcbiAgdmFsdWUsXHJcbiAgYXJnLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcclxuICBlbCxcclxuICBuYW1lLFxyXG4gIHZhbHVlLFxyXG4gIG1vZGlmaWVycyxcclxuICBpbXBvcnRhbnQsXHJcbiAgd2FyblxyXG4pIHtcclxuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoXHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcclxuICAgIG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxyXG4gICkge1xyXG4gICAgd2FybihcclxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcclxuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXHJcbiAgICApO1xyXG4gIH1cclxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXHJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMuY2FwdHVyZSkge1xyXG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xyXG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXHJcbiAgfVxyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcclxuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcclxuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnBhc3NpdmUpIHtcclxuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcclxuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXHJcbiAgfVxyXG4gIHZhciBldmVudHM7XHJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XHJcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcclxuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcclxuICB9XHJcbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcclxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XHJcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcclxuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XHJcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcclxuICB9IGVsc2Uge1xyXG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcclxuICBlbCxcclxuICBuYW1lLFxyXG4gIGdldFN0YXRpY1xyXG4pIHtcclxuICB2YXIgZHluYW1pY1ZhbHVlID1cclxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XHJcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcclxuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcclxuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxyXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xyXG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XHJcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xyXG4gIHZhciB2YWw7XHJcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xyXG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB2YWxcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxyXG4gIGVsLFxyXG4gIHZhbHVlLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xyXG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xyXG4gIHZhciB0cmltID0gcmVmLnRyaW07XHJcblxyXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XHJcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XHJcbiAgaWYgKHRyaW0pIHtcclxuICAgIHZhbHVlRXhwcmVzc2lvbiA9XHJcbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXHJcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcclxuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XHJcbiAgfVxyXG4gIGlmIChudW1iZXIpIHtcclxuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcclxuICB9XHJcbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcclxuXHJcbiAgZWwubW9kZWwgPSB7XHJcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXHJcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcclxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXHJcbiAgdmFsdWUsXHJcbiAgYXNzaWdubWVudFxyXG4pIHtcclxuICB2YXIgbW9kZWxScyA9IHBhcnNlTW9kZWwodmFsdWUpO1xyXG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAobW9kZWxScy5leHApICsgXCIsIFwiICsgKG1vZGVsUnMuaWR4KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXHJcbiAqXHJcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxyXG4gKlxyXG4gKiAtIHRlc3RcclxuICogLSB0ZXN0W2lkeF1cclxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXHJcbiAqIC0gdGVzdFtcImFcIl1baWR4XVxyXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cclxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXHJcbiAqXHJcbiAqL1xyXG5cclxudmFyIGxlbjtcclxudmFyIHN0cjtcclxudmFyIGNocjtcclxudmFyIGluZGV4JDE7XHJcbnZhciBleHByZXNzaW9uUG9zO1xyXG52YXIgZXhwcmVzc2lvbkVuZFBvcztcclxuXHJcbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xyXG4gIHN0ciA9IHZhbDtcclxuICBsZW4gPSBzdHIubGVuZ3RoO1xyXG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XHJcblxyXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGV4cDogdmFsLFxyXG4gICAgICBpZHg6IG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdoaWxlICghZW9mKCkpIHtcclxuICAgIGNociA9IG5leHQoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xyXG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xyXG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcclxuICAgICAgcGFyc2VCcmFja2V0KGNocik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxyXG4gICAgaWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbmV4dCAoKSB7XHJcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcclxufVxyXG5cclxuZnVuY3Rpb24gZW9mICgpIHtcclxuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cclxufVxyXG5cclxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XHJcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4MjdcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcclxuICB2YXIgaW5CcmFja2V0ID0gMTtcclxuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcclxuICB3aGlsZSAoIWVvZigpKSB7XHJcbiAgICBjaHIgPSBuZXh0KCk7XHJcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XHJcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XHJcbiAgICAgIGNvbnRpbnVlXHJcbiAgICB9XHJcbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XHJcbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XHJcbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XHJcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xyXG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcclxuICB3aGlsZSAoIWVvZigpKSB7XHJcbiAgICBjaHIgPSBuZXh0KCk7XHJcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgd2FybiQxO1xyXG5cclxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxyXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxyXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcclxudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XHJcblxyXG5mdW5jdGlvbiBtb2RlbCAoXHJcbiAgZWwsXHJcbiAgZGlyLFxyXG4gIF93YXJuXHJcbikge1xyXG4gIHdhcm4kMSA9IF93YXJuO1xyXG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcclxuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcclxuICB2YXIgdGFnID0gZWwudGFnO1xyXG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xyXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xyXG4gICAgICB3YXJuJDEoXHJcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xyXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xyXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cclxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xyXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xyXG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XHJcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XHJcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcclxuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgd2FybiQxKFxyXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcclxuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcclxuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xyXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXHJcbiAgZWwsXHJcbiAgdmFsdWUsXHJcbiAgbW9kaWZpZXJzXHJcbikge1xyXG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcclxuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcclxuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcclxuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcclxuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXHJcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcclxuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXHJcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXHJcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxyXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxyXG4gICAgICApXHJcbiAgKTtcclxuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTixcclxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xyXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXHJcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xyXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXHJcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXHJcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xyXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdChbJCR2XSkpfVwiICtcclxuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xyXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxyXG4gICAgbnVsbCwgdHJ1ZVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxyXG4gICAgZWwsXHJcbiAgICB2YWx1ZSxcclxuICAgIG1vZGlmaWVyc1xyXG4pIHtcclxuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XHJcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XHJcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XHJcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xyXG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblNlbGVjdCAoXHJcbiAgICBlbCxcclxuICAgIHZhbHVlLFxyXG4gICAgbW9kaWZpZXJzXHJcbikge1xyXG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcclxuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXHJcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xyXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcclxuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcclxuXHJcbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcclxuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XHJcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xyXG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcclxuICBlbCxcclxuICB2YWx1ZSxcclxuICBtb2RpZmllcnNcclxuKSB7XHJcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xyXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XHJcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcclxuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcclxuICB2YXIgdHJpbSA9IHJlZi50cmltO1xyXG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XHJcbiAgdmFyIGV2ZW50ID0gbGF6eVxyXG4gICAgPyAnY2hhbmdlJ1xyXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXHJcbiAgICAgID8gUkFOR0VfVE9LRU5cclxuICAgICAgOiAnaW5wdXQnO1xyXG5cclxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xyXG4gIGlmICh0cmltKSB7XHJcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XHJcbiAgfVxyXG4gIGlmIChudW1iZXIpIHtcclxuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcclxuICB9XHJcblxyXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XHJcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XHJcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xyXG4gIH1cclxuXHJcbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xyXG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcclxuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcclxuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cclxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxyXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXHJcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcclxuICB2YXIgZXZlbnQ7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcclxuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcclxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcclxuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XHJcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xyXG4gIH1cclxuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xyXG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXHJcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xyXG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcclxuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XHJcbiAgfVxyXG59XHJcblxyXG52YXIgdGFyZ2V0JDE7XHJcblxyXG5mdW5jdGlvbiBhZGQkMSAoXHJcbiAgZXZlbnQsXHJcbiAgaGFuZGxlcixcclxuICBvbmNlJCQxLFxyXG4gIGNhcHR1cmUsXHJcbiAgcGFzc2l2ZVxyXG4pIHtcclxuICBpZiAob25jZSQkMSkge1xyXG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xyXG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcclxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcclxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXHJcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcclxuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICBldmVudCxcclxuICAgIGhhbmRsZXIsXHJcbiAgICBzdXBwb3J0c1Bhc3NpdmVcclxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxyXG4gICAgICA6IGNhcHR1cmVcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmUkMiAoXHJcbiAgZXZlbnQsXHJcbiAgaGFuZGxlcixcclxuICBjYXB0dXJlLFxyXG4gIF90YXJnZXRcclxuKSB7XHJcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xyXG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XHJcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XHJcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcclxuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xyXG59XHJcblxyXG52YXIgZXZlbnRzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxyXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIGtleSwgY3VyO1xyXG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XHJcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcclxuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xyXG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxyXG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XHJcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcclxuICB9XHJcblxyXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XHJcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xyXG4gICAgICBlbG1ba2V5XSA9ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKGtleSBpbiBwcm9wcykge1xyXG4gICAgY3VyID0gcHJvcHNba2V5XTtcclxuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxyXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcclxuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXHJcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcclxuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cclxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxyXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXHJcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XHJcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxyXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcclxuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcclxuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsbVtrZXldID0gY3VyO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXHJcblxyXG5cclxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxyXG4gIGVsbSxcclxuICB2bm9kZSxcclxuICBjaGVja1ZhbFxyXG4pIHtcclxuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcclxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcclxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcclxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXHJcbiAgKSlcclxufVxyXG5cclxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xyXG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcclxuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcclxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XHJcbiAgLy8gIzYxNTdcclxuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcclxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxyXG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcclxufVxyXG5cclxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XHJcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xyXG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxyXG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHtcclxuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcclxuICB9XHJcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLnRyaW0pIHtcclxuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcclxufVxyXG5cclxudmFyIGRvbVByb3BzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXHJcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xyXG59O1xyXG5cclxuLyogICovXHJcblxyXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcclxuICB2YXIgcmVzID0ge307XHJcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xyXG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XHJcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICBpZiAoaXRlbSkge1xyXG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XHJcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcmVzXHJcbn0pO1xyXG5cclxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XHJcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xyXG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxyXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XHJcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcclxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxyXG4gICAgOiBzdHlsZVxyXG59XHJcblxyXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xyXG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxyXG4gIH1cclxuICByZXR1cm4gYmluZGluZ1N0eWxlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXHJcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcclxuICB2YXIgcmVzID0ge307XHJcbiAgdmFyIHN0eWxlRGF0YTtcclxuXHJcbiAgaWYgKGNoZWNrQ2hpbGQpIHtcclxuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcclxuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xyXG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xyXG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcclxuICB9XHJcblxyXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XHJcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XHJcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcclxuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xyXG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcclxudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XHJcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cclxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxyXG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcclxuXHJcbnZhciBlbXB0eVN0eWxlO1xyXG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XHJcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xyXG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xyXG4gICAgcmV0dXJuIHByb3BcclxuICB9XHJcbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcclxuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcclxuICAgICAgcmV0dXJuIG5hbWVcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XHJcblxyXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcclxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxyXG4gICkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgY3VyLCBuYW1lO1xyXG4gIHZhciBlbCA9IHZub2RlLmVsbTtcclxuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xyXG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xyXG5cclxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxyXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcclxuXHJcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xyXG5cclxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXHJcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xyXG4gIC8vIHRvIG11dGF0ZSBpdC5cclxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcclxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcclxuICAgIDogc3R5bGU7XHJcblxyXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcclxuXHJcbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XHJcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcclxuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcclxuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xyXG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcclxuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcclxuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgc3R5bGUgPSB7XHJcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcclxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cclxuICogU1ZHIGVsZW1lbnRzIGluIElFXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XHJcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xyXG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxyXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcclxuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xyXG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcclxuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcclxuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xyXG4gICAgfVxyXG4gICAgY3VyID0gY3VyLnRyaW0oKTtcclxuICAgIGlmIChjdXIpIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcclxuICBpZiAoIWRlZiQkMSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcclxuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XHJcbiAgICB9XHJcbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXHJcbiAgfVxyXG59XHJcblxyXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcclxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxyXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcclxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcclxudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcclxuXHJcbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcclxudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xyXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xyXG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xyXG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcclxuaWYgKGhhc1RyYW5zaXRpb24pIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcclxuICApIHtcclxuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xyXG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xyXG4gIH1cclxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XHJcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xyXG4gIH1cclxufVxyXG5cclxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXHJcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcclxuICA6IHNldFRpbWVvdXQ7XHJcblxyXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XHJcbiAgcmFmKGZ1bmN0aW9uICgpIHtcclxuICAgIHJhZihmbik7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xyXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xyXG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XHJcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XHJcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xyXG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XHJcbiAgfVxyXG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxyXG4gIGVsLFxyXG4gIGV4cGVjdGVkVHlwZSxcclxuICBjYlxyXG4pIHtcclxuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XHJcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcclxuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xyXG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xyXG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XHJcbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xyXG4gIHZhciBlbmRlZCA9IDA7XHJcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcclxuICAgIGNiKCk7XHJcbiAgfTtcclxuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xyXG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcclxuICAgICAgICBlbmQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcclxuICAgICAgZW5kKCk7XHJcbiAgICB9XHJcbiAgfSwgdGltZW91dCArIDEpO1xyXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcclxufVxyXG5cclxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcclxuXHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XHJcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xyXG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XHJcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcclxuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcclxuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcclxuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xyXG5cclxuICB2YXIgdHlwZTtcclxuICB2YXIgdGltZW91dCA9IDA7XHJcbiAgdmFyIHByb3BDb3VudCA9IDA7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xyXG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XHJcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcclxuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcclxuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XHJcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XHJcbiAgICB0eXBlID0gdGltZW91dCA+IDBcclxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICA6IG51bGw7XHJcbiAgICBwcm9wQ291bnQgPSB0eXBlXHJcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxyXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgOiAwO1xyXG4gIH1cclxuICB2YXIgaGFzVHJhbnNmb3JtID1cclxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcclxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiB0eXBlLFxyXG4gICAgdGltZW91dDogdGltZW91dCxcclxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxyXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcclxuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxyXG4gIH0pKVxyXG59XHJcblxyXG5mdW5jdGlvbiB0b01zIChzKSB7XHJcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XHJcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG5cclxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xyXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcclxuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICBlbC5fbGVhdmVDYigpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xyXG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xyXG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xyXG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xyXG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcclxuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcclxuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xyXG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xyXG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XHJcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcclxuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xyXG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xyXG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XHJcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xyXG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcclxuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xyXG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcclxuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xyXG5cclxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXHJcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXHJcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcclxuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cclxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xyXG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcclxuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XHJcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcclxuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xyXG4gIH1cclxuXHJcbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xyXG5cclxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcclxuICAgID8gYXBwZWFyQ2xhc3NcclxuICAgIDogZW50ZXJDbGFzcztcclxuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xyXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xyXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xyXG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xyXG4gICAgPyBhcHBlYXJUb0NsYXNzXHJcbiAgICA6IGVudGVyVG9DbGFzcztcclxuXHJcbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXHJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXHJcbiAgICA6IGJlZm9yZUVudGVyO1xyXG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxyXG4gICAgOiBlbnRlcjtcclxuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcclxuICAgIDogYWZ0ZXJFbnRlcjtcclxuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcclxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XHJcblxyXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcclxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxyXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXHJcbiAgICAgIDogZHVyYXRpb25cclxuICApO1xyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xyXG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcclxuICB9XHJcblxyXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XHJcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XHJcblxyXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xyXG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcclxuICAgIH1cclxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcclxuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xyXG4gICAgICB9XHJcbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xyXG4gICAgfVxyXG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xyXG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcclxuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcclxuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXHJcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcclxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcclxuICAgICAgKSB7XHJcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XHJcbiAgICAgIH1cclxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXHJcbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XHJcbiAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XHJcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcclxuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XHJcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XHJcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XHJcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xyXG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XHJcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgIGNiKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XHJcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG5cclxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xyXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcclxuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICBlbC5fZW50ZXJDYigpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xyXG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XHJcbiAgICByZXR1cm4gcm0oKVxyXG4gIH1cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgY3NzID0gZGF0YS5jc3M7XHJcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XHJcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XHJcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xyXG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xyXG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XHJcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcclxuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcclxuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xyXG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xyXG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XHJcblxyXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XHJcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcclxuXHJcbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxyXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXHJcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcclxuICAgICAgOiBkdXJhdGlvblxyXG4gICk7XHJcblxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcclxuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XHJcbiAgfVxyXG5cclxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xyXG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgIH1cclxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcm0oKTtcclxuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcclxuICAgIH1cclxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcclxuICB9KTtcclxuXHJcbiAgaWYgKGRlbGF5TGVhdmUpIHtcclxuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xyXG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxyXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcclxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XHJcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcclxuICAgIH1cclxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcclxuICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XHJcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgY2IoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxyXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXHJcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXHJcbiAgICAgIHZub2RlLmNvbnRleHRcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXHJcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcclxuICAgICAgdm5vZGUuY29udGV4dFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcclxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXHJcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxyXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xyXG4gIGlmIChpc1VuZGVmKGZuKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xyXG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xyXG4gICAgLy8gaW52b2tlclxyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXHJcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcclxuICAgICAgICA/IGludm9rZXJGbnNbMF1cclxuICAgICAgICA6IGludm9rZXJGbnNcclxuICAgIClcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XHJcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgZW50ZXIodm5vZGUpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XHJcbiAgY3JlYXRlOiBfZW50ZXIsXHJcbiAgYWN0aXZhdGU6IF9lbnRlcixcclxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcm0oKTtcclxuICAgIH1cclxuICB9XHJcbn0gOiB7fTtcclxuXHJcbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXHJcbiAgYXR0cnMsXHJcbiAga2xhc3MsXHJcbiAgZXZlbnRzLFxyXG4gIGRvbVByb3BzLFxyXG4gIHN0eWxlLFxyXG4gIHRyYW5zaXRpb25cclxuXTtcclxuXHJcbi8qICAqL1xyXG5cclxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXHJcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXHJcbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XHJcblxyXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcclxuXHJcbi8qKlxyXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcclxuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cclxuICovXHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuaWYgKGlzSUU5KSB7XHJcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcclxuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciBtb2RlbCQxID0ge1xyXG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XHJcbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xyXG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xyXG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcclxuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXHJcbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxyXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcclxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xyXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoaXNJRTkpIHtcclxuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XHJcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcclxuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXHJcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cclxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXHJcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxyXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XHJcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xyXG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XHJcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcclxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxyXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXHJcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcclxuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XHJcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xyXG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XHJcbiAgICB9LCAwKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xyXG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XHJcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcclxuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcclxuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcclxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcclxuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIWlzTXVsdGlwbGUpIHtcclxuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xyXG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cclxuICAgID8gb3B0aW9uLl92YWx1ZVxyXG4gICAgOiBvcHRpb24udmFsdWVcclxufVxyXG5cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XHJcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xyXG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXHJcbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cclxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcclxuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XHJcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XHJcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxyXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcclxuICAgIDogdm5vZGVcclxufVxyXG5cclxudmFyIHNob3cgPSB7XHJcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcclxuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcclxuXHJcbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xyXG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcclxuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxyXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XHJcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xyXG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xyXG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xyXG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxyXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcclxuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XHJcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xyXG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcclxuICAgIGVsLFxyXG4gICAgYmluZGluZyxcclxuICAgIHZub2RlLFxyXG4gICAgb2xkVm5vZGUsXHJcbiAgICBpc0Rlc3Ryb3lcclxuICApIHtcclxuICAgIGlmICghaXNEZXN0cm95KSB7XHJcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcclxuICBtb2RlbDogbW9kZWwkMSxcclxuICBzaG93OiBzaG93XHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXHJcbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxyXG5cclxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcclxuICBuYW1lOiBTdHJpbmcsXHJcbiAgYXBwZWFyOiBCb29sZWFuLFxyXG4gIGNzczogQm9vbGVhbixcclxuICBtb2RlOiBTdHJpbmcsXHJcbiAgdHlwZTogU3RyaW5nLFxyXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcclxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXHJcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxyXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxyXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cclxufTtcclxuXHJcbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxyXG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxyXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XHJcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XHJcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdm5vZGVcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xyXG4gIHZhciBkYXRhID0ge307XHJcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xyXG4gIC8vIHByb3BzXHJcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XHJcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XHJcbiAgfVxyXG4gIC8vIGV2ZW50cy5cclxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcclxuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xyXG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xyXG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XHJcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xyXG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XHJcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XHJcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcclxuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcclxuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcclxufVxyXG5cclxudmFyIFRyYW5zaXRpb24gPSB7XHJcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxyXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXHJcbiAgYWJzdHJhY3Q6IHRydWUsXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcclxuICAgIGlmICghY2hpbGRyZW4pIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcclxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcclxuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxyXG4gICAgICAgIHRoaXMuJHBhcmVudFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xyXG5cclxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXHJcbiAgICApIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXHJcbiAgICAgICAgdGhpcy4kcGFyZW50XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XHJcblxyXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xyXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXHJcbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcclxuICAgICAgcmV0dXJuIHJhd0NoaWxkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXHJcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXHJcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNoaWxkKSB7XHJcbiAgICAgIHJldHVybiByYXdDaGlsZFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XHJcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcclxuICAgIH1cclxuXHJcbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxyXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xyXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxyXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xyXG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcclxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcclxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXHJcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xyXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcclxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxyXG4gICAgICAgIDogY2hpbGQua2V5O1xyXG5cclxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XHJcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcclxuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XHJcblxyXG4gICAgLy8gbWFyayB2LXNob3dcclxuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxyXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XHJcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBvbGRDaGlsZCAmJlxyXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXHJcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXHJcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpXHJcbiAgICApIHtcclxuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXHJcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcclxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XHJcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcclxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXHJcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXHJcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcclxuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XHJcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJhd0NoaWxkXHJcbiAgfVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXHJcbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxyXG5cclxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxyXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcclxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3NlczpcclxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXHJcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXHJcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXHJcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxyXG5cclxudmFyIHByb3BzID0gZXh0ZW5kKHtcclxuICB0YWc6IFN0cmluZyxcclxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xyXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xyXG5cclxuZGVsZXRlIHByb3BzLm1vZGU7XHJcblxyXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xyXG4gIHByb3BzOiBwcm9wcyxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcclxuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XHJcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcclxuICAgICAgaWYgKGMudGFnKSB7XHJcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XHJcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xyXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcclxuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgdmFyIGtlcHQgPSBbXTtcclxuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XHJcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xyXG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xyXG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XHJcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcclxuICB9LFxyXG5cclxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XHJcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXHJcbiAgICB0aGlzLl9fcGF0Y2hfXyhcclxuICAgICAgdGhpcy5fdm5vZGUsXHJcbiAgICAgIHRoaXMua2VwdCxcclxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xyXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcclxuICAgICk7XHJcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcclxuICB9LFxyXG5cclxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xyXG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcclxuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xyXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXHJcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcclxuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xyXG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcclxuXHJcbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cclxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcclxuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuXHJcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcclxuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcclxuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xyXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XHJcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XHJcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIG1ldGhvZHM6IHtcclxuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXHJcbiAgICAgIH1cclxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXHJcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xyXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXHJcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xyXG4gICAgICAvLyBpcyBhcHBsaWVkLlxyXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcclxuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xyXG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XHJcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xyXG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcclxuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XHJcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcclxuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcclxuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcclxuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcclxuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xyXG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xyXG4gIGlmIChkeCB8fCBkeSkge1xyXG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcclxuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XHJcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XHJcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xyXG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXHJcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xyXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcclxuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xyXG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcclxuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcclxuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xyXG5cclxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXHJcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XHJcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XHJcblxyXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXHJcblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XHJcblxyXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXHJcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXHJcbiAgZWwsXHJcbiAgaHlkcmF0aW5nXHJcbikge1xyXG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xyXG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxyXG59O1xyXG5cclxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xyXG4gICAgaWYgKGRldnRvb2xzKSB7XHJcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XHJcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcclxuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXHJcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xyXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXHJcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcclxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xyXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXHJcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxyXG4gICAgKTtcclxuICB9XHJcbn0sIDApO1xyXG5cclxuLyogICovXHJcblxyXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xyXG5mdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcclxuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgZGl2LmlubmVySFRNTCA9IFwiPGRpdiBhPVxcXCJcIiArIGNvbnRlbnQgKyBcIlxcXCIvPlwiO1xyXG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoZW5jb2RlZCkgPiAwXHJcbn1cclxuXHJcbi8vICMzNjYzXHJcbi8vIElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcclxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcclxudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xyXG5cclxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcclxuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XHJcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcclxuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXHJcbiAgdGV4dCxcclxuICBkZWxpbWl0ZXJzXHJcbikge1xyXG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xyXG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciB0b2tlbnMgPSBbXTtcclxuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcclxuICB2YXIgbWF0Y2gsIGluZGV4O1xyXG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xyXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcclxuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxyXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XHJcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcclxuICAgIH1cclxuICAgIC8vIHRhZyB0b2tlblxyXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xyXG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xyXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAgfVxyXG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgpKSk7XHJcbiAgfVxyXG4gIHJldHVybiB0b2tlbnMuam9pbignKycpXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcclxuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xyXG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XHJcbiAgICBpZiAoZXhwcmVzc2lvbikge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcclxuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcclxuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcclxuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoc3RhdGljQ2xhc3MpIHtcclxuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xyXG4gIH1cclxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XHJcbiAgaWYgKGNsYXNzQmluZGluZykge1xyXG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcclxuICB2YXIgZGF0YSA9ICcnO1xyXG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xyXG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xyXG4gIH1cclxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XHJcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVxyXG59XHJcblxyXG52YXIga2xhc3MkMSA9IHtcclxuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXHJcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcclxuICBnZW5EYXRhOiBnZW5EYXRhXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcclxuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcclxuICBpZiAoc3RhdGljU3R5bGUpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XHJcbiAgICAgIGlmIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcclxuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXHJcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcclxuICB9XHJcblxyXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcclxuICBpZiAoc3R5bGVCaW5kaW5nKSB7XHJcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XHJcbiAgdmFyIGRhdGEgPSAnJztcclxuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcclxuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcclxuICB9XHJcbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xyXG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVxyXG59XHJcblxyXG52YXIgc3R5bGUkMSA9IHtcclxuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXHJcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxyXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxyXG59O1xyXG5cclxudmFyIG1vZHVsZXMkMSA9IFtcclxuICBrbGFzcyQxLFxyXG4gIHN0eWxlJDFcclxuXTtcclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xyXG4gIGlmIChkaXIudmFsdWUpIHtcclxuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XHJcbiAgaWYgKGRpci52YWx1ZSkge1xyXG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcclxuICBtb2RlbDogbW9kZWwsXHJcbiAgdGV4dDogdGV4dCxcclxuICBodG1sOiBodG1sXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcclxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXHJcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xyXG4pO1xyXG5cclxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXHJcbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcclxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxyXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xyXG4pO1xyXG5cclxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xyXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcclxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxyXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXHJcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcclxuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXHJcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcclxuICAndGl0bGUsdHIsdHJhY2snXHJcbik7XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBiYXNlT3B0aW9ucyA9IHtcclxuICBleHBlY3RIVE1MOiB0cnVlLFxyXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcclxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXHJcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxyXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXHJcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxyXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXHJcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcclxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcclxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGRlY29kZXI7XHJcblxyXG52YXIgaGUgPSB7XHJcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcclxuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXHJcbiAqL1xyXG5cclxuLyohXHJcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcclxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XHJcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcclxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcclxuICovXHJcblxyXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcclxudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xyXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcclxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcclxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xyXG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xyXG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XHJcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XHJcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcclxudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcclxudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xyXG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XHJcblxyXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xyXG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcclxuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XHJcbn0pO1xyXG5cclxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXHJcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcclxudmFyIHJlQ2FjaGUgPSB7fTtcclxuXHJcbnZhciBkZWNvZGluZ01hcCA9IHtcclxuICAnJmx0Oyc6ICc8JyxcclxuICAnJmd0Oyc6ICc+JyxcclxuICAnJnF1b3Q7JzogJ1wiJyxcclxuICAnJmFtcDsnOiAnJicsXHJcbiAgJyYjMTA7JzogJ1xcbidcclxufTtcclxudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XHJcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwKTsvZztcclxuXHJcbi8vICM1OTkyXHJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcclxudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcclxuXHJcbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xyXG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcclxuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xyXG4gIHZhciBzdGFjayA9IFtdO1xyXG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xyXG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xyXG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xyXG4gIHZhciBpbmRleCA9IDA7XHJcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XHJcbiAgd2hpbGUgKGh0bWwpIHtcclxuICAgIGxhc3QgPSBodG1sO1xyXG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcclxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XHJcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XHJcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XHJcbiAgICAgICAgLy8gQ29tbWVudDpcclxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XHJcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcclxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcclxuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xyXG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEb2N0eXBlOlxyXG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xyXG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcclxuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRW5kIHRhZzpcclxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XHJcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XHJcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcclxuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcclxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcclxuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xyXG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XHJcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKGxhc3RUYWcsIGh0bWwpKSB7XHJcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XHJcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcclxuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcclxuICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcclxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxyXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxyXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxyXG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xyXG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cclxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcclxuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XHJcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XHJcbiAgICAgICAgdGV4dCA9IGh0bWw7XHJcbiAgICAgICAgaHRtbCA9ICcnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XHJcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XHJcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XHJcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcclxuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xyXG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcclxuICAgICAgICAgIHRleHQgPSB0ZXh0XHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XHJcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcclxuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJ1xyXG4gICAgICB9KTtcclxuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xyXG4gICAgICBodG1sID0gcmVzdCQxO1xyXG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XHJcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcclxuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXHJcbiAgcGFyc2VFbmRUYWcoKTtcclxuXHJcbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xyXG4gICAgaW5kZXggKz0gbjtcclxuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xyXG4gICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgIHZhciBtYXRjaCA9IHtcclxuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcclxuICAgICAgICBhdHRyczogW10sXHJcbiAgICAgICAgc3RhcnQ6IGluZGV4XHJcbiAgICAgIH07XHJcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIGVuZCwgYXR0cjtcclxuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XHJcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcclxuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xyXG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xyXG4gICAgICAgIHJldHVybiBtYXRjaFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcclxuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcclxuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcclxuXHJcbiAgICBpZiAoZXhwZWN0SFRNTCkge1xyXG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcclxuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XHJcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcclxuXHJcbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcclxuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XHJcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxyXG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcclxuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cclxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cclxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcclxuICAgICAgYXR0cnNbaV0gPSB7XHJcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcclxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcclxuICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc1xyXG4gICAgICAgIClcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVuYXJ5KSB7XHJcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xyXG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xyXG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XHJcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XHJcbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cclxuXHJcbiAgICBpZiAodGFnTmFtZSkge1xyXG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgaWYgKHRhZ05hbWUpIHtcclxuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcclxuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXHJcbiAgICAgIHBvcyA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBvcyA+PSAwKSB7XHJcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXHJcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxyXG4gICAgICAgICAgb3B0aW9ucy53YXJuXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBvcHRpb25zLndhcm4oXHJcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xyXG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xyXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XHJcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xyXG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xyXG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xyXG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcclxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcclxuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XHJcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcclxudmFyIGRpclJFID0gL152LXxeQHxeOi87XHJcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcclxudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XHJcblxyXG52YXIgYXJnUkUgPSAvOiguKikkLztcclxudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XHJcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XHJcblxyXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xyXG5cclxuLy8gY29uZmlndXJhYmxlIHN0YXRlXHJcbnZhciB3YXJuJDI7XHJcbnZhciBkZWxpbWl0ZXJzO1xyXG52YXIgdHJhbnNmb3JtcztcclxudmFyIHByZVRyYW5zZm9ybXM7XHJcbnZhciBwb3N0VHJhbnNmb3JtcztcclxudmFyIHBsYXRmb3JtSXNQcmVUYWc7XHJcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xyXG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XHJcblxyXG4vKipcclxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZSAoXHJcbiAgdGVtcGxhdGUsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XHJcblxyXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xyXG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xyXG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XHJcblxyXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcclxuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XHJcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XHJcblxyXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XHJcblxyXG4gIHZhciBzdGFjayA9IFtdO1xyXG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XHJcbiAgdmFyIHJvb3Q7XHJcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XHJcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xyXG4gIHZhciBpblByZSA9IGZhbHNlO1xyXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcclxuXHJcbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xyXG4gICAgaWYgKCF3YXJuZWQpIHtcclxuICAgICAgd2FybmVkID0gdHJ1ZTtcclxuICAgICAgd2FybiQyKG1zZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcclxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxyXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XHJcbiAgICAgIGluVlByZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XHJcbiAgICAgIGluUHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcclxuICAgIHdhcm46IHdhcm4kMixcclxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcclxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcclxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcclxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxyXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXHJcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XHJcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cclxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXHJcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XHJcblxyXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGVsZW1lbnQgPSB7XHJcbiAgICAgICAgdHlwZTogMSxcclxuICAgICAgICB0YWc6IHRhZyxcclxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxyXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxyXG4gICAgICAgIHBhcmVudDogY3VycmVudFBhcmVudCxcclxuICAgICAgICBjaGlsZHJlbjogW11cclxuICAgICAgfTtcclxuICAgICAgaWYgKG5zKSB7XHJcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcclxuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXHJcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXHJcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcclxuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFpblZQcmUpIHtcclxuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xyXG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XHJcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpblZQcmUpIHtcclxuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcclxuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XHJcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XHJcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcclxuXHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcclxuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XHJcblxyXG4gICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XHJcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XHJcbiAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXHJcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XHJcbiAgICAgICAgICAgIHdhcm5PbmNlKFxyXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcclxuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcclxuICAgICAgaWYgKCFyb290KSB7XHJcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxyXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XHJcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcclxuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcclxuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcclxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgd2Fybk9uY2UoXHJcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xyXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xyXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcclxuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XHJcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcclxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcclxuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIXVuYXJ5KSB7XHJcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXHJcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcclxuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcclxuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcclxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xyXG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XHJcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBwb3Agc3RhY2tcclxuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XHJcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgZW5kUHJlKGVsZW1lbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcclxuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChpc0lFICYmXHJcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcclxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxyXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcclxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xyXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xyXG4gICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgIHZhciBleHByZXNzaW9uO1xyXG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiAyLFxyXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xyXG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6IDMsXHJcbiAgICAgICAgICAgIHRleHQ6IHRleHRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQpIHtcclxuICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcclxuICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgaXNDb21tZW50OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiByb290XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XHJcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcclxuICAgIGVsLnByZSA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XHJcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xyXG4gIGlmIChsKSB7XHJcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGF0dHJzW2ldID0ge1xyXG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxyXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XHJcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXHJcbiAgICBlbC5wbGFpbiA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xyXG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xyXG4gIGlmIChleHApIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xyXG4gICAgfVxyXG4gICAgZWwua2V5ID0gZXhwO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcclxuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcclxuICBpZiAocmVmKSB7XHJcbiAgICBlbC5yZWYgPSByZWY7XHJcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcclxuICB2YXIgZXhwO1xyXG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XHJcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcclxuICAgIGlmICghaW5NYXRjaCkge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcclxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XHJcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xyXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcclxuICAgICAgZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcclxuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XHJcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XHJcbiAgICAgICAgZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsLmFsaWFzID0gYWxpYXM7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XHJcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XHJcbiAgaWYgKGV4cCkge1xyXG4gICAgZWwuaWYgPSBleHA7XHJcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xyXG4gICAgICBleHA6IGV4cCxcclxuICAgICAgYmxvY2s6IGVsXHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XHJcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcclxuICAgIGlmIChlbHNlaWYpIHtcclxuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xyXG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XHJcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xyXG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xyXG4gICAgICBleHA6IGVsLmVsc2VpZixcclxuICAgICAgYmxvY2s6IGVsXHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHdhcm4kMihcclxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXHJcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xyXG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XHJcbiAgICAgICAgd2FybiQyKFxyXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXHJcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgY2hpbGRyZW4ucG9wKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xyXG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XHJcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcclxuICB9XHJcbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XHJcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XHJcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xyXG4gICAgZWwub25jZSA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcclxuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcclxuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcclxuICAgICAgd2FybiQyKFxyXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXHJcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXHJcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xyXG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcclxuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xyXG4gICAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XHJcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgIGVsLnNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcclxuICB2YXIgYmluZGluZztcclxuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XHJcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xyXG4gIH1cclxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcclxuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcclxuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcclxuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xyXG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XHJcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XHJcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xyXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XHJcbiAgICAgIC8vIG1vZGlmaWVyc1xyXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcclxuICAgICAgaWYgKG1vZGlmaWVycykge1xyXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcclxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xyXG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcclxuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcclxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcclxuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xyXG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxyXG4gICAgICAgICAgICAgIGVsLFxyXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxyXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNQcm9wIHx8IChcclxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXHJcbiAgICAgICAgKSkge1xyXG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XHJcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XHJcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xyXG4gICAgICAgIC8vIHBhcnNlIGFyZ1xyXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xyXG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcclxuICAgICAgICBpZiAoYXJnKSB7XHJcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XHJcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xyXG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICB3YXJuJDIoXHJcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xyXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcclxuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXHJcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcclxuICB2YXIgcGFyZW50ID0gZWw7XHJcbiAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XHJcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcclxuICBpZiAobWF0Y2gpIHtcclxuICAgIHZhciByZXQgPSB7fTtcclxuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XHJcbiAgICByZXR1cm4gcmV0XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XHJcbiAgdmFyIG1hcCA9IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcclxuICAgICkge1xyXG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcclxuICAgIH1cclxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gbWFwXHJcbn1cclxuXHJcbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxyXG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XHJcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xyXG4gIHJldHVybiAoXHJcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcclxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcclxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcclxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcclxuICAgICkpXHJcbiAgKVxyXG59XHJcblxyXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcclxudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcclxuICB2YXIgcmVzID0gW107XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcclxuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcclxuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xyXG4gICAgICByZXMucHVzaChhdHRyKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xyXG4gIHZhciBfZWwgPSBlbDtcclxuICB3aGlsZSAoX2VsKSB7XHJcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XHJcbiAgICAgIHdhcm4kMihcclxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcclxuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXHJcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXHJcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXHJcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgX2VsID0gX2VsLnBhcmVudDtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGlzU3RhdGljS2V5O1xyXG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xyXG5cclxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcclxuXHJcbi8qKlxyXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxyXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXHJcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXHJcbiAqXHJcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxyXG4gKlxyXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXHJcbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcclxuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xyXG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxyXG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xyXG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcclxuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxyXG4gIG1hcmtTdGF0aWMkMShyb290KTtcclxuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXHJcbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XHJcbiAgcmV0dXJuIG1ha2VNYXAoXHJcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xyXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXHJcbiAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcclxuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xyXG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcclxuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xyXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xyXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xyXG4gICAgaWYgKFxyXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxyXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXHJcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcclxuICAgICkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcclxuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcclxuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcclxuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XHJcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcclxuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xyXG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XHJcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xyXG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcclxuICAgIH1cclxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XHJcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxyXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxyXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXHJcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xyXG4gICAgKSkge1xyXG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xyXG4gICAgICByZXR1cm5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcclxuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XHJcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xyXG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcclxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcclxuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcclxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXHJcbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxyXG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXHJcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcclxuICApKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xyXG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xyXG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuZm9yKSB7XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XHJcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcclxuXHJcbi8vIGtleUNvZGUgYWxpYXNlc1xyXG52YXIga2V5Q29kZXMgPSB7XHJcbiAgZXNjOiAyNyxcclxuICB0YWI6IDksXHJcbiAgZW50ZXI6IDEzLFxyXG4gIHNwYWNlOiAzMixcclxuICB1cDogMzgsXHJcbiAgbGVmdDogMzcsXHJcbiAgcmlnaHQ6IDM5LFxyXG4gIGRvd246IDQwLFxyXG4gICdkZWxldGUnOiBbOCwgNDZdXHJcbn07XHJcblxyXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXHJcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcclxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XHJcblxyXG52YXIgbW9kaWZpZXJDb2RlID0ge1xyXG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcclxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcclxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxyXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxyXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXHJcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxyXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxyXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXHJcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxyXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXHJcbiAgZXZlbnRzLFxyXG4gIGlzTmF0aXZlLFxyXG4gIHdhcm5cclxuKSB7XHJcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xyXG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XHJcbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1tuYW1lXTtcclxuICAgIC8vICM1MzMwOiB3YXJuIGNsaWNrLnJpZ2h0LCBzaW5jZSByaWdodCBjbGlja3MgZG8gbm90IGFjdHVhbGx5IGZpcmUgY2xpY2sgZXZlbnRzLlxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgbmFtZSA9PT0gJ2NsaWNrJyAmJlxyXG4gICAgICBoYW5kbGVyICYmIGhhbmRsZXIubW9kaWZpZXJzICYmIGhhbmRsZXIubW9kaWZpZXJzLnJpZ2h0XHJcbiAgICApIHtcclxuICAgICAgd2FybihcclxuICAgICAgICBcIlVzZSBcXFwiY29udGV4dG1lbnVcXFwiIGluc3RlYWQgb2YgXFxcImNsaWNrLnJpZ2h0XFxcIiBzaW5jZSByaWdodCBjbGlja3MgXCIgK1xyXG4gICAgICAgIFwiZG8gbm90IGFjdHVhbGx5IGZpcmUgXFxcImNsaWNrXFxcIiBldmVudHMuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKSkgKyBcIixcIjtcclxuICB9XHJcbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXHJcbiAgbmFtZSxcclxuICBoYW5kbGVyXHJcbikge1xyXG4gIGlmICghaGFuZGxlcikge1xyXG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXHJcbiAgfVxyXG5cclxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xyXG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxyXG4gIH1cclxuXHJcbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xyXG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcclxuXHJcbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xyXG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxyXG4gICAgICA/IGhhbmRsZXIudmFsdWVcclxuICAgICAgOiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGNvZGUgPSAnJztcclxuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcclxuICAgIHZhciBrZXlzID0gW107XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcclxuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XHJcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xyXG4gICAgICAgIC8vIGxlZnQvcmlnaHRcclxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xyXG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XHJcbiAgICB9XHJcbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xyXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xyXG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcclxuICAgIH1cclxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxyXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXHJcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cclxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXHJcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xyXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xyXG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xyXG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcclxuICBpZiAoa2V5VmFsKSB7XHJcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcclxuICB9XHJcbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcclxuICByZXR1cm4gKFwiX2soJGV2ZW50LmtleUNvZGUsXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyAoYWxpYXMgPyAnLCcgKyBKU09OLnN0cmluZ2lmeShhbGlhcykgOiAnJykgKyBcIilcIilcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcclxuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xyXG4gIH1cclxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XHJcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xyXG4gIG9uOiBvbixcclxuICBiaW5kOiBiaW5kJDEsXHJcbiAgY2xvYWs6IG5vb3BcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xyXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xyXG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xyXG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xyXG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcclxuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcclxuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xyXG4gIHRoaXMub25jZUlkID0gMDtcclxuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xyXG59O1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXHJcbiAgYXN0LFxyXG4gIG9wdGlvbnNcclxuKSB7XHJcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcclxuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xyXG4gIHJldHVybiB7XHJcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcclxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcclxuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XHJcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcclxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcclxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XHJcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcclxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcclxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xyXG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcclxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XHJcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XHJcbiAgICB2YXIgY29kZTtcclxuICAgIGlmIChlbC5jb21wb25lbnQpIHtcclxuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XHJcblxyXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xyXG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xyXG4gICAgfVxyXG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29kZVxyXG4gIH1cclxufVxyXG5cclxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcclxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcclxuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xyXG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xyXG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXHJcbn1cclxuXHJcbi8vIHYtb25jZVxyXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcclxuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcclxuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XHJcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxyXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcclxuICAgIHZhciBrZXkgPSAnJztcclxuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XHJcbiAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XHJcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIWtleSkge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXHJcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbklmIChcclxuICBlbCxcclxuICBzdGF0ZSxcclxuICBhbHRHZW4sXHJcbiAgYWx0RW1wdHlcclxuKSB7XHJcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cclxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcclxuICBjb25kaXRpb25zLFxyXG4gIHN0YXRlLFxyXG4gIGFsdEdlbixcclxuICBhbHRFbXB0eVxyXG4pIHtcclxuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXHJcbiAgfVxyXG5cclxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xyXG4gIGlmIChjb25kaXRpb24uZXhwKSB7XHJcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXHJcbiAgfVxyXG5cclxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXHJcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcclxuICAgIHJldHVybiBhbHRHZW5cclxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxyXG4gICAgICA6IGVsLm9uY2VcclxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxyXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Gb3IgKFxyXG4gIGVsLFxyXG4gIHN0YXRlLFxyXG4gIGFsdEdlbixcclxuICBhbHRIZWxwZXJcclxuKSB7XHJcbiAgdmFyIGV4cCA9IGVsLmZvcjtcclxuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcclxuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XHJcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXHJcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxyXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXHJcbiAgICAhZWwua2V5XHJcbiAgKSB7XHJcbiAgICBzdGF0ZS53YXJuKFxyXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcclxuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXHJcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcclxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cclxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXHJcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xyXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcclxuICAgICd9KSdcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcclxuICB2YXIgZGF0YSA9ICd7JztcclxuXHJcbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cclxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxyXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xyXG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxyXG5cclxuICAvLyBrZXlcclxuICBpZiAoZWwua2V5KSB7XHJcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcclxuICB9XHJcbiAgLy8gcmVmXHJcbiAgaWYgKGVsLnJlZikge1xyXG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XHJcbiAgfVxyXG4gIGlmIChlbC5yZWZJbkZvcikge1xyXG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XHJcbiAgfVxyXG4gIC8vIHByZVxyXG4gIGlmIChlbC5wcmUpIHtcclxuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcclxuICB9XHJcbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcclxuICBpZiAoZWwuY29tcG9uZW50KSB7XHJcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xyXG4gIH1cclxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xyXG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcclxuICB9XHJcbiAgLy8gYXR0cmlidXRlc1xyXG4gIGlmIChlbC5hdHRycykge1xyXG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xyXG4gIH1cclxuICAvLyBET00gcHJvcHNcclxuICBpZiAoZWwucHJvcHMpIHtcclxuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcclxuICB9XHJcbiAgLy8gZXZlbnQgaGFuZGxlcnNcclxuICBpZiAoZWwuZXZlbnRzKSB7XHJcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcclxuICB9XHJcbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xyXG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcclxuICB9XHJcbiAgLy8gc2xvdCB0YXJnZXRcclxuICBpZiAoZWwuc2xvdFRhcmdldCkge1xyXG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcclxuICB9XHJcbiAgLy8gc2NvcGVkIHNsb3RzXHJcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XHJcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xyXG4gIH1cclxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxyXG4gIGlmIChlbC5tb2RlbCkge1xyXG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xyXG4gIH1cclxuICAvLyBpbmxpbmUtdGVtcGxhdGVcclxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcclxuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XHJcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcclxuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xyXG4gICAgfVxyXG4gIH1cclxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcclxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXHJcbiAgaWYgKGVsLndyYXBEYXRhKSB7XHJcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XHJcbiAgfVxyXG4gIC8vIHYtb24gZGF0YSB3cmFwXHJcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcclxuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcclxuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XHJcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XHJcbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xyXG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XHJcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XHJcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBkaXIgPSBkaXJzW2ldO1xyXG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xyXG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xyXG4gICAgaWYgKGdlbikge1xyXG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxyXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXHJcbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XHJcbiAgICB9XHJcbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcclxuICAgICAgaGFzUnVudGltZSA9IHRydWU7XHJcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaGFzUnVudGltZSkge1xyXG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcclxuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxyXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxyXG4gICkpIHtcclxuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xyXG4gIH1cclxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcclxuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcclxuICBzbG90cyxcclxuICBzdGF0ZVxyXG4pIHtcclxuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxyXG4gICAgfSkuam9pbignLCcpKSArIFwiXSlcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXHJcbiAga2V5LFxyXG4gIGVsLFxyXG4gIHN0YXRlXHJcbikge1xyXG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpXHJcbiAgfVxyXG4gIHJldHVybiBcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXHJcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcclxuICAgICAgPyBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXHJcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifX1cIlxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcclxuICBrZXksXHJcbiAgZWwsXHJcbiAgc3RhdGVcclxuKSB7XHJcbiAgdmFyIGV4cCA9IGVsLmZvcjtcclxuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcclxuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XHJcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xyXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxyXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXHJcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xyXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xyXG4gICAgJ30pJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXHJcbiAgZWwsXHJcbiAgc3RhdGUsXHJcbiAgY2hlY2tTa2lwLFxyXG4gIGFsdEdlbkVsZW1lbnQsXHJcbiAgYWx0R2VuTm9kZVxyXG4pIHtcclxuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcclxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xyXG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXHJcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgIGVsJDEuZm9yICYmXHJcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXHJcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXHJcbiAgICB9XHJcbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcclxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXHJcbiAgICAgIDogMDtcclxuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XHJcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxyXG4gIH1cclxufVxyXG5cclxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxyXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxyXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXHJcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcclxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxyXG4gIGNoaWxkcmVuLFxyXG4gIG1heWJlQ29tcG9uZW50XHJcbikge1xyXG4gIHZhciByZXMgPSAwO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcclxuICAgICAgY29udGludWVcclxuICAgIH1cclxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XHJcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcclxuICAgICAgcmVzID0gMjtcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcclxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XHJcbiAgICAgIHJlcyA9IDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xyXG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcclxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcclxuICB9IGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcclxuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XHJcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxyXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcclxuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XHJcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcclxuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xyXG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XHJcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcclxuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcclxuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xyXG4gICAgcmVzICs9IFwiLG51bGxcIjtcclxuICB9XHJcbiAgaWYgKGF0dHJzKSB7XHJcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcclxuICB9XHJcbiAgaWYgKGJpbmQkJDEpIHtcclxuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xyXG4gIH1cclxuICByZXR1cm4gcmVzICsgJyknXHJcbn1cclxuXHJcbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcclxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcclxuICBjb21wb25lbnROYW1lLFxyXG4gIGVsLFxyXG4gIHN0YXRlXHJcbikge1xyXG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XHJcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcclxuICB2YXIgcmVzID0gJyc7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcclxuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcclxuICB9XHJcbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcclxufVxyXG5cclxuLy8gIzM4OTUsICM0MjY4XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xyXG4gIHJldHVybiB0ZXh0XHJcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcclxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXHJcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcclxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXHJcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXHJcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcclxuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcclxuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcclxuXHJcbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXHJcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxyXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXHJcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xyXG5cclxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcclxudmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xyXG5cclxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xyXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xyXG5cclxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcclxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcclxuICB2YXIgZXJyb3JzID0gW107XHJcbiAgaWYgKGFzdCkge1xyXG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcclxuICB9XHJcbiAgcmV0dXJuIGVycm9yc1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xyXG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xyXG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xyXG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XHJcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xyXG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xyXG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xyXG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xyXG4gICAgZXJyb3JzLnB1c2goXHJcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXHJcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcclxuICAgICk7XHJcbiAgfVxyXG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcclxuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XHJcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XHJcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xyXG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChpZGVudCwgdHlwZSwgdGV4dCwgZXJyb3JzKSB7XHJcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcclxuICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XHJcbiAgdHJ5IHtcclxuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xyXG4gICAgICBlcnJvcnMucHVzaChcclxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXHJcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xyXG4gICAgcmV0dXJuIG5vb3BcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcclxuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcclxuICAgIHRlbXBsYXRlLFxyXG4gICAgb3B0aW9ucyxcclxuICAgIHZtXHJcbiAgKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xyXG4gICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xyXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXHJcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXHJcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcclxuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBjYWNoZVxyXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xyXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcclxuICAgICAgOiB0ZW1wbGF0ZTtcclxuICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29tcGlsZVxyXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXHJcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcclxuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XHJcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XHJcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cclxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXHJcbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXHJcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xyXG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XHJcbiAgICAgICAgfSkuam9pbignXFxuJyksXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XHJcbiAgICBmdW5jdGlvbiBjb21waWxlIChcclxuICAgICAgdGVtcGxhdGUsXHJcbiAgICAgIG9wdGlvbnNcclxuICAgICkge1xyXG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XHJcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcclxuICAgICAgdmFyIHRpcHMgPSBbXTtcclxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcclxuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xyXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcclxuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cclxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xyXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxyXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxyXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcclxuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcclxuICAgICAgfVxyXG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xyXG4gICAgICByZXR1cm4gY29tcGlsZWRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb21waWxlOiBjb21waWxlLFxyXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxyXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXHJcbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxyXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxyXG4gIHRlbXBsYXRlLFxyXG4gIG9wdGlvbnNcclxuKSB7XHJcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XHJcbiAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcclxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFzdDogYXN0LFxyXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcclxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcclxuICB9XHJcbn0pO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XHJcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XHJcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xyXG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcclxufSk7XHJcblxyXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xyXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxyXG4gIGVsLFxyXG4gIGh5ZHJhdGluZ1xyXG4pIHtcclxuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XHJcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cclxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XHJcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xyXG4gICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXHJcbiAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xyXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGVsKSB7XHJcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcclxuICAgIH1cclxuICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgICBtYXJrKCdjb21waWxlJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcclxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXHJcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxyXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcclxuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xyXG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcclxuXHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XHJcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXHJcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xyXG4gIGlmIChlbC5vdXRlckhUTUwpIHtcclxuICAgIHJldHVybiBlbC5vdXRlckhUTUxcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxyXG4gIH1cclxufVxyXG5cclxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\r\nvar process = module.exports = {};\r\n\r\n// cached from whatever global is present so that test runners that stub it\r\n// don't break things.  But we need to wrap it in a try catch in case it is\r\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\r\n// function because try/catches deoptimize in certain engines.\r\n\r\nvar cachedSetTimeout;\r\nvar cachedClearTimeout;\r\n\r\nfunction defaultSetTimout() {\r\n    throw new Error('setTimeout has not been defined');\r\n}\r\nfunction defaultClearTimeout () {\r\n    throw new Error('clearTimeout has not been defined');\r\n}\r\n(function () {\r\n    try {\r\n        if (typeof setTimeout === 'function') {\r\n            cachedSetTimeout = setTimeout;\r\n        } else {\r\n            cachedSetTimeout = defaultSetTimout;\r\n        }\r\n    } catch (e) {\r\n        cachedSetTimeout = defaultSetTimout;\r\n    }\r\n    try {\r\n        if (typeof clearTimeout === 'function') {\r\n            cachedClearTimeout = clearTimeout;\r\n        } else {\r\n            cachedClearTimeout = defaultClearTimeout;\r\n        }\r\n    } catch (e) {\r\n        cachedClearTimeout = defaultClearTimeout;\r\n    }\r\n} ())\r\nfunction runTimeout(fun) {\r\n    if (cachedSetTimeout === setTimeout) {\r\n        //normal enviroments in sane situations\r\n        return setTimeout(fun, 0);\r\n    }\r\n    // if setTimeout wasn't available but was latter defined\r\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\r\n        cachedSetTimeout = setTimeout;\r\n        return setTimeout(fun, 0);\r\n    }\r\n    try {\r\n        // when when somebody has screwed with setTimeout but no I.E. maddness\r\n        return cachedSetTimeout(fun, 0);\r\n    } catch(e){\r\n        try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\r\n            return cachedSetTimeout.call(null, fun, 0);\r\n        } catch(e){\r\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\r\n            return cachedSetTimeout.call(this, fun, 0);\r\n        }\r\n    }\r\n\r\n\r\n}\r\nfunction runClearTimeout(marker) {\r\n    if (cachedClearTimeout === clearTimeout) {\r\n        //normal enviroments in sane situations\r\n        return clearTimeout(marker);\r\n    }\r\n    // if clearTimeout wasn't available but was latter defined\r\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\r\n        cachedClearTimeout = clearTimeout;\r\n        return clearTimeout(marker);\r\n    }\r\n    try {\r\n        // when when somebody has screwed with setTimeout but no I.E. maddness\r\n        return cachedClearTimeout(marker);\r\n    } catch (e){\r\n        try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\r\n            return cachedClearTimeout.call(null, marker);\r\n        } catch (e){\r\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\r\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\r\n            return cachedClearTimeout.call(this, marker);\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\nvar queue = [];\r\nvar draining = false;\r\nvar currentQueue;\r\nvar queueIndex = -1;\r\n\r\nfunction cleanUpNextTick() {\r\n    if (!draining || !currentQueue) {\r\n        return;\r\n    }\r\n    draining = false;\r\n    if (currentQueue.length) {\r\n        queue = currentQueue.concat(queue);\r\n    } else {\r\n        queueIndex = -1;\r\n    }\r\n    if (queue.length) {\r\n        drainQueue();\r\n    }\r\n}\r\n\r\nfunction drainQueue() {\r\n    if (draining) {\r\n        return;\r\n    }\r\n    var timeout = runTimeout(cleanUpNextTick);\r\n    draining = true;\r\n\r\n    var len = queue.length;\r\n    while(len) {\r\n        currentQueue = queue;\r\n        queue = [];\r\n        while (++queueIndex < len) {\r\n            if (currentQueue) {\r\n                currentQueue[queueIndex].run();\r\n            }\r\n        }\r\n        queueIndex = -1;\r\n        len = queue.length;\r\n    }\r\n    currentQueue = null;\r\n    draining = false;\r\n    runClearTimeout(timeout);\r\n}\r\n\r\nprocess.nextTick = function (fun) {\r\n    var args = new Array(arguments.length - 1);\r\n    if (arguments.length > 1) {\r\n        for (var i = 1; i < arguments.length; i++) {\r\n            args[i - 1] = arguments[i];\r\n        }\r\n    }\r\n    queue.push(new Item(fun, args));\r\n    if (queue.length === 1 && !draining) {\r\n        runTimeout(drainQueue);\r\n    }\r\n};\r\n\r\n// v8 likes predictible objects\r\nfunction Item(fun, array) {\r\n    this.fun = fun;\r\n    this.array = array;\r\n}\r\nItem.prototype.run = function () {\r\n    this.fun.apply(null, this.array);\r\n};\r\nprocess.title = 'browser';\r\nprocess.browser = true;\r\nprocess.env = {};\r\nprocess.argv = [];\r\nprocess.version = ''; // empty string to avoid regexp issues\r\nprocess.versions = {};\r\n\r\nfunction noop() {}\r\n\r\nprocess.on = noop;\r\nprocess.addListener = noop;\r\nprocess.once = noop;\r\nprocess.off = noop;\r\nprocess.removeListener = noop;\r\nprocess.removeAllListeners = noop;\r\nprocess.emit = noop;\r\nprocess.prependListener = noop;\r\nprocess.prependOnceListener = noop;\r\n\r\nprocess.listeners = function (name) { return [] }\r\n\r\nprocess.binding = function (name) {\r\n    throw new Error('process.binding is not supported');\r\n};\r\n\r\nprocess.cwd = function () { return '/' };\r\nprocess.chdir = function (dir) {\r\n    throw new Error('process.chdir is not supported');\r\n};\r\nprocess.umask = function() { return 0; };\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzViNjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXHJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcclxuXHJcbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxyXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcclxuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxyXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxyXG5cclxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XHJcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xyXG59XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xyXG4gICAgfVxyXG59ICgpKVxyXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xyXG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcclxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcclxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xyXG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcclxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xyXG4gICAgfSBjYXRjaChlKXtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xyXG4gICAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XHJcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcclxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcclxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XHJcbiAgICB9XHJcbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXHJcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcclxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XHJcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xyXG4gICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcclxuICAgICAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXHJcbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59XHJcbnZhciBxdWV1ZSA9IFtdO1xyXG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcclxudmFyIGN1cnJlbnRRdWV1ZTtcclxudmFyIHF1ZXVlSW5kZXggPSAtMTtcclxuXHJcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcclxuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGRyYWluaW5nID0gZmFsc2U7XHJcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcclxuICAgIH1cclxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICBkcmFpblF1ZXVlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XHJcbiAgICBpZiAoZHJhaW5pbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcclxuICAgIGRyYWluaW5nID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xyXG4gICAgd2hpbGUobGVuKSB7XHJcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgcXVldWUgPSBbXTtcclxuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XHJcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcclxuICAgIGRyYWluaW5nID0gZmFsc2U7XHJcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XHJcbn1cclxuXHJcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XHJcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xyXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcclxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xyXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcclxuICAgIHRoaXMuZnVuID0gZnVuO1xyXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xyXG59XHJcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xyXG59O1xyXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xyXG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xyXG5wcm9jZXNzLmVudiA9IHt9O1xyXG5wcm9jZXNzLmFyZ3YgPSBbXTtcclxucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXHJcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cclxucHJvY2Vzcy5vbiA9IG5vb3A7XHJcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xyXG5wcm9jZXNzLm9uY2UgPSBub29wO1xyXG5wcm9jZXNzLm9mZiA9IG5vb3A7XHJcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xyXG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XHJcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XHJcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcclxucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcclxuXHJcbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cclxuXHJcbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbn07XHJcblxyXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xyXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxufTtcclxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function(useSourceMap) {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\treturn this.map(function (item) {\r\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\r\n\t\t\tif(item[2]) {\r\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\r\n\t\t\t} else {\r\n\t\t\t\treturn content;\r\n\t\t\t}\r\n\t\t}).join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\r\nfunction cssWithMappingToString(item, useSourceMap) {\r\n\tvar content = item[1] || '';\r\n\tvar cssMapping = item[3];\r\n\tif (!cssMapping) {\r\n\t\treturn content;\r\n\t}\r\n\r\n\tif (useSourceMap && typeof btoa === 'function') {\r\n\t\tvar sourceMapping = toComment(cssMapping);\r\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\r\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\r\n\t\t});\r\n\r\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\r\n\t}\r\n\r\n\treturn [content].join('\\n');\r\n}\r\n\r\n// Adapted from convert-source-map (MIT)\r\nfunction toComment(sourceMap) {\r\n\t// eslint-disable-next-line no-undef\r\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\r\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\r\n\r\n\treturn '/*# ' + data + ' */';\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MTU5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH0pLmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xyXG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcclxuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XHJcblx0aWYgKCFjc3NNYXBwaW5nKSB7XHJcblx0XHRyZXR1cm4gY29udGVudDtcclxuXHR9XHJcblxyXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xyXG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xyXG59XHJcblxyXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXHJcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcclxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcclxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcclxuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xyXG5cclxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6a91af18_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_header_vue__ = __webpack_require__(13);\nvar disposed = false\nvar normalizeComponent = __webpack_require__(0)\n/* script */\nvar __vue_script__ = null\n/* template */\n\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6a91af18_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_header_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src\\\\components\\\\header.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] header.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-6a91af18\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-6a91af18\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9oZWFkZXIudnVlP2IzNDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbnZhciBfX3Z1ZV9zY3JpcHRfXyA9IG51bGxcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi02YTkxYWYxOFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9oZWFkZXIudnVlXCJcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcY29tcG9uZW50c1xcXFxoZWFkZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBoZWFkZXIudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTZhOTFhZjE4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNmE5MWFmMThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9oZWFkZXIudnVlXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__routes_js__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__assets_styles_base_css__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__assets_styles_base_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__assets_styles_base_css__);\n\n\n\n\n\n//import './assets/sass/reset.sass'//sass\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */].config.debug = true; //\n\nnew __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */]({\n    router: __WEBPACK_IMPORTED_MODULE_2__routes_js__[\"a\" /* default */],\n    el: '#appIndex',\n    render: h => h(__WEBPACK_IMPORTED_MODULE_1__App_vue__[\"a\" /* default */])\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIlZ1ZSIsImNvbmZpZyIsImRlYnVnIiwicm91dGVyIiwiZWwiLCJyZW5kZXIiLCJoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFBQSxDQUFJQyxNQUFKLENBQVdDLEtBQVgsR0FBbUIsSUFBbkIsQyxDQUF3Qjs7QUFFeEIsSUFBSSxvREFBSixDQUFRO0FBQ0pDLElBQUEsbUVBREk7QUFFSkMsUUFBSSxXQUZBO0FBR0pDLFlBQVFDLEtBQUtBLEVBQUUseURBQUY7QUFIVCxDQUFSIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IEFwcCBmcm9tICcuL0FwcC52dWUnXHJcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi9yb3V0ZXMuanMnXHJcblxyXG5pbXBvcnQgJy4vYXNzZXRzL3N0eWxlcy9iYXNlLmNzcydcclxuLy9pbXBvcnQgJy4vYXNzZXRzL3Nhc3MvcmVzZXQuc2FzcycvL+aKpemUmeaaguaXtuS4jeeUqHNhc3NcclxuVnVlLmNvbmZpZy5kZWJ1ZyA9IHRydWU7Ly/lvIDlkK/plJnor6/mj5DnpLpcclxuXHJcbm5ldyBWdWUoe1xyXG4gICAgcm91dGVyLFxyXG4gICAgZWw6ICcjYXBwSW5kZXgnLFxyXG4gICAgcmVuZGVyOiBoID0+IGgoQXBwKVxyXG59KVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_App_vue__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_69697fcf_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_App_vue__ = __webpack_require__(14);\nvar disposed = false\nfunction injectStyle (ssrContext) {\n  if (disposed) return\n  __webpack_require__(8)\n}\nvar normalizeComponent = __webpack_require__(0)\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_App_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_69697fcf_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_App_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src\\\\App.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] App.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-69697fcf\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-69697fcf\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT85ZTA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLHVCQUEyTDtBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTY5Njk3ZmNmXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc2Fzcy1sb2FkZXIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BcHAudnVlXCIpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTY5Njk3ZmNmXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0FwcC52dWVcIlxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcQXBwLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gQXBwLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi02OTY5N2ZjZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTY5Njk3ZmNmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(10)(\"26116a6e\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-69697fcf\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/sass-loader/lib/loader.js!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./App.vue\", function() {\n     var newContent = require(\"!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-69697fcf\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/sass-loader/lib/loader.js!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./App.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT80MWUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsbUNBQWtOO0FBQ2xOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsbUZBQW1GO0FBQ2pOLHVJQUF1SSxtRkFBbUY7QUFDMU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTY5Njk3ZmNmXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BcHAudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIyNjExNmE2ZVwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi02OTY5N2ZjZlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vQXBwLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi02OTY5N2ZjZlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vQXBwLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi02OTY5N2ZjZlwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(3)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\nh2 {\\n  color: #f00;\\n}\\n#app {\\n  text-align: center;\\n  color: #2c3e50;\\n  margin-top: 60px;\\n}\\nh1, h2 {\\n  font-weight: normal;\\n}\\nul {\\n  list-style-type: none;\\n  padding: 0;\\n}\\nli {\\n  text-align: left;\\n  margin: 0 10px;\\n}\\na {\\n  color: #42b983;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"D:/jslearning/Js-learning-project/vue-webpack/src/App.vue\"],\"names\":[],\"mappings\":\";AAAA;EACE,YAAY;CAAE;AAEhB;EACE,mBAAmB;EACnB,eAAe;EACf,iBAAiB;CAAE;AAErB;EACE,oBAAoB;CAAE;AAExB;EACE,sBAAsB;EACtB,WAAW;CAAE;AAEf;EACE,iBAAiB;EACjB,eAAe;CAAE;AAEnB;EACE,eAAe;CAAE\",\"file\":\"App.vue\",\"sourcesContent\":[\"h2 {\\n  color: #f00; }\\n\\n#app {\\n  text-align: center;\\n  color: #2c3e50;\\n  margin-top: 60px; }\\n\\nh1, h2 {\\n  font-weight: normal; }\\n\\nul {\\n  list-style-type: none;\\n  padding: 0; }\\n\\nli {\\n  text-align: left;\\n  margin: 0 10px; }\\n\\na {\\n  color: #42b983; }\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8zYTRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQWdDLGdCQUFnQixHQUFHLFFBQVEsdUJBQXVCLG1CQUFtQixxQkFBcUIsR0FBRyxVQUFVLHdCQUF3QixHQUFHLE1BQU0sMEJBQTBCLGVBQWUsR0FBRyxNQUFNLHFCQUFxQixtQkFBbUIsR0FBRyxLQUFLLG1CQUFtQixHQUFHLFVBQVUsNEdBQTRHLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxXQUFXLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksV0FBVyxLQUFLLEtBQUssWUFBWSxXQUFXLEtBQUssTUFBTSxVQUFVLDhDQUE4QyxnQkFBZ0IsRUFBRSxVQUFVLHVCQUF1QixtQkFBbUIscUJBQXFCLEVBQUUsWUFBWSx3QkFBd0IsRUFBRSxRQUFRLDBCQUEwQixlQUFlLEVBQUUsUUFBUSxxQkFBcUIsbUJBQW1CLEVBQUUsT0FBTyxtQkFBbUIsRUFBRSxxQkFBcUI7O0FBRXo0QiIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbmgyIHtcXG4gIGNvbG9yOiAjZjAwO1xcbn1cXG4jYXBwIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGNvbG9yOiAjMmMzZTUwO1xcbiAgbWFyZ2luLXRvcDogNjBweDtcXG59XFxuaDEsIGgyIHtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxufVxcbnVsIHtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxufVxcbmxpIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBtYXJnaW46IDAgMTBweDtcXG59XFxuYSB7XFxuICBjb2xvcjogIzQyYjk4MztcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkQ6L2pzbGVhcm5pbmcvSnMtbGVhcm5pbmctcHJvamVjdC92dWUtd2VicGFjay9zcmMvQXBwLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQUE7RUFDRSxZQUFZO0NBQUU7QUFFaEI7RUFDRSxtQkFBbUI7RUFDbkIsZUFBZTtFQUNmLGlCQUFpQjtDQUFFO0FBRXJCO0VBQ0Usb0JBQW9CO0NBQUU7QUFFeEI7RUFDRSxzQkFBc0I7RUFDdEIsV0FBVztDQUFFO0FBRWY7RUFDRSxpQkFBaUI7RUFDakIsZUFBZTtDQUFFO0FBRW5CO0VBQ0UsZUFBZTtDQUFFXCIsXCJmaWxlXCI6XCJBcHAudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcImgyIHtcXG4gIGNvbG9yOiAjZjAwOyB9XFxuXFxuI2FwcCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBjb2xvcjogIzJjM2U1MDtcXG4gIG1hcmdpbi10b3A6IDYwcHg7IH1cXG5cXG5oMSwgaDIge1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDsgfVxcblxcbnVsIHtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG4gIHBhZGRpbmc6IDA7IH1cXG5cXG5saSB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgbWFyZ2luOiAwIDEwcHg7IH1cXG5cXG5hIHtcXG4gIGNvbG9yOiAjNDJiOTgzOyB9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTY5Njk3ZmNmXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n  Modified by Evan You @yyx990803\r\n*/\r\n\r\nvar hasDocument = typeof document !== 'undefined'\r\n\r\nif (typeof DEBUG !== 'undefined' && DEBUG) {\r\n  if (!hasDocument) {\r\n    throw new Error(\r\n    'vue-style-loader cannot be used in a non-browser environment. ' +\r\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\r\n  ) }\r\n}\r\n\r\nvar listToStyles = __webpack_require__(11)\r\n\r\n/*\r\ntype StyleObject = {\r\n  id: number;\r\n  parts: Array<StyleObjectPart>\r\n}\r\n\r\ntype StyleObjectPart = {\r\n  css: string;\r\n  media: string;\r\n  sourceMap: ?string\r\n}\r\n*/\r\n\r\nvar stylesInDom = {/*\r\n  [id: number]: {\r\n    id: number,\r\n    refs: number,\r\n    parts: Array<(obj?: StyleObjectPart) => void>\r\n  }\r\n*/}\r\n\r\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\r\nvar singletonElement = null\r\nvar singletonCounter = 0\r\nvar isProduction = false\r\nvar noop = function () {}\r\n\r\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n// tags it will allow on a page\r\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\r\n\r\nmodule.exports = function (parentId, list, _isProduction) {\r\n  isProduction = _isProduction\r\n\r\n  var styles = listToStyles(parentId, list)\r\n  addStylesToDom(styles)\r\n\r\n  return function update (newList) {\r\n    var mayRemove = []\r\n    for (var i = 0; i < styles.length; i++) {\r\n      var item = styles[i]\r\n      var domStyle = stylesInDom[item.id]\r\n      domStyle.refs--\r\n      mayRemove.push(domStyle)\r\n    }\r\n    if (newList) {\r\n      styles = listToStyles(parentId, newList)\r\n      addStylesToDom(styles)\r\n    } else {\r\n      styles = []\r\n    }\r\n    for (var i = 0; i < mayRemove.length; i++) {\r\n      var domStyle = mayRemove[i]\r\n      if (domStyle.refs === 0) {\r\n        for (var j = 0; j < domStyle.parts.length; j++) {\r\n          domStyle.parts[j]()\r\n        }\r\n        delete stylesInDom[domStyle.id]\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\r\n  for (var i = 0; i < styles.length; i++) {\r\n    var item = styles[i]\r\n    var domStyle = stylesInDom[item.id]\r\n    if (domStyle) {\r\n      domStyle.refs++\r\n      for (var j = 0; j < domStyle.parts.length; j++) {\r\n        domStyle.parts[j](item.parts[j])\r\n      }\r\n      for (; j < item.parts.length; j++) {\r\n        domStyle.parts.push(addStyle(item.parts[j]))\r\n      }\r\n      if (domStyle.parts.length > item.parts.length) {\r\n        domStyle.parts.length = item.parts.length\r\n      }\r\n    } else {\r\n      var parts = []\r\n      for (var j = 0; j < item.parts.length; j++) {\r\n        parts.push(addStyle(item.parts[j]))\r\n      }\r\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createStyleElement () {\r\n  var styleElement = document.createElement('style')\r\n  styleElement.type = 'text/css'\r\n  head.appendChild(styleElement)\r\n  return styleElement\r\n}\r\n\r\nfunction addStyle (obj /* StyleObjectPart */) {\r\n  var update, remove\r\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\r\n\r\n  if (styleElement) {\r\n    if (isProduction) {\r\n      // has SSR styles and in production mode.\r\n      // simply do nothing.\r\n      return noop\r\n    } else {\r\n      // has SSR styles but in dev mode.\r\n      // for some reason Chrome can't handle source map in server-rendered\r\n      // style tags - source maps in <style> only works if the style tag is\r\n      // created and inserted dynamically. So we remove the server rendered\r\n      // styles and inject new ones.\r\n      styleElement.parentNode.removeChild(styleElement)\r\n    }\r\n  }\r\n\r\n  if (isOldIE) {\r\n    // use singleton mode for IE9.\r\n    var styleIndex = singletonCounter++\r\n    styleElement = singletonElement || (singletonElement = createStyleElement())\r\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\r\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\r\n  } else {\r\n    // use multi-style-tag mode in all other cases\r\n    styleElement = createStyleElement()\r\n    update = applyToTag.bind(null, styleElement)\r\n    remove = function () {\r\n      styleElement.parentNode.removeChild(styleElement)\r\n    }\r\n  }\r\n\r\n  update(obj)\r\n\r\n  return function updateStyle (newObj /* StyleObjectPart */) {\r\n    if (newObj) {\r\n      if (newObj.css === obj.css &&\r\n          newObj.media === obj.media &&\r\n          newObj.sourceMap === obj.sourceMap) {\r\n        return\r\n      }\r\n      update(obj = newObj)\r\n    } else {\r\n      remove()\r\n    }\r\n  }\r\n}\r\n\r\nvar replaceText = (function () {\r\n  var textStore = []\r\n\r\n  return function (index, replacement) {\r\n    textStore[index] = replacement\r\n    return textStore.filter(Boolean).join('\\n')\r\n  }\r\n})()\r\n\r\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\r\n  var css = remove ? '' : obj.css\r\n\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = replaceText(index, css)\r\n  } else {\r\n    var cssNode = document.createTextNode(css)\r\n    var childNodes = styleElement.childNodes\r\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\r\n    if (childNodes.length) {\r\n      styleElement.insertBefore(cssNode, childNodes[index])\r\n    } else {\r\n      styleElement.appendChild(cssNode)\r\n    }\r\n  }\r\n}\r\n\r\nfunction applyToTag (styleElement, obj) {\r\n  var css = obj.css\r\n  var media = obj.media\r\n  var sourceMap = obj.sourceMap\r\n\r\n  if (media) {\r\n    styleElement.setAttribute('media', media)\r\n  }\r\n\r\n  if (sourceMap) {\r\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n    // this makes source maps inside style tags work properly in Chrome\r\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\r\n    // http://stackoverflow.com/a/26603875\r\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\r\n  }\r\n\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = css\r\n  } else {\r\n    while (styleElement.firstChild) {\r\n      styleElement.removeChild(styleElement.firstChild)\r\n    }\r\n    styleElement.appendChild(document.createTextNode(css))\r\n  }\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzP2FlMzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xyXG4qL1xyXG5cclxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xyXG5cclxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcclxuICBpZiAoIWhhc0RvY3VtZW50KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcclxuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxyXG4gICkgfVxyXG59XHJcblxyXG52YXIgbGlzdFRvU3R5bGVzID0gcmVxdWlyZSgnLi9saXN0VG9TdHlsZXMnKVxyXG5cclxuLypcclxudHlwZSBTdHlsZU9iamVjdCA9IHtcclxuICBpZDogbnVtYmVyO1xyXG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XHJcbn1cclxuXHJcbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xyXG4gIGNzczogc3RyaW5nO1xyXG4gIG1lZGlhOiBzdHJpbmc7XHJcbiAgc291cmNlTWFwOiA/c3RyaW5nXHJcbn1cclxuKi9cclxuXHJcbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxyXG4gIFtpZDogbnVtYmVyXToge1xyXG4gICAgaWQ6IG51bWJlcixcclxuICAgIHJlZnM6IG51bWJlcixcclxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxyXG4gIH1cclxuKi99XHJcblxyXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXHJcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxyXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcclxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cclxuXHJcbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24pIHtcclxuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXHJcblxyXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXHJcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XHJcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXHJcbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXHJcbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxyXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcclxuICAgIH1cclxuICAgIGlmIChuZXdMaXN0KSB7XHJcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcclxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3R5bGVzID0gW11cclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxyXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxyXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cclxuICAgIGlmIChkb21TdHlsZSkge1xyXG4gICAgICBkb21TdHlsZS5yZWZzKytcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXHJcbiAgICAgIH1cclxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcclxuICAgICAgfVxyXG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcclxuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgcGFydHMgPSBbXVxyXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxyXG4gICAgICB9XHJcbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XHJcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcclxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcclxuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcclxuICByZXR1cm4gc3R5bGVFbGVtZW50XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XHJcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXHJcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgb2JqLmlkICsgJ1wiXScpXHJcblxyXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcclxuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcclxuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cclxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXHJcbiAgICAgIHJldHVybiBub29wXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXHJcbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXHJcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xyXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcclxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXHJcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpc09sZElFKSB7XHJcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cclxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXHJcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXHJcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcclxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcclxuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXHJcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxyXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGUob2JqKVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcclxuICAgIGlmIChuZXdPYmopIHtcclxuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcclxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXHJcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlbW92ZSgpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XHJcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxyXG4gIH1cclxufSkoKVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXHJcblxyXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxyXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xyXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXHJcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuICB2YXIgY3NzID0gb2JqLmNzc1xyXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxyXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXHJcblxyXG4gIGlmIChtZWRpYSkge1xyXG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcclxuICB9XHJcblxyXG4gIGlmIChzb3VyY2VNYXApIHtcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xyXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxyXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXHJcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcclxuICB9XHJcblxyXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxyXG4gICAgfVxyXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXHJcbiAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

eval("/**\r\n * Translates the list format produced by css-loader into something\r\n * easier to manipulate.\r\n */\r\nmodule.exports = function listToStyles (parentId, list) {\r\n  var styles = []\r\n  var newStyles = {}\r\n  for (var i = 0; i < list.length; i++) {\r\n    var item = list[i]\r\n    var id = item[0]\r\n    var css = item[1]\r\n    var media = item[2]\r\n    var sourceMap = item[3]\r\n    var part = {\r\n      id: parentId + ':' + i,\r\n      css: css,\r\n      media: media,\r\n      sourceMap: sourceMap\r\n    }\r\n    if (!newStyles[id]) {\r\n      styles.push(newStyles[id] = { id: id, parts: [part] })\r\n    } else {\r\n      newStyles[id].parts.push(part)\r\n    }\r\n  }\r\n  return styles\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzP2I1MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVHJhbnNsYXRlcyB0aGUgbGlzdCBmb3JtYXQgcHJvZHVjZWQgYnkgY3NzLWxvYWRlciBpbnRvIHNvbWV0aGluZ1xyXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xyXG4gIHZhciBzdHlsZXMgPSBbXVxyXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXHJcbiAgICB2YXIgaWQgPSBpdGVtWzBdXHJcbiAgICB2YXIgY3NzID0gaXRlbVsxXVxyXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxyXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cclxuICAgIHZhciBwYXJ0ID0ge1xyXG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxyXG4gICAgICBjc3M6IGNzcyxcclxuICAgICAgbWVkaWE6IG1lZGlhLFxyXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxyXG4gICAgfVxyXG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XHJcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzdHlsZXNcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_header_vue__ = __webpack_require__(4);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n    name: 'app',\n    data() {\n        return {\n            msg: 'Welcome to Your Vue.js App'\n        };\n    },\n    components: {\n        HeaderTab: __WEBPACK_IMPORTED_MODULE_0__components_header_vue__[\"a\" /* default */]\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQXBwLnZ1ZT8wMmVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO1VBRUE7V0FDQTs7aUJBR0E7QUFGQTtBQUdBOztBQUdBO0FBRkE7QUFQQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgaWQ9XCJhcHBcIj5cclxuICAgICAgICA8aGVhZGVyLXRhYj48L2hlYWRlci10YWI+XHJcbiAgICAgICAgPGgyPnt7bXNnfX08L2gyPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXYtYm94XCI+XHJcbiAgICAgICAgICAgIDxwIGNsYXNzPVwibmF2LWxpc3RcIj5cclxuICAgICAgICAgICAgICAgIDxyb3V0ZXItbGluayBjbGFzcz1cIm5hdi1pdGVtXCIgdG89XCIvXCI+6aaW6aG1PC9yb3V0ZXItbGluaz5cclxuICAgICAgICAgICAgICAgIDxyb3V0ZXItbGluayBjbGFzcz1cIm5hdi1pdGVtXCIgdG89XCIvYWJvdXRcIj7lhbPkuo48L3JvdXRlci1saW5rPlxyXG4gICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgPHJvdXRlci12aWV3Pjwvcm91dGVyLXZpZXc+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBIZWFkZXJUYWIgZnJvbSAnLi9jb21wb25lbnRzL2hlYWRlci52dWUnO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBuYW1lOiAnYXBwJyxcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbXNnOiAnV2VsY29tZSB0byBZb3VyIFZ1ZS5qcyBBcHAnXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBIZWFkZXJUYWJcclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxyXG4gICAgJHJlZENvbG9yOiNmMDA7XHJcbiAgICBoMiB7XHJcbiAgICAgICAgY29sb3I6JHJlZENvbG9yO1xyXG4gICAgfVxyXG4gICAgI2FwcCB7XHJcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgIGNvbG9yOiAjMmMzZTUwO1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDYwcHg7XHJcbiAgICB9XHJcbiAgICBoMSwgaDIge1xyXG4gICAgICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XHJcbiAgICB9XHJcbiAgICB1bCB7XHJcbiAgICAgICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xyXG4gICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICB9XHJcbiAgICBsaSB7XHJcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcclxuICAgICAgICBtYXJnaW46IDAgMTBweDtcclxuICAgIH1cclxuICAgIGEge1xyXG4gICAgICAgIGNvbG9yOiAjNDJiOTgzO1xyXG4gICAgfVxyXG48L3N0eWxlPlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gQXBwLnZ1ZT85MmMwMjJhNiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", [_c(\"h1\", [_vm._v(\"header\")])])\n  }\n]\nrender._withStripped = true\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-6a91af18\", esExports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9oZWFkZXIudnVlPzhjODYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIFtfYyhcImgxXCIsIFtfdm0uX3YoXCLlhbHlkIxoZWFkZXJcIildKV0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNmE5MWFmMThcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi02YTkxYWYxOFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL2hlYWRlci52dWVcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    { attrs: { id: \"app\" } },\n    [\n      _c(\"header-tab\"),\n      _vm._v(\" \"),\n      _c(\"h2\", [_vm._v(_vm._s(_vm.msg))]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"nav-box\" }, [\n        _c(\n          \"p\",\n          { staticClass: \"nav-list\" },\n          [\n            _c(\"router-link\", { staticClass: \"nav-item\", attrs: { to: \"/\" } }, [\n              _vm._v(\"\")\n            ]),\n            _vm._v(\" \"),\n            _c(\n              \"router-link\",\n              { staticClass: \"nav-item\", attrs: { to: \"/about\" } },\n              [_vm._v(\"\")]\n            )\n          ],\n          1\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", [_c(\"router-view\")], 1)\n    ],\n    1\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-69697fcf\", esExports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9hODVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssU0FBUyxZQUFZLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0EsK0JBQStCLGtDQUFrQyxVQUFVLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDLGVBQWUsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgYXR0cnM6IHsgaWQ6IFwiYXBwXCIgfSB9LFxuICAgIFtcbiAgICAgIF9jKFwiaGVhZGVyLXRhYlwiKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImgyXCIsIFtfdm0uX3YoX3ZtLl9zKF92bS5tc2cpKV0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibmF2LWJveFwiIH0sIFtcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJwXCIsXG4gICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJuYXYtbGlzdFwiIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXCJyb3V0ZXItbGlua1wiLCB7IHN0YXRpY0NsYXNzOiBcIm5hdi1pdGVtXCIsIGF0dHJzOiB7IHRvOiBcIi9cIiB9IH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFwi6aaW6aG1XCIpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJyb3V0ZXItbGlua1wiLFxuICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm5hdi1pdGVtXCIsIGF0dHJzOiB7IHRvOiBcIi9hYm91dFwiIH0gfSxcbiAgICAgICAgICAgICAgW192bS5fdihcIuWFs+S6jlwiKV1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgW19jKFwicm91dGVyLXZpZXdcIildLCAxKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNjk2OTdmY2ZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi02OTY5N2ZjZlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9BcHAudnVlXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_router__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_header_vue__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__views_home_vue__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__views_about_vue__ = __webpack_require__(20);\n\n\n\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */].use(__WEBPACK_IMPORTED_MODULE_1_vue_router__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (new __WEBPACK_IMPORTED_MODULE_1_vue_router__[\"a\" /* default */]({\n    routes: [{\n        path: '/',\n        component: __WEBPACK_IMPORTED_MODULE_3__views_home_vue__[\"a\" /* default */]\n    }, {\n        path: '/about',\n        component: __WEBPACK_IMPORTED_MODULE_4__views_about_vue__[\"a\" /* default */]\n    }]\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcm91dGVzLmpzPzdhYWIiXSwibmFtZXMiOlsiVnVlIiwidXNlIiwicm91dGVzIiwicGF0aCIsImNvbXBvbmVudCIsImhvbWVQYWdlIiwiYWJvdXRQYWdlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQUFBLENBQUlDLEdBQUosQ0FBUSwyREFBUjs7QUFFQSx5REFBZSxJQUFJLDJEQUFKLENBQVc7QUFDdEJDLFlBQVEsQ0FDSjtBQUNJQyxjQUFNLEdBRFY7QUFFSUMsbUJBQVcsZ0VBQUFDO0FBRmYsS0FESSxFQUtKO0FBQ0lGLGNBQU0sUUFEVjtBQUVJQyxtQkFBVyxpRUFBQUU7QUFGZixLQUxJO0FBRGMsQ0FBWCxDQUFmIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xyXG5pbXBvcnQgUm91dGVyIGZyb20gJ3Z1ZS1yb3V0ZXInO1xyXG5pbXBvcnQgaW5kZXhQYWdlIGZyb20gJy4vY29tcG9uZW50cy9oZWFkZXIudnVlJ1xyXG5pbXBvcnQgaG9tZVBhZ2UgZnJvbSAnLi92aWV3cy9ob21lLnZ1ZSdcclxuaW1wb3J0IGFib3V0UGFnZSBmcm9tICcuL3ZpZXdzL2Fib3V0LnZ1ZSdcclxuXHJcblZ1ZS51c2UoUm91dGVyKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IFJvdXRlcih7XHJcbiAgICByb3V0ZXM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBhdGg6ICcvJyxcclxuICAgICAgICAgICAgY29tcG9uZW50OiBob21lUGFnZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwYXRoOiAnL2Fib3V0JyxcclxuICAgICAgICAgICAgY29tcG9uZW50OiBhYm91dFBhZ2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbn0pXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JvdXRlcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\r\n  * vue-router v2.7.0\r\n  * (c) 2017 Evan You\r\n  * @license MIT\r\n  */\r\n/*  */\r\n\r\nfunction assert (condition, message) {\r\n  if (!condition) {\r\n    throw new Error((\"[vue-router] \" + message))\r\n  }\r\n}\r\n\r\nfunction warn (condition, message) {\r\n  if (process.env.NODE_ENV !== 'production' && !condition) {\r\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\r\n  }\r\n}\r\n\r\nfunction isError (err) {\r\n  return Object.prototype.toString.call(err).indexOf('Error') > -1\r\n}\r\n\r\nvar View = {\r\n  name: 'router-view',\r\n  functional: true,\r\n  props: {\r\n    name: {\r\n      type: String,\r\n      default: 'default'\r\n    }\r\n  },\r\n  render: function render (_, ref) {\r\n    var props = ref.props;\r\n    var children = ref.children;\r\n    var parent = ref.parent;\r\n    var data = ref.data;\r\n\r\n    data.routerView = true;\r\n\r\n    // directly use parent context's createElement() function\r\n    // so that components rendered by router-view can resolve named slots\r\n    var h = parent.$createElement;\r\n    var name = props.name;\r\n    var route = parent.$route;\r\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\r\n\r\n    // determine current view depth, also check to see if the tree\r\n    // has been toggled inactive but kept-alive.\r\n    var depth = 0;\r\n    var inactive = false;\r\n    while (parent && parent._routerRoot !== parent) {\r\n      if (parent.$vnode && parent.$vnode.data.routerView) {\r\n        depth++;\r\n      }\r\n      if (parent._inactive) {\r\n        inactive = true;\r\n      }\r\n      parent = parent.$parent;\r\n    }\r\n    data.routerViewDepth = depth;\r\n\r\n    // render previous view if the tree is inactive and kept-alive\r\n    if (inactive) {\r\n      return h(cache[name], data, children)\r\n    }\r\n\r\n    var matched = route.matched[depth];\r\n    // render empty node if no matched route\r\n    if (!matched) {\r\n      cache[name] = null;\r\n      return h()\r\n    }\r\n\r\n    var component = cache[name] = matched.components[name];\r\n\r\n    // attach instance registration hook\r\n    // this will be called in the instance's injected lifecycle hooks\r\n    data.registerRouteInstance = function (vm, val) {\r\n      // val could be undefined for unregistration\r\n      var current = matched.instances[name];\r\n      if (\r\n        (val && current !== vm) ||\r\n        (!val && current === vm)\r\n      ) {\r\n        matched.instances[name] = val;\r\n      }\r\n    }\r\n\r\n    // also regiseter instance in prepatch hook\r\n    // in case the same component instance is reused across different routes\r\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\r\n      matched.instances[name] = vnode.componentInstance;\r\n    };\r\n\r\n    // resolve props\r\n    data.props = resolveProps(route, matched.props && matched.props[name]);\r\n\r\n    return h(component, data, children)\r\n  }\r\n};\r\n\r\nfunction resolveProps (route, config) {\r\n  switch (typeof config) {\r\n    case 'undefined':\r\n      return\r\n    case 'object':\r\n      return config\r\n    case 'function':\r\n      return config(route)\r\n    case 'boolean':\r\n      return config ? route.params : undefined\r\n    default:\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        warn(\r\n          false,\r\n          \"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", \" +\r\n          \"expecting an object, function or boolean.\"\r\n        );\r\n      }\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar encodeReserveRE = /[!'()*]/g;\r\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\r\nvar commaRE = /%2C/g;\r\n\r\n// fixed encodeURIComponent which is more conformant to RFC3986:\r\n// - escapes [!'()*]\r\n// - preserve commas\r\nvar encode = function (str) { return encodeURIComponent(str)\r\n  .replace(encodeReserveRE, encodeReserveReplacer)\r\n  .replace(commaRE, ','); };\r\n\r\nvar decode = decodeURIComponent;\r\n\r\nfunction resolveQuery (\r\n  query,\r\n  extraQuery,\r\n  _parseQuery\r\n) {\r\n  if ( extraQuery === void 0 ) extraQuery = {};\r\n\r\n  var parse = _parseQuery || parseQuery;\r\n  var parsedQuery;\r\n  try {\r\n    parsedQuery = parse(query || '');\r\n  } catch (e) {\r\n    process.env.NODE_ENV !== 'production' && warn(false, e.message);\r\n    parsedQuery = {};\r\n  }\r\n  for (var key in extraQuery) {\r\n    var val = extraQuery[key];\r\n    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;\r\n  }\r\n  return parsedQuery\r\n}\r\n\r\nfunction parseQuery (query) {\r\n  var res = {};\r\n\r\n  query = query.trim().replace(/^(\\?|#|&)/, '');\r\n\r\n  if (!query) {\r\n    return res\r\n  }\r\n\r\n  query.split('&').forEach(function (param) {\r\n    var parts = param.replace(/\\+/g, ' ').split('=');\r\n    var key = decode(parts.shift());\r\n    var val = parts.length > 0\r\n      ? decode(parts.join('='))\r\n      : null;\r\n\r\n    if (res[key] === undefined) {\r\n      res[key] = val;\r\n    } else if (Array.isArray(res[key])) {\r\n      res[key].push(val);\r\n    } else {\r\n      res[key] = [res[key], val];\r\n    }\r\n  });\r\n\r\n  return res\r\n}\r\n\r\nfunction stringifyQuery (obj) {\r\n  var res = obj ? Object.keys(obj).map(function (key) {\r\n    var val = obj[key];\r\n\r\n    if (val === undefined) {\r\n      return ''\r\n    }\r\n\r\n    if (val === null) {\r\n      return encode(key)\r\n    }\r\n\r\n    if (Array.isArray(val)) {\r\n      var result = [];\r\n      val.forEach(function (val2) {\r\n        if (val2 === undefined) {\r\n          return\r\n        }\r\n        if (val2 === null) {\r\n          result.push(encode(key));\r\n        } else {\r\n          result.push(encode(key) + '=' + encode(val2));\r\n        }\r\n      });\r\n      return result.join('&')\r\n    }\r\n\r\n    return encode(key) + '=' + encode(val)\r\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\r\n  return res ? (\"?\" + res) : ''\r\n}\r\n\r\n/*  */\r\n\r\n\r\nvar trailingSlashRE = /\\/?$/;\r\n\r\nfunction createRoute (\r\n  record,\r\n  location,\r\n  redirectedFrom,\r\n  router\r\n) {\r\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\r\n  var route = {\r\n    name: location.name || (record && record.name),\r\n    meta: (record && record.meta) || {},\r\n    path: location.path || '/',\r\n    hash: location.hash || '',\r\n    query: location.query || {},\r\n    params: location.params || {},\r\n    fullPath: getFullPath(location, stringifyQuery$$1),\r\n    matched: record ? formatMatch(record) : []\r\n  };\r\n  if (redirectedFrom) {\r\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\r\n  }\r\n  return Object.freeze(route)\r\n}\r\n\r\n// the starting route that represents the initial state\r\nvar START = createRoute(null, {\r\n  path: '/'\r\n});\r\n\r\nfunction formatMatch (record) {\r\n  var res = [];\r\n  while (record) {\r\n    res.unshift(record);\r\n    record = record.parent;\r\n  }\r\n  return res\r\n}\r\n\r\nfunction getFullPath (\r\n  ref,\r\n  _stringifyQuery\r\n) {\r\n  var path = ref.path;\r\n  var query = ref.query; if ( query === void 0 ) query = {};\r\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\r\n\r\n  var stringify = _stringifyQuery || stringifyQuery;\r\n  return (path || '/') + stringify(query) + hash\r\n}\r\n\r\nfunction isSameRoute (a, b) {\r\n  if (b === START) {\r\n    return a === b\r\n  } else if (!b) {\r\n    return false\r\n  } else if (a.path && b.path) {\r\n    return (\r\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\r\n      a.hash === b.hash &&\r\n      isObjectEqual(a.query, b.query)\r\n    )\r\n  } else if (a.name && b.name) {\r\n    return (\r\n      a.name === b.name &&\r\n      a.hash === b.hash &&\r\n      isObjectEqual(a.query, b.query) &&\r\n      isObjectEqual(a.params, b.params)\r\n    )\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction isObjectEqual (a, b) {\r\n  if ( a === void 0 ) a = {};\r\n  if ( b === void 0 ) b = {};\r\n\r\n  var aKeys = Object.keys(a);\r\n  var bKeys = Object.keys(b);\r\n  if (aKeys.length !== bKeys.length) {\r\n    return false\r\n  }\r\n  return aKeys.every(function (key) {\r\n    var aVal = a[key];\r\n    var bVal = b[key];\r\n    // check nested equality\r\n    if (typeof aVal === 'object' && typeof bVal === 'object') {\r\n      return isObjectEqual(aVal, bVal)\r\n    }\r\n    return String(aVal) === String(bVal)\r\n  })\r\n}\r\n\r\nfunction isIncludedRoute (current, target) {\r\n  return (\r\n    current.path.replace(trailingSlashRE, '/').indexOf(\r\n      target.path.replace(trailingSlashRE, '/')\r\n    ) === 0 &&\r\n    (!target.hash || current.hash === target.hash) &&\r\n    queryIncludes(current.query, target.query)\r\n  )\r\n}\r\n\r\nfunction queryIncludes (current, target) {\r\n  for (var key in target) {\r\n    if (!(key in current)) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\n/*  */\r\n\r\n// work around weird flow bug\r\nvar toTypes = [String, Object];\r\nvar eventTypes = [String, Array];\r\n\r\nvar Link = {\r\n  name: 'router-link',\r\n  props: {\r\n    to: {\r\n      type: toTypes,\r\n      required: true\r\n    },\r\n    tag: {\r\n      type: String,\r\n      default: 'a'\r\n    },\r\n    exact: Boolean,\r\n    append: Boolean,\r\n    replace: Boolean,\r\n    activeClass: String,\r\n    exactActiveClass: String,\r\n    event: {\r\n      type: eventTypes,\r\n      default: 'click'\r\n    }\r\n  },\r\n  render: function render (h) {\r\n    var this$1 = this;\r\n\r\n    var router = this.$router;\r\n    var current = this.$route;\r\n    var ref = router.resolve(this.to, current, this.append);\r\n    var location = ref.location;\r\n    var route = ref.route;\r\n    var href = ref.href;\r\n\r\n    var classes = {};\r\n    var globalActiveClass = router.options.linkActiveClass;\r\n    var globalExactActiveClass = router.options.linkExactActiveClass;\r\n    // Support global empty active class\r\n    var activeClassFallback = globalActiveClass == null\r\n            ? 'router-link-active'\r\n            : globalActiveClass;\r\n    var exactActiveClassFallback = globalExactActiveClass == null\r\n            ? 'router-link-exact-active'\r\n            : globalExactActiveClass;\r\n    var activeClass = this.activeClass == null\r\n            ? activeClassFallback\r\n            : this.activeClass;\r\n    var exactActiveClass = this.exactActiveClass == null\r\n            ? exactActiveClassFallback\r\n            : this.exactActiveClass;\r\n    var compareTarget = location.path\r\n      ? createRoute(null, location, null, router)\r\n      : route;\r\n\r\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\r\n    classes[activeClass] = this.exact\r\n      ? classes[exactActiveClass]\r\n      : isIncludedRoute(current, compareTarget);\r\n\r\n    var handler = function (e) {\r\n      if (guardEvent(e)) {\r\n        if (this$1.replace) {\r\n          router.replace(location);\r\n        } else {\r\n          router.push(location);\r\n        }\r\n      }\r\n    };\r\n\r\n    var on = { click: guardEvent };\r\n    if (Array.isArray(this.event)) {\r\n      this.event.forEach(function (e) { on[e] = handler; });\r\n    } else {\r\n      on[this.event] = handler;\r\n    }\r\n\r\n    var data = {\r\n      class: classes\r\n    };\r\n\r\n    if (this.tag === 'a') {\r\n      data.on = on;\r\n      data.attrs = { href: href };\r\n    } else {\r\n      // find the first <a> child and apply listener and href\r\n      var a = findAnchor(this.$slots.default);\r\n      if (a) {\r\n        // in case the <a> is a static node\r\n        a.isStatic = false;\r\n        var extend = _Vue.util.extend;\r\n        var aData = a.data = extend({}, a.data);\r\n        aData.on = on;\r\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\r\n        aAttrs.href = href;\r\n      } else {\r\n        // doesn't have <a> child, apply listener to self\r\n        data.on = on;\r\n      }\r\n    }\r\n\r\n    return h(this.tag, data, this.$slots.default)\r\n  }\r\n};\r\n\r\nfunction guardEvent (e) {\r\n  // don't redirect with control keys\r\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\r\n  // don't redirect when preventDefault called\r\n  if (e.defaultPrevented) { return }\r\n  // don't redirect on right click\r\n  if (e.button !== undefined && e.button !== 0) { return }\r\n  // don't redirect if `target=\"_blank\"`\r\n  if (e.currentTarget && e.currentTarget.getAttribute) {\r\n    var target = e.currentTarget.getAttribute('target');\r\n    if (/\\b_blank\\b/i.test(target)) { return }\r\n  }\r\n  // this may be a Weex event which doesn't have this method\r\n  if (e.preventDefault) {\r\n    e.preventDefault();\r\n  }\r\n  return true\r\n}\r\n\r\nfunction findAnchor (children) {\r\n  if (children) {\r\n    var child;\r\n    for (var i = 0; i < children.length; i++) {\r\n      child = children[i];\r\n      if (child.tag === 'a') {\r\n        return child\r\n      }\r\n      if (child.children && (child = findAnchor(child.children))) {\r\n        return child\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvar _Vue;\r\n\r\nfunction install (Vue) {\r\n  if (install.installed) { return }\r\n  install.installed = true;\r\n\r\n  _Vue = Vue;\r\n\r\n  var isDef = function (v) { return v !== undefined; };\r\n\r\n  var registerInstance = function (vm, callVal) {\r\n    var i = vm.$options._parentVnode;\r\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\r\n      i(vm, callVal);\r\n    }\r\n  };\r\n\r\n  Vue.mixin({\r\n    beforeCreate: function beforeCreate () {\r\n      if (isDef(this.$options.router)) {\r\n        this._routerRoot = this;\r\n        this._router = this.$options.router;\r\n        this._router.init(this);\r\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\r\n      } else {\r\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\r\n      }\r\n      registerInstance(this, this);\r\n    },\r\n    destroyed: function destroyed () {\r\n      registerInstance(this);\r\n    }\r\n  });\r\n\r\n  Object.defineProperty(Vue.prototype, '$router', {\r\n    get: function get () { return this._routerRoot._router }\r\n  });\r\n\r\n  Object.defineProperty(Vue.prototype, '$route', {\r\n    get: function get () { return this._routerRoot._route }\r\n  });\r\n\r\n  Vue.component('router-view', View);\r\n  Vue.component('router-link', Link);\r\n\r\n  var strats = Vue.config.optionMergeStrategies;\r\n  // use the same hook merging strategy for route hooks\r\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\r\n}\r\n\r\n/*  */\r\n\r\nvar inBrowser = typeof window !== 'undefined';\r\n\r\n/*  */\r\n\r\nfunction resolvePath (\r\n  relative,\r\n  base,\r\n  append\r\n) {\r\n  var firstChar = relative.charAt(0);\r\n  if (firstChar === '/') {\r\n    return relative\r\n  }\r\n\r\n  if (firstChar === '?' || firstChar === '#') {\r\n    return base + relative\r\n  }\r\n\r\n  var stack = base.split('/');\r\n\r\n  // remove trailing segment if:\r\n  // - not appending\r\n  // - appending to trailing slash (last segment is empty)\r\n  if (!append || !stack[stack.length - 1]) {\r\n    stack.pop();\r\n  }\r\n\r\n  // resolve relative path\r\n  var segments = relative.replace(/^\\//, '').split('/');\r\n  for (var i = 0; i < segments.length; i++) {\r\n    var segment = segments[i];\r\n    if (segment === '..') {\r\n      stack.pop();\r\n    } else if (segment !== '.') {\r\n      stack.push(segment);\r\n    }\r\n  }\r\n\r\n  // ensure leading slash\r\n  if (stack[0] !== '') {\r\n    stack.unshift('');\r\n  }\r\n\r\n  return stack.join('/')\r\n}\r\n\r\nfunction parsePath (path) {\r\n  var hash = '';\r\n  var query = '';\r\n\r\n  var hashIndex = path.indexOf('#');\r\n  if (hashIndex >= 0) {\r\n    hash = path.slice(hashIndex);\r\n    path = path.slice(0, hashIndex);\r\n  }\r\n\r\n  var queryIndex = path.indexOf('?');\r\n  if (queryIndex >= 0) {\r\n    query = path.slice(queryIndex + 1);\r\n    path = path.slice(0, queryIndex);\r\n  }\r\n\r\n  return {\r\n    path: path,\r\n    query: query,\r\n    hash: hash\r\n  }\r\n}\r\n\r\nfunction cleanPath (path) {\r\n  return path.replace(/\\/\\//g, '/')\r\n}\r\n\r\nvar index$1 = Array.isArray || function (arr) {\r\n  return Object.prototype.toString.call(arr) == '[object Array]';\r\n};\r\n\r\n/**\r\n * Expose `pathToRegexp`.\r\n */\r\nvar index = pathToRegexp;\r\nvar parse_1 = parse;\r\nvar compile_1 = compile;\r\nvar tokensToFunction_1 = tokensToFunction;\r\nvar tokensToRegExp_1 = tokensToRegExp;\r\n\r\n/**\r\n * The main path matching regexp utility.\r\n *\r\n * @type {RegExp}\r\n */\r\nvar PATH_REGEXP = new RegExp([\r\n  // Match escaped characters that would otherwise appear in future matches.\r\n  // This allows the user to escape special characters that won't transform.\r\n  '(\\\\\\\\.)',\r\n  // Match Express-style parameters and un-named parameters with a prefix\r\n  // and optional suffixes. Matches appear as:\r\n  //\r\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\r\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\r\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\r\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\r\n].join('|'), 'g');\r\n\r\n/**\r\n * Parse a string for the raw tokens.\r\n *\r\n * @param  {string}  str\r\n * @param  {Object=} options\r\n * @return {!Array}\r\n */\r\nfunction parse (str, options) {\r\n  var tokens = [];\r\n  var key = 0;\r\n  var index = 0;\r\n  var path = '';\r\n  var defaultDelimiter = options && options.delimiter || '/';\r\n  var res;\r\n\r\n  while ((res = PATH_REGEXP.exec(str)) != null) {\r\n    var m = res[0];\r\n    var escaped = res[1];\r\n    var offset = res.index;\r\n    path += str.slice(index, offset);\r\n    index = offset + m.length;\r\n\r\n    // Ignore already escaped sequences.\r\n    if (escaped) {\r\n      path += escaped[1];\r\n      continue\r\n    }\r\n\r\n    var next = str[index];\r\n    var prefix = res[2];\r\n    var name = res[3];\r\n    var capture = res[4];\r\n    var group = res[5];\r\n    var modifier = res[6];\r\n    var asterisk = res[7];\r\n\r\n    // Push the current path onto the tokens.\r\n    if (path) {\r\n      tokens.push(path);\r\n      path = '';\r\n    }\r\n\r\n    var partial = prefix != null && next != null && next !== prefix;\r\n    var repeat = modifier === '+' || modifier === '*';\r\n    var optional = modifier === '?' || modifier === '*';\r\n    var delimiter = res[2] || defaultDelimiter;\r\n    var pattern = capture || group;\r\n\r\n    tokens.push({\r\n      name: name || key++,\r\n      prefix: prefix || '',\r\n      delimiter: delimiter,\r\n      optional: optional,\r\n      repeat: repeat,\r\n      partial: partial,\r\n      asterisk: !!asterisk,\r\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\r\n    });\r\n  }\r\n\r\n  // Match any characters still remaining.\r\n  if (index < str.length) {\r\n    path += str.substr(index);\r\n  }\r\n\r\n  // If the path exists, push it onto the end.\r\n  if (path) {\r\n    tokens.push(path);\r\n  }\r\n\r\n  return tokens\r\n}\r\n\r\n/**\r\n * Compile a string to a template function for the path.\r\n *\r\n * @param  {string}             str\r\n * @param  {Object=}            options\r\n * @return {!function(Object=, Object=)}\r\n */\r\nfunction compile (str, options) {\r\n  return tokensToFunction(parse(str, options))\r\n}\r\n\r\n/**\r\n * Prettier encoding of URI path segments.\r\n *\r\n * @param  {string}\r\n * @return {string}\r\n */\r\nfunction encodeURIComponentPretty (str) {\r\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\r\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\r\n  })\r\n}\r\n\r\n/**\r\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\r\n *\r\n * @param  {string}\r\n * @return {string}\r\n */\r\nfunction encodeAsterisk (str) {\r\n  return encodeURI(str).replace(/[?#]/g, function (c) {\r\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\r\n  })\r\n}\r\n\r\n/**\r\n * Expose a method for transforming tokens into the path function.\r\n */\r\nfunction tokensToFunction (tokens) {\r\n  // Compile all the tokens into regexps.\r\n  var matches = new Array(tokens.length);\r\n\r\n  // Compile all the patterns before compilation.\r\n  for (var i = 0; i < tokens.length; i++) {\r\n    if (typeof tokens[i] === 'object') {\r\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\r\n    }\r\n  }\r\n\r\n  return function (obj, opts) {\r\n    var path = '';\r\n    var data = obj || {};\r\n    var options = opts || {};\r\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\r\n\r\n    for (var i = 0; i < tokens.length; i++) {\r\n      var token = tokens[i];\r\n\r\n      if (typeof token === 'string') {\r\n        path += token;\r\n\r\n        continue\r\n      }\r\n\r\n      var value = data[token.name];\r\n      var segment;\r\n\r\n      if (value == null) {\r\n        if (token.optional) {\r\n          // Prepend partial segment prefixes.\r\n          if (token.partial) {\r\n            path += token.prefix;\r\n          }\r\n\r\n          continue\r\n        } else {\r\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\r\n        }\r\n      }\r\n\r\n      if (index$1(value)) {\r\n        if (!token.repeat) {\r\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\r\n        }\r\n\r\n        if (value.length === 0) {\r\n          if (token.optional) {\r\n            continue\r\n          } else {\r\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\r\n          }\r\n        }\r\n\r\n        for (var j = 0; j < value.length; j++) {\r\n          segment = encode(value[j]);\r\n\r\n          if (!matches[i].test(segment)) {\r\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\r\n          }\r\n\r\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\r\n        }\r\n\r\n        continue\r\n      }\r\n\r\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\r\n\r\n      if (!matches[i].test(segment)) {\r\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\r\n      }\r\n\r\n      path += token.prefix + segment;\r\n    }\r\n\r\n    return path\r\n  }\r\n}\r\n\r\n/**\r\n * Escape a regular expression string.\r\n *\r\n * @param  {string} str\r\n * @return {string}\r\n */\r\nfunction escapeString (str) {\r\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\r\n}\r\n\r\n/**\r\n * Escape the capturing group by escaping special characters and meaning.\r\n *\r\n * @param  {string} group\r\n * @return {string}\r\n */\r\nfunction escapeGroup (group) {\r\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\r\n}\r\n\r\n/**\r\n * Attach the keys as a property of the regexp.\r\n *\r\n * @param  {!RegExp} re\r\n * @param  {Array}   keys\r\n * @return {!RegExp}\r\n */\r\nfunction attachKeys (re, keys) {\r\n  re.keys = keys;\r\n  return re\r\n}\r\n\r\n/**\r\n * Get the flags for a regexp from the options.\r\n *\r\n * @param  {Object} options\r\n * @return {string}\r\n */\r\nfunction flags (options) {\r\n  return options.sensitive ? '' : 'i'\r\n}\r\n\r\n/**\r\n * Pull out keys from a regexp.\r\n *\r\n * @param  {!RegExp} path\r\n * @param  {!Array}  keys\r\n * @return {!RegExp}\r\n */\r\nfunction regexpToRegexp (path, keys) {\r\n  // Use a negative lookahead to match only capturing groups.\r\n  var groups = path.source.match(/\\((?!\\?)/g);\r\n\r\n  if (groups) {\r\n    for (var i = 0; i < groups.length; i++) {\r\n      keys.push({\r\n        name: i,\r\n        prefix: null,\r\n        delimiter: null,\r\n        optional: false,\r\n        repeat: false,\r\n        partial: false,\r\n        asterisk: false,\r\n        pattern: null\r\n      });\r\n    }\r\n  }\r\n\r\n  return attachKeys(path, keys)\r\n}\r\n\r\n/**\r\n * Transform an array into a regexp.\r\n *\r\n * @param  {!Array}  path\r\n * @param  {Array}   keys\r\n * @param  {!Object} options\r\n * @return {!RegExp}\r\n */\r\nfunction arrayToRegexp (path, keys, options) {\r\n  var parts = [];\r\n\r\n  for (var i = 0; i < path.length; i++) {\r\n    parts.push(pathToRegexp(path[i], keys, options).source);\r\n  }\r\n\r\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\r\n\r\n  return attachKeys(regexp, keys)\r\n}\r\n\r\n/**\r\n * Create a path regexp from string input.\r\n *\r\n * @param  {string}  path\r\n * @param  {!Array}  keys\r\n * @param  {!Object} options\r\n * @return {!RegExp}\r\n */\r\nfunction stringToRegexp (path, keys, options) {\r\n  return tokensToRegExp(parse(path, options), keys, options)\r\n}\r\n\r\n/**\r\n * Expose a function for taking tokens and returning a RegExp.\r\n *\r\n * @param  {!Array}          tokens\r\n * @param  {(Array|Object)=} keys\r\n * @param  {Object=}         options\r\n * @return {!RegExp}\r\n */\r\nfunction tokensToRegExp (tokens, keys, options) {\r\n  if (!index$1(keys)) {\r\n    options = /** @type {!Object} */ (keys || options);\r\n    keys = [];\r\n  }\r\n\r\n  options = options || {};\r\n\r\n  var strict = options.strict;\r\n  var end = options.end !== false;\r\n  var route = '';\r\n\r\n  // Iterate over the tokens and create our regexp string.\r\n  for (var i = 0; i < tokens.length; i++) {\r\n    var token = tokens[i];\r\n\r\n    if (typeof token === 'string') {\r\n      route += escapeString(token);\r\n    } else {\r\n      var prefix = escapeString(token.prefix);\r\n      var capture = '(?:' + token.pattern + ')';\r\n\r\n      keys.push(token);\r\n\r\n      if (token.repeat) {\r\n        capture += '(?:' + prefix + capture + ')*';\r\n      }\r\n\r\n      if (token.optional) {\r\n        if (!token.partial) {\r\n          capture = '(?:' + prefix + '(' + capture + '))?';\r\n        } else {\r\n          capture = prefix + '(' + capture + ')?';\r\n        }\r\n      } else {\r\n        capture = prefix + '(' + capture + ')';\r\n      }\r\n\r\n      route += capture;\r\n    }\r\n  }\r\n\r\n  var delimiter = escapeString(options.delimiter || '/');\r\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\r\n\r\n  // In non-strict mode we allow a slash at the end of match. If the path to\r\n  // match already ends with a slash, we remove it for consistency. The slash\r\n  // is valid at the end of a path match, not in the middle. This is important\r\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\r\n  if (!strict) {\r\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\r\n  }\r\n\r\n  if (end) {\r\n    route += '$';\r\n  } else {\r\n    // In non-ending mode, we need the capturing groups to match as much as\r\n    // possible by using a positive lookahead to the end or next path segment.\r\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\r\n  }\r\n\r\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\r\n}\r\n\r\n/**\r\n * Normalize the given path string, returning a regular expression.\r\n *\r\n * An empty array can be passed in for the keys, which will hold the\r\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n *\r\n * @param  {(string|RegExp|Array)} path\r\n * @param  {(Array|Object)=}       keys\r\n * @param  {Object=}               options\r\n * @return {!RegExp}\r\n */\r\nfunction pathToRegexp (path, keys, options) {\r\n  if (!index$1(keys)) {\r\n    options = /** @type {!Object} */ (keys || options);\r\n    keys = [];\r\n  }\r\n\r\n  options = options || {};\r\n\r\n  if (path instanceof RegExp) {\r\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\r\n  }\r\n\r\n  if (index$1(path)) {\r\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\r\n  }\r\n\r\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\r\n}\r\n\r\nindex.parse = parse_1;\r\nindex.compile = compile_1;\r\nindex.tokensToFunction = tokensToFunction_1;\r\nindex.tokensToRegExp = tokensToRegExp_1;\r\n\r\n/*  */\r\n\r\nvar regexpCompileCache = Object.create(null);\r\n\r\nfunction fillParams (\r\n  path,\r\n  params,\r\n  routeMsg\r\n) {\r\n  try {\r\n    var filler =\r\n      regexpCompileCache[path] ||\r\n      (regexpCompileCache[path] = index.compile(path));\r\n    return filler(params || {}, { pretty: true })\r\n  } catch (e) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\r\n    }\r\n    return ''\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nfunction createRouteMap (\r\n  routes,\r\n  oldPathList,\r\n  oldPathMap,\r\n  oldNameMap\r\n) {\r\n  // the path list is used to control path matching priority\r\n  var pathList = oldPathList || [];\r\n  var pathMap = oldPathMap || Object.create(null);\r\n  var nameMap = oldNameMap || Object.create(null);\r\n\r\n  routes.forEach(function (route) {\r\n    addRouteRecord(pathList, pathMap, nameMap, route);\r\n  });\r\n\r\n  // ensure wildcard routes are always at the end\r\n  for (var i = 0, l = pathList.length; i < l; i++) {\r\n    if (pathList[i] === '*') {\r\n      pathList.push(pathList.splice(i, 1)[0]);\r\n      l--;\r\n      i--;\r\n    }\r\n  }\r\n\r\n  return {\r\n    pathList: pathList,\r\n    pathMap: pathMap,\r\n    nameMap: nameMap\r\n  }\r\n}\r\n\r\nfunction addRouteRecord (\r\n  pathList,\r\n  pathMap,\r\n  nameMap,\r\n  route,\r\n  parent,\r\n  matchAs\r\n) {\r\n  var path = route.path;\r\n  var name = route.name;\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\r\n    assert(\r\n      typeof route.component !== 'string',\r\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\r\n      \"string id. Use an actual component instead.\"\r\n    );\r\n  }\r\n\r\n  var normalizedPath = normalizePath(path, parent);\r\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\r\n\r\n  if (typeof route.caseSensitive === 'boolean') {\r\n    pathToRegexpOptions.sensitive = route.caseSensitive;\r\n  }\r\n\r\n  var record = {\r\n    path: normalizedPath,\r\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\r\n    components: route.components || { default: route.component },\r\n    instances: {},\r\n    name: name,\r\n    parent: parent,\r\n    matchAs: matchAs,\r\n    redirect: route.redirect,\r\n    beforeEnter: route.beforeEnter,\r\n    meta: route.meta || {},\r\n    props: route.props == null\r\n      ? {}\r\n      : route.components\r\n        ? route.props\r\n        : { default: route.props }\r\n  };\r\n\r\n  if (route.children) {\r\n    // Warn if route is named, does not redirect and has a default child route.\r\n    // If users navigate to this route by name, the default child will\r\n    // not be rendered (GH Issue #629)\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (route.name && !route.redirect && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\r\n        warn(\r\n          false,\r\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\r\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\r\n          \"the default child route will not be rendered. Remove the name from \" +\r\n          \"this route and use the name of the default child route for named \" +\r\n          \"links instead.\"\r\n        );\r\n      }\r\n    }\r\n    route.children.forEach(function (child) {\r\n      var childMatchAs = matchAs\r\n        ? cleanPath((matchAs + \"/\" + (child.path)))\r\n        : undefined;\r\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\r\n    });\r\n  }\r\n\r\n  if (route.alias !== undefined) {\r\n    var aliases = Array.isArray(route.alias)\r\n      ? route.alias\r\n      : [route.alias];\r\n\r\n    aliases.forEach(function (alias) {\r\n      var aliasRoute = {\r\n        path: alias,\r\n        children: route.children\r\n      };\r\n      addRouteRecord(\r\n        pathList,\r\n        pathMap,\r\n        nameMap,\r\n        aliasRoute,\r\n        parent,\r\n        record.path || '/' // matchAs\r\n      );\r\n    });\r\n  }\r\n\r\n  if (!pathMap[record.path]) {\r\n    pathList.push(record.path);\r\n    pathMap[record.path] = record;\r\n  }\r\n\r\n  if (name) {\r\n    if (!nameMap[name]) {\r\n      nameMap[name] = record;\r\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\r\n      warn(\r\n        false,\r\n        \"Duplicate named routes definition: \" +\r\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction compileRouteRegex (path, pathToRegexpOptions) {\r\n  var regex = index(path, [], pathToRegexpOptions);\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    var keys = {};\r\n    regex.keys.forEach(function (key) {\r\n      warn(!keys[key.name], (\"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\"));\r\n      keys[key.name] = true;\r\n    });\r\n  }\r\n  return regex\r\n}\r\n\r\nfunction normalizePath (path, parent) {\r\n  path = path.replace(/\\/$/, '');\r\n  if (path[0] === '/') { return path }\r\n  if (parent == null) { return path }\r\n  return cleanPath(((parent.path) + \"/\" + path))\r\n}\r\n\r\n/*  */\r\n\r\n\r\nfunction normalizeLocation (\r\n  raw,\r\n  current,\r\n  append,\r\n  router\r\n) {\r\n  var next = typeof raw === 'string' ? { path: raw } : raw;\r\n  // named target\r\n  if (next.name || next._normalized) {\r\n    return next\r\n  }\r\n\r\n  // relative params\r\n  if (!next.path && next.params && current) {\r\n    next = assign({}, next);\r\n    next._normalized = true;\r\n    var params = assign(assign({}, current.params), next.params);\r\n    if (current.name) {\r\n      next.name = current.name;\r\n      next.params = params;\r\n    } else if (current.matched.length) {\r\n      var rawPath = current.matched[current.matched.length - 1].path;\r\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\r\n    } else if (process.env.NODE_ENV !== 'production') {\r\n      warn(false, \"relative params navigation requires a current route.\");\r\n    }\r\n    return next\r\n  }\r\n\r\n  var parsedPath = parsePath(next.path || '');\r\n  var basePath = (current && current.path) || '/';\r\n  var path = parsedPath.path\r\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\r\n    : basePath;\r\n\r\n  var query = resolveQuery(\r\n    parsedPath.query,\r\n    next.query,\r\n    router && router.options.parseQuery\r\n  );\r\n\r\n  var hash = next.hash || parsedPath.hash;\r\n  if (hash && hash.charAt(0) !== '#') {\r\n    hash = \"#\" + hash;\r\n  }\r\n\r\n  return {\r\n    _normalized: true,\r\n    path: path,\r\n    query: query,\r\n    hash: hash\r\n  }\r\n}\r\n\r\nfunction assign (a, b) {\r\n  for (var key in b) {\r\n    a[key] = b[key];\r\n  }\r\n  return a\r\n}\r\n\r\n/*  */\r\n\r\n\r\nfunction createMatcher (\r\n  routes,\r\n  router\r\n) {\r\n  var ref = createRouteMap(routes);\r\n  var pathList = ref.pathList;\r\n  var pathMap = ref.pathMap;\r\n  var nameMap = ref.nameMap;\r\n\r\n  function addRoutes (routes) {\r\n    createRouteMap(routes, pathList, pathMap, nameMap);\r\n  }\r\n\r\n  function match (\r\n    raw,\r\n    currentRoute,\r\n    redirectedFrom\r\n  ) {\r\n    var location = normalizeLocation(raw, currentRoute, false, router);\r\n    var name = location.name;\r\n\r\n    if (name) {\r\n      var record = nameMap[name];\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\r\n      }\r\n      if (!record) { return _createRoute(null, location) }\r\n      var paramNames = record.regex.keys\r\n        .filter(function (key) { return !key.optional; })\r\n        .map(function (key) { return key.name; });\r\n\r\n      if (typeof location.params !== 'object') {\r\n        location.params = {};\r\n      }\r\n\r\n      if (currentRoute && typeof currentRoute.params === 'object') {\r\n        for (var key in currentRoute.params) {\r\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\r\n            location.params[key] = currentRoute.params[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      if (record) {\r\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\r\n        return _createRoute(record, location, redirectedFrom)\r\n      }\r\n    } else if (location.path) {\r\n      location.params = {};\r\n      for (var i = 0; i < pathList.length; i++) {\r\n        var path = pathList[i];\r\n        var record$1 = pathMap[path];\r\n        if (matchRoute(record$1.regex, location.path, location.params)) {\r\n          return _createRoute(record$1, location, redirectedFrom)\r\n        }\r\n      }\r\n    }\r\n    // no match\r\n    return _createRoute(null, location)\r\n  }\r\n\r\n  function redirect (\r\n    record,\r\n    location\r\n  ) {\r\n    var originalRedirect = record.redirect;\r\n    var redirect = typeof originalRedirect === 'function'\r\n        ? originalRedirect(createRoute(record, location, null, router))\r\n        : originalRedirect;\r\n\r\n    if (typeof redirect === 'string') {\r\n      redirect = { path: redirect };\r\n    }\r\n\r\n    if (!redirect || typeof redirect !== 'object') {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        warn(\r\n          false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\r\n        );\r\n      }\r\n      return _createRoute(null, location)\r\n    }\r\n\r\n    var re = redirect;\r\n    var name = re.name;\r\n    var path = re.path;\r\n    var query = location.query;\r\n    var hash = location.hash;\r\n    var params = location.params;\r\n    query = re.hasOwnProperty('query') ? re.query : query;\r\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\r\n    params = re.hasOwnProperty('params') ? re.params : params;\r\n\r\n    if (name) {\r\n      // resolved named direct\r\n      var targetRecord = nameMap[name];\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\r\n      }\r\n      return match({\r\n        _normalized: true,\r\n        name: name,\r\n        query: query,\r\n        hash: hash,\r\n        params: params\r\n      }, undefined, location)\r\n    } else if (path) {\r\n      // 1. resolve relative redirect\r\n      var rawPath = resolveRecordPath(path, record);\r\n      // 2. resolve params\r\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\r\n      // 3. rematch with existing query and hash\r\n      return match({\r\n        _normalized: true,\r\n        path: resolvedPath,\r\n        query: query,\r\n        hash: hash\r\n      }, undefined, location)\r\n    } else {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\r\n      }\r\n      return _createRoute(null, location)\r\n    }\r\n  }\r\n\r\n  function alias (\r\n    record,\r\n    location,\r\n    matchAs\r\n  ) {\r\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\r\n    var aliasedMatch = match({\r\n      _normalized: true,\r\n      path: aliasedPath\r\n    });\r\n    if (aliasedMatch) {\r\n      var matched = aliasedMatch.matched;\r\n      var aliasedRecord = matched[matched.length - 1];\r\n      location.params = aliasedMatch.params;\r\n      return _createRoute(aliasedRecord, location)\r\n    }\r\n    return _createRoute(null, location)\r\n  }\r\n\r\n  function _createRoute (\r\n    record,\r\n    location,\r\n    redirectedFrom\r\n  ) {\r\n    if (record && record.redirect) {\r\n      return redirect(record, redirectedFrom || location)\r\n    }\r\n    if (record && record.matchAs) {\r\n      return alias(record, location, record.matchAs)\r\n    }\r\n    return createRoute(record, location, redirectedFrom, router)\r\n  }\r\n\r\n  return {\r\n    match: match,\r\n    addRoutes: addRoutes\r\n  }\r\n}\r\n\r\nfunction matchRoute (\r\n  regex,\r\n  path,\r\n  params\r\n) {\r\n  var m = path.match(regex);\r\n\r\n  if (!m) {\r\n    return false\r\n  } else if (!params) {\r\n    return true\r\n  }\r\n\r\n  for (var i = 1, len = m.length; i < len; ++i) {\r\n    var key = regex.keys[i - 1];\r\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\r\n    if (key) {\r\n      params[key.name] = val;\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nfunction resolveRecordPath (path, record) {\r\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\r\n}\r\n\r\n/*  */\r\n\r\n\r\nvar positionStore = Object.create(null);\r\n\r\nfunction setupScroll () {\r\n  window.addEventListener('popstate', function (e) {\r\n    saveScrollPosition();\r\n    if (e.state && e.state.key) {\r\n      setStateKey(e.state.key);\r\n    }\r\n  });\r\n}\r\n\r\nfunction handleScroll (\r\n  router,\r\n  to,\r\n  from,\r\n  isPop\r\n) {\r\n  if (!router.app) {\r\n    return\r\n  }\r\n\r\n  var behavior = router.options.scrollBehavior;\r\n  if (!behavior) {\r\n    return\r\n  }\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\r\n  }\r\n\r\n  // wait until re-render finishes before scrolling\r\n  router.app.$nextTick(function () {\r\n    var position = getScrollPosition();\r\n    var shouldScroll = behavior(to, from, isPop ? position : null);\r\n    if (!shouldScroll) {\r\n      return\r\n    }\r\n    var isObject = typeof shouldScroll === 'object';\r\n    if (isObject && typeof shouldScroll.selector === 'string') {\r\n      var el = document.querySelector(shouldScroll.selector);\r\n      if (el) {\r\n        var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};\r\n        offset = normalizeOffset(offset);\r\n        position = getElementPosition(el, offset);\r\n      } else if (isValidPosition(shouldScroll)) {\r\n        position = normalizePosition(shouldScroll);\r\n      }\r\n    } else if (isObject && isValidPosition(shouldScroll)) {\r\n      position = normalizePosition(shouldScroll);\r\n    }\r\n\r\n    if (position) {\r\n      window.scrollTo(position.x, position.y);\r\n    }\r\n  });\r\n}\r\n\r\nfunction saveScrollPosition () {\r\n  var key = getStateKey();\r\n  if (key) {\r\n    positionStore[key] = {\r\n      x: window.pageXOffset,\r\n      y: window.pageYOffset\r\n    };\r\n  }\r\n}\r\n\r\nfunction getScrollPosition () {\r\n  var key = getStateKey();\r\n  if (key) {\r\n    return positionStore[key]\r\n  }\r\n}\r\n\r\nfunction getElementPosition (el, offset) {\r\n  var docEl = document.documentElement;\r\n  var docRect = docEl.getBoundingClientRect();\r\n  var elRect = el.getBoundingClientRect();\r\n  return {\r\n    x: elRect.left - docRect.left - offset.x,\r\n    y: elRect.top - docRect.top - offset.y\r\n  }\r\n}\r\n\r\nfunction isValidPosition (obj) {\r\n  return isNumber(obj.x) || isNumber(obj.y)\r\n}\r\n\r\nfunction normalizePosition (obj) {\r\n  return {\r\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\r\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\r\n  }\r\n}\r\n\r\nfunction normalizeOffset (obj) {\r\n  return {\r\n    x: isNumber(obj.x) ? obj.x : 0,\r\n    y: isNumber(obj.y) ? obj.y : 0\r\n  }\r\n}\r\n\r\nfunction isNumber (v) {\r\n  return typeof v === 'number'\r\n}\r\n\r\n/*  */\r\n\r\nvar supportsPushState = inBrowser && (function () {\r\n  var ua = window.navigator.userAgent;\r\n\r\n  if (\r\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\r\n    ua.indexOf('Mobile Safari') !== -1 &&\r\n    ua.indexOf('Chrome') === -1 &&\r\n    ua.indexOf('Windows Phone') === -1\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  return window.history && 'pushState' in window.history\r\n})();\r\n\r\n// use User Timing api (if present) for more accurate key precision\r\nvar Time = inBrowser && window.performance && window.performance.now\r\n  ? window.performance\r\n  : Date;\r\n\r\nvar _key = genKey();\r\n\r\nfunction genKey () {\r\n  return Time.now().toFixed(3)\r\n}\r\n\r\nfunction getStateKey () {\r\n  return _key\r\n}\r\n\r\nfunction setStateKey (key) {\r\n  _key = key;\r\n}\r\n\r\nfunction pushState (url, replace) {\r\n  saveScrollPosition();\r\n  // try...catch the pushState call to get around Safari\r\n  // DOM Exception 18 where it limits to 100 pushState calls\r\n  var history = window.history;\r\n  try {\r\n    if (replace) {\r\n      history.replaceState({ key: _key }, '', url);\r\n    } else {\r\n      _key = genKey();\r\n      history.pushState({ key: _key }, '', url);\r\n    }\r\n  } catch (e) {\r\n    window.location[replace ? 'replace' : 'assign'](url);\r\n  }\r\n}\r\n\r\nfunction replaceState (url) {\r\n  pushState(url, true);\r\n}\r\n\r\n/*  */\r\n\r\nfunction runQueue (queue, fn, cb) {\r\n  var step = function (index) {\r\n    if (index >= queue.length) {\r\n      cb();\r\n    } else {\r\n      if (queue[index]) {\r\n        fn(queue[index], function () {\r\n          step(index + 1);\r\n        });\r\n      } else {\r\n        step(index + 1);\r\n      }\r\n    }\r\n  };\r\n  step(0);\r\n}\r\n\r\n/*  */\r\n\r\nfunction resolveAsyncComponents (matched) {\r\n  return function (to, from, next) {\r\n    var hasAsync = false;\r\n    var pending = 0;\r\n    var error = null;\r\n\r\n    flatMapComponents(matched, function (def, _, match, key) {\r\n      // if it's a function and doesn't have cid attached,\r\n      // assume it's an async component resolve function.\r\n      // we are not using Vue's default async resolving mechanism because\r\n      // we want to halt the navigation until the incoming component has been\r\n      // resolved.\r\n      if (typeof def === 'function' && def.cid === undefined) {\r\n        hasAsync = true;\r\n        pending++;\r\n\r\n        var resolve = once(function (resolvedDef) {\r\n          if (resolvedDef.__esModule && resolvedDef.default) {\r\n            resolvedDef = resolvedDef.default;\r\n          }\r\n          // save resolved on async factory in case it's used elsewhere\r\n          def.resolved = typeof resolvedDef === 'function'\r\n            ? resolvedDef\r\n            : _Vue.extend(resolvedDef);\r\n          match.components[key] = resolvedDef;\r\n          pending--;\r\n          if (pending <= 0) {\r\n            next();\r\n          }\r\n        });\r\n\r\n        var reject = once(function (reason) {\r\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\r\n          process.env.NODE_ENV !== 'production' && warn(false, msg);\r\n          if (!error) {\r\n            error = isError(reason)\r\n              ? reason\r\n              : new Error(msg);\r\n            next(error);\r\n          }\r\n        });\r\n\r\n        var res;\r\n        try {\r\n          res = def(resolve, reject);\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n        if (res) {\r\n          if (typeof res.then === 'function') {\r\n            res.then(resolve, reject);\r\n          } else {\r\n            // new syntax in Vue 2.3\r\n            var comp = res.component;\r\n            if (comp && typeof comp.then === 'function') {\r\n              comp.then(resolve, reject);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!hasAsync) { next(); }\r\n  }\r\n}\r\n\r\nfunction flatMapComponents (\r\n  matched,\r\n  fn\r\n) {\r\n  return flatten(matched.map(function (m) {\r\n    return Object.keys(m.components).map(function (key) { return fn(\r\n      m.components[key],\r\n      m.instances[key],\r\n      m, key\r\n    ); })\r\n  }))\r\n}\r\n\r\nfunction flatten (arr) {\r\n  return Array.prototype.concat.apply([], arr)\r\n}\r\n\r\n// in Webpack 2, require.ensure now also returns a Promise\r\n// so the resolve/reject functions may get called an extra time\r\n// if the user uses an arrow function shorthand that happens to\r\n// return that Promise.\r\nfunction once (fn) {\r\n  var called = false;\r\n  return function () {\r\n    var args = [], len = arguments.length;\r\n    while ( len-- ) args[ len ] = arguments[ len ];\r\n\r\n    if (called) { return }\r\n    called = true;\r\n    return fn.apply(this, args)\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\nvar History = function History (router, base) {\r\n  this.router = router;\r\n  this.base = normalizeBase(base);\r\n  // start with a route object that stands for \"nowhere\"\r\n  this.current = START;\r\n  this.pending = null;\r\n  this.ready = false;\r\n  this.readyCbs = [];\r\n  this.readyErrorCbs = [];\r\n  this.errorCbs = [];\r\n};\r\n\r\nHistory.prototype.listen = function listen (cb) {\r\n  this.cb = cb;\r\n};\r\n\r\nHistory.prototype.onReady = function onReady (cb, errorCb) {\r\n  if (this.ready) {\r\n    cb();\r\n  } else {\r\n    this.readyCbs.push(cb);\r\n    if (errorCb) {\r\n      this.readyErrorCbs.push(errorCb);\r\n    }\r\n  }\r\n};\r\n\r\nHistory.prototype.onError = function onError (errorCb) {\r\n  this.errorCbs.push(errorCb);\r\n};\r\n\r\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\r\n    var this$1 = this;\r\n\r\n  var route = this.router.match(location, this.current);\r\n  this.confirmTransition(route, function () {\r\n    this$1.updateRoute(route);\r\n    onComplete && onComplete(route);\r\n    this$1.ensureURL();\r\n\r\n    // fire ready cbs once\r\n    if (!this$1.ready) {\r\n      this$1.ready = true;\r\n      this$1.readyCbs.forEach(function (cb) { cb(route); });\r\n    }\r\n  }, function (err) {\r\n    if (onAbort) {\r\n      onAbort(err);\r\n    }\r\n    if (err && !this$1.ready) {\r\n      this$1.ready = true;\r\n      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });\r\n    }\r\n  });\r\n};\r\n\r\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\r\n    var this$1 = this;\r\n\r\n  var current = this.current;\r\n  var abort = function (err) {\r\n    if (isError(err)) {\r\n      if (this$1.errorCbs.length) {\r\n        this$1.errorCbs.forEach(function (cb) { cb(err); });\r\n      } else {\r\n        warn(false, 'uncaught error during route navigation:');\r\n        console.error(err);\r\n      }\r\n    }\r\n    onAbort && onAbort(err);\r\n  };\r\n  if (\r\n    isSameRoute(route, current) &&\r\n    // in the case the route map has been dynamically appended to\r\n    route.matched.length === current.matched.length\r\n  ) {\r\n    this.ensureURL();\r\n    return abort()\r\n  }\r\n\r\n  var ref = resolveQueue(this.current.matched, route.matched);\r\n    var updated = ref.updated;\r\n    var deactivated = ref.deactivated;\r\n    var activated = ref.activated;\r\n\r\n  var queue = [].concat(\r\n    // in-component leave guards\r\n    extractLeaveGuards(deactivated),\r\n    // global before hooks\r\n    this.router.beforeHooks,\r\n    // in-component update hooks\r\n    extractUpdateHooks(updated),\r\n    // in-config enter guards\r\n    activated.map(function (m) { return m.beforeEnter; }),\r\n    // async components\r\n    resolveAsyncComponents(activated)\r\n  );\r\n\r\n  this.pending = route;\r\n  var iterator = function (hook, next) {\r\n    if (this$1.pending !== route) {\r\n      return abort()\r\n    }\r\n    try {\r\n      hook(route, current, function (to) {\r\n        if (to === false || isError(to)) {\r\n          // next(false) -> abort navigation, ensure current URL\r\n          this$1.ensureURL(true);\r\n          abort(to);\r\n        } else if (\r\n          typeof to === 'string' ||\r\n          (typeof to === 'object' && (\r\n            typeof to.path === 'string' ||\r\n            typeof to.name === 'string'\r\n          ))\r\n        ) {\r\n          // next('/') or next({ path: '/' }) -> redirect\r\n          abort();\r\n          if (typeof to === 'object' && to.replace) {\r\n            this$1.replace(to);\r\n          } else {\r\n            this$1.push(to);\r\n          }\r\n        } else {\r\n          // confirm transition and pass on the value\r\n          next(to);\r\n        }\r\n      });\r\n    } catch (e) {\r\n      abort(e);\r\n    }\r\n  };\r\n\r\n  runQueue(queue, iterator, function () {\r\n    var postEnterCbs = [];\r\n    var isValid = function () { return this$1.current === route; };\r\n    // wait until async components are resolved before\r\n    // extracting in-component enter guards\r\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\r\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\r\n    runQueue(queue, iterator, function () {\r\n      if (this$1.pending !== route) {\r\n        return abort()\r\n      }\r\n      this$1.pending = null;\r\n      onComplete(route);\r\n      if (this$1.router.app) {\r\n        this$1.router.app.$nextTick(function () {\r\n          postEnterCbs.forEach(function (cb) { cb(); });\r\n        });\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nHistory.prototype.updateRoute = function updateRoute (route) {\r\n  var prev = this.current;\r\n  this.current = route;\r\n  this.cb && this.cb(route);\r\n  this.router.afterHooks.forEach(function (hook) {\r\n    hook && hook(route, prev);\r\n  });\r\n};\r\n\r\nfunction normalizeBase (base) {\r\n  if (!base) {\r\n    if (inBrowser) {\r\n      // respect <base> tag\r\n      var baseEl = document.querySelector('base');\r\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\r\n      // strip full URL origin\r\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\r\n    } else {\r\n      base = '/';\r\n    }\r\n  }\r\n  // make sure there's the starting slash\r\n  if (base.charAt(0) !== '/') {\r\n    base = '/' + base;\r\n  }\r\n  // remove trailing slash\r\n  return base.replace(/\\/$/, '')\r\n}\r\n\r\nfunction resolveQueue (\r\n  current,\r\n  next\r\n) {\r\n  var i;\r\n  var max = Math.max(current.length, next.length);\r\n  for (i = 0; i < max; i++) {\r\n    if (current[i] !== next[i]) {\r\n      break\r\n    }\r\n  }\r\n  return {\r\n    updated: next.slice(0, i),\r\n    activated: next.slice(i),\r\n    deactivated: current.slice(i)\r\n  }\r\n}\r\n\r\nfunction extractGuards (\r\n  records,\r\n  name,\r\n  bind,\r\n  reverse\r\n) {\r\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\r\n    var guard = extractGuard(def, name);\r\n    if (guard) {\r\n      return Array.isArray(guard)\r\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\r\n        : bind(guard, instance, match, key)\r\n    }\r\n  });\r\n  return flatten(reverse ? guards.reverse() : guards)\r\n}\r\n\r\nfunction extractGuard (\r\n  def,\r\n  key\r\n) {\r\n  if (typeof def !== 'function') {\r\n    // extend now so that global mixins are applied.\r\n    def = _Vue.extend(def);\r\n  }\r\n  return def.options[key]\r\n}\r\n\r\nfunction extractLeaveGuards (deactivated) {\r\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\r\n}\r\n\r\nfunction extractUpdateHooks (updated) {\r\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\r\n}\r\n\r\nfunction bindGuard (guard, instance) {\r\n  if (instance) {\r\n    return function boundRouteGuard () {\r\n      return guard.apply(instance, arguments)\r\n    }\r\n  }\r\n}\r\n\r\nfunction extractEnterGuards (\r\n  activated,\r\n  cbs,\r\n  isValid\r\n) {\r\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\r\n    return bindEnterGuard(guard, match, key, cbs, isValid)\r\n  })\r\n}\r\n\r\nfunction bindEnterGuard (\r\n  guard,\r\n  match,\r\n  key,\r\n  cbs,\r\n  isValid\r\n) {\r\n  return function routeEnterGuard (to, from, next) {\r\n    return guard(to, from, function (cb) {\r\n      next(cb);\r\n      if (typeof cb === 'function') {\r\n        cbs.push(function () {\r\n          // #750\r\n          // if a router-view is wrapped with an out-in transition,\r\n          // the instance may not have been registered at this time.\r\n          // we will need to poll for registration until current route\r\n          // is no longer valid.\r\n          poll(cb, match.instances, key, isValid);\r\n        });\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction poll (\r\n  cb, // somehow flow cannot infer this is a function\r\n  instances,\r\n  key,\r\n  isValid\r\n) {\r\n  if (instances[key]) {\r\n    cb(instances[key]);\r\n  } else if (isValid()) {\r\n    setTimeout(function () {\r\n      poll(cb, instances, key, isValid);\r\n    }, 16);\r\n  }\r\n}\r\n\r\n/*  */\r\n\r\n\r\nvar HTML5History = (function (History$$1) {\r\n  function HTML5History (router, base) {\r\n    var this$1 = this;\r\n\r\n    History$$1.call(this, router, base);\r\n\r\n    var expectScroll = router.options.scrollBehavior;\r\n\r\n    if (expectScroll) {\r\n      setupScroll();\r\n    }\r\n\r\n    window.addEventListener('popstate', function (e) {\r\n      var current = this$1.current;\r\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\r\n        if (expectScroll) {\r\n          handleScroll(router, route, current, true);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\r\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\r\n  HTML5History.prototype.constructor = HTML5History;\r\n\r\n  HTML5History.prototype.go = function go (n) {\r\n    window.history.go(n);\r\n  };\r\n\r\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\r\n    var this$1 = this;\r\n\r\n    var ref = this;\r\n    var fromRoute = ref.current;\r\n    this.transitionTo(location, function (route) {\r\n      pushState(cleanPath(this$1.base + route.fullPath));\r\n      handleScroll(this$1.router, route, fromRoute, false);\r\n      onComplete && onComplete(route);\r\n    }, onAbort);\r\n  };\r\n\r\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\r\n    var this$1 = this;\r\n\r\n    var ref = this;\r\n    var fromRoute = ref.current;\r\n    this.transitionTo(location, function (route) {\r\n      replaceState(cleanPath(this$1.base + route.fullPath));\r\n      handleScroll(this$1.router, route, fromRoute, false);\r\n      onComplete && onComplete(route);\r\n    }, onAbort);\r\n  };\r\n\r\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\r\n    if (getLocation(this.base) !== this.current.fullPath) {\r\n      var current = cleanPath(this.base + this.current.fullPath);\r\n      push ? pushState(current) : replaceState(current);\r\n    }\r\n  };\r\n\r\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\r\n    return getLocation(this.base)\r\n  };\r\n\r\n  return HTML5History;\r\n}(History));\r\n\r\nfunction getLocation (base) {\r\n  var path = window.location.pathname;\r\n  if (base && path.indexOf(base) === 0) {\r\n    path = path.slice(base.length);\r\n  }\r\n  return (path || '/') + window.location.search + window.location.hash\r\n}\r\n\r\n/*  */\r\n\r\n\r\nvar HashHistory = (function (History$$1) {\r\n  function HashHistory (router, base, fallback) {\r\n    History$$1.call(this, router, base);\r\n    // check history fallback deeplinking\r\n    if (fallback && checkFallback(this.base)) {\r\n      return\r\n    }\r\n    ensureSlash();\r\n  }\r\n\r\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\r\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\r\n  HashHistory.prototype.constructor = HashHistory;\r\n\r\n  // this is delayed until the app mounts\r\n  // to avoid the hashchange listener being fired too early\r\n  HashHistory.prototype.setupListeners = function setupListeners () {\r\n    var this$1 = this;\r\n\r\n    window.addEventListener('hashchange', function () {\r\n      if (!ensureSlash()) {\r\n        return\r\n      }\r\n      this$1.transitionTo(getHash(), function (route) {\r\n        replaceHash(route.fullPath);\r\n      });\r\n    });\r\n  };\r\n\r\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\r\n    this.transitionTo(location, function (route) {\r\n      pushHash(route.fullPath);\r\n      onComplete && onComplete(route);\r\n    }, onAbort);\r\n  };\r\n\r\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\r\n    this.transitionTo(location, function (route) {\r\n      replaceHash(route.fullPath);\r\n      onComplete && onComplete(route);\r\n    }, onAbort);\r\n  };\r\n\r\n  HashHistory.prototype.go = function go (n) {\r\n    window.history.go(n);\r\n  };\r\n\r\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\r\n    var current = this.current.fullPath;\r\n    if (getHash() !== current) {\r\n      push ? pushHash(current) : replaceHash(current);\r\n    }\r\n  };\r\n\r\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\r\n    return getHash()\r\n  };\r\n\r\n  return HashHistory;\r\n}(History));\r\n\r\nfunction checkFallback (base) {\r\n  var location = getLocation(base);\r\n  if (!/^\\/#/.test(location)) {\r\n    window.location.replace(\r\n      cleanPath(base + '/#' + location)\r\n    );\r\n    return true\r\n  }\r\n}\r\n\r\nfunction ensureSlash () {\r\n  var path = getHash();\r\n  if (path.charAt(0) === '/') {\r\n    return true\r\n  }\r\n  replaceHash('/' + path);\r\n  return false\r\n}\r\n\r\nfunction getHash () {\r\n  // We can't use window.location.hash here because it's not\r\n  // consistent across browsers - Firefox will pre-decode it!\r\n  var href = window.location.href;\r\n  var index = href.indexOf('#');\r\n  return index === -1 ? '' : href.slice(index + 1)\r\n}\r\n\r\nfunction pushHash (path) {\r\n  window.location.hash = path;\r\n}\r\n\r\nfunction replaceHash (path) {\r\n  var href = window.location.href;\r\n  var i = href.indexOf('#');\r\n  var base = i >= 0 ? href.slice(0, i) : href;\r\n  window.location.replace((base + \"#\" + path));\r\n}\r\n\r\n/*  */\r\n\r\n\r\nvar AbstractHistory = (function (History$$1) {\r\n  function AbstractHistory (router, base) {\r\n    History$$1.call(this, router, base);\r\n    this.stack = [];\r\n    this.index = -1;\r\n  }\r\n\r\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\r\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\r\n  AbstractHistory.prototype.constructor = AbstractHistory;\r\n\r\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\r\n    var this$1 = this;\r\n\r\n    this.transitionTo(location, function (route) {\r\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\r\n      this$1.index++;\r\n      onComplete && onComplete(route);\r\n    }, onAbort);\r\n  };\r\n\r\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\r\n    var this$1 = this;\r\n\r\n    this.transitionTo(location, function (route) {\r\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\r\n      onComplete && onComplete(route);\r\n    }, onAbort);\r\n  };\r\n\r\n  AbstractHistory.prototype.go = function go (n) {\r\n    var this$1 = this;\r\n\r\n    var targetIndex = this.index + n;\r\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\r\n      return\r\n    }\r\n    var route = this.stack[targetIndex];\r\n    this.confirmTransition(route, function () {\r\n      this$1.index = targetIndex;\r\n      this$1.updateRoute(route);\r\n    });\r\n  };\r\n\r\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\r\n    var current = this.stack[this.stack.length - 1];\r\n    return current ? current.fullPath : '/'\r\n  };\r\n\r\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\r\n    // noop\r\n  };\r\n\r\n  return AbstractHistory;\r\n}(History));\r\n\r\n/*  */\r\n\r\nvar VueRouter = function VueRouter (options) {\r\n  if ( options === void 0 ) options = {};\r\n\r\n  this.app = null;\r\n  this.apps = [];\r\n  this.options = options;\r\n  this.beforeHooks = [];\r\n  this.resolveHooks = [];\r\n  this.afterHooks = [];\r\n  this.matcher = createMatcher(options.routes || [], this);\r\n\r\n  var mode = options.mode || 'hash';\r\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\r\n  if (this.fallback) {\r\n    mode = 'hash';\r\n  }\r\n  if (!inBrowser) {\r\n    mode = 'abstract';\r\n  }\r\n  this.mode = mode;\r\n\r\n  switch (mode) {\r\n    case 'history':\r\n      this.history = new HTML5History(this, options.base);\r\n      break\r\n    case 'hash':\r\n      this.history = new HashHistory(this, options.base, this.fallback);\r\n      break\r\n    case 'abstract':\r\n      this.history = new AbstractHistory(this, options.base);\r\n      break\r\n    default:\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        assert(false, (\"invalid mode: \" + mode));\r\n      }\r\n  }\r\n};\r\n\r\nvar prototypeAccessors = { currentRoute: {} };\r\n\r\nVueRouter.prototype.match = function match (\r\n  raw,\r\n  current,\r\n  redirectedFrom\r\n) {\r\n  return this.matcher.match(raw, current, redirectedFrom)\r\n};\r\n\r\nprototypeAccessors.currentRoute.get = function () {\r\n  return this.history && this.history.current\r\n};\r\n\r\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\r\n    var this$1 = this;\r\n\r\n  process.env.NODE_ENV !== 'production' && assert(\r\n    install.installed,\r\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\r\n    \"before creating root instance.\"\r\n  );\r\n\r\n  this.apps.push(app);\r\n\r\n  // main app already initialized.\r\n  if (this.app) {\r\n    return\r\n  }\r\n\r\n  this.app = app;\r\n\r\n  var history = this.history;\r\n\r\n  if (history instanceof HTML5History) {\r\n    history.transitionTo(history.getCurrentLocation());\r\n  } else if (history instanceof HashHistory) {\r\n    var setupHashListener = function () {\r\n      history.setupListeners();\r\n    };\r\n    history.transitionTo(\r\n      history.getCurrentLocation(),\r\n      setupHashListener,\r\n      setupHashListener\r\n    );\r\n  }\r\n\r\n  history.listen(function (route) {\r\n    this$1.apps.forEach(function (app) {\r\n      app._route = route;\r\n    });\r\n  });\r\n};\r\n\r\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\r\n  return registerHook(this.beforeHooks, fn)\r\n};\r\n\r\nVueRouter.prototype.beforeResolve = function beforeResolve (fn) {\r\n  return registerHook(this.resolveHooks, fn)\r\n};\r\n\r\nVueRouter.prototype.afterEach = function afterEach (fn) {\r\n  return registerHook(this.afterHooks, fn)\r\n};\r\n\r\nVueRouter.prototype.onReady = function onReady (cb, errorCb) {\r\n  this.history.onReady(cb, errorCb);\r\n};\r\n\r\nVueRouter.prototype.onError = function onError (errorCb) {\r\n  this.history.onError(errorCb);\r\n};\r\n\r\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\r\n  this.history.push(location, onComplete, onAbort);\r\n};\r\n\r\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\r\n  this.history.replace(location, onComplete, onAbort);\r\n};\r\n\r\nVueRouter.prototype.go = function go (n) {\r\n  this.history.go(n);\r\n};\r\n\r\nVueRouter.prototype.back = function back () {\r\n  this.go(-1);\r\n};\r\n\r\nVueRouter.prototype.forward = function forward () {\r\n  this.go(1);\r\n};\r\n\r\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\r\n  var route = to\r\n    ? to.matched\r\n      ? to\r\n      : this.resolve(to).route\r\n    : this.currentRoute;\r\n  if (!route) {\r\n    return []\r\n  }\r\n  return [].concat.apply([], route.matched.map(function (m) {\r\n    return Object.keys(m.components).map(function (key) {\r\n      return m.components[key]\r\n    })\r\n  }))\r\n};\r\n\r\nVueRouter.prototype.resolve = function resolve (\r\n  to,\r\n  current,\r\n  append\r\n) {\r\n  var location = normalizeLocation(\r\n    to,\r\n    current || this.history.current,\r\n    append,\r\n    this\r\n  );\r\n  var route = this.match(location, current);\r\n  var fullPath = route.redirectedFrom || route.fullPath;\r\n  var base = this.history.base;\r\n  var href = createHref(base, fullPath, this.mode);\r\n  return {\r\n    location: location,\r\n    route: route,\r\n    href: href,\r\n    // for backwards compat\r\n    normalizedTo: location,\r\n    resolved: route\r\n  }\r\n};\r\n\r\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\r\n  this.matcher.addRoutes(routes);\r\n  if (this.history.current !== START) {\r\n    this.history.transitionTo(this.history.getCurrentLocation());\r\n  }\r\n};\r\n\r\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\r\n\r\nfunction registerHook (list, fn) {\r\n  list.push(fn);\r\n  return function () {\r\n    var i = list.indexOf(fn);\r\n    if (i > -1) { list.splice(i, 1); }\r\n  }\r\n}\r\n\r\nfunction createHref (base, fullPath, mode) {\r\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\r\n  return base ? cleanPath(base + '/' + path) : path\r\n}\r\n\r\nVueRouter.install = install;\r\nVueRouter.version = '2.7.0';\r\n\r\nif (inBrowser && window.Vue) {\r\n  window.Vue.use(VueRouter);\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (VueRouter);\r\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzP2ZlODciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyw2QkFBNkI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEdBQUcsdUJBQXVCLHFCQUFxQixFQUFFO0FBQ2pEO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQSx1Q0FBdUMsaUJBQWlCLEVBQUU7QUFDMUQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLDZDQUE2QztBQUM3QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQSw0QkFBNEIsd0JBQXdCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUIsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQixHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBNkQ7QUFDM0U7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQyxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDs7QUFFQTtBQUNBLG9DQUFvQyxPQUFPLHVCQUF1QixPQUFPO0FBQ3pFOztBQUVBLG1DQUFtQyxPQUFPLHVCQUF1QixPQUFPO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixHQUFHLGVBQWU7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyQkFBMkI7QUFDaEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixpQ0FBaUMsRUFBRTtBQUNwSDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBMEQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGdDQUFnQyxzQkFBc0IsRUFBRTtBQUN4RCw2QkFBNkIsaUJBQWlCLEVBQUU7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMsS0FBSztBQUNMO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVyxFQUFFO0FBQzFEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUyxFQUFFO0FBQzdEO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUyxFQUFFO0FBQzFELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCLEVBQUU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sRUFBRTtBQUN0RCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQ0FBMEMsRUFBRTtBQUNsRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAgKiB2dWUtcm91dGVyIHYyLjcuMFxyXG4gICogKGMpIDIwMTcgRXZhbiBZb3VcclxuICAqIEBsaWNlbnNlIE1JVFxyXG4gICovXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmRpdGlvbikge1xyXG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHtcclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikuaW5kZXhPZignRXJyb3InKSA+IC0xXHJcbn1cclxuXHJcbnZhciBWaWV3ID0ge1xyXG4gIG5hbWU6ICdyb3V0ZXItdmlldycsXHJcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcclxuICBwcm9wczoge1xyXG4gICAgbmFtZToge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKF8sIHJlZikge1xyXG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xyXG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xyXG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XHJcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xyXG5cclxuICAgIGRhdGEucm91dGVyVmlldyA9IHRydWU7XHJcblxyXG4gICAgLy8gZGlyZWN0bHkgdXNlIHBhcmVudCBjb250ZXh0J3MgY3JlYXRlRWxlbWVudCgpIGZ1bmN0aW9uXHJcbiAgICAvLyBzbyB0aGF0IGNvbXBvbmVudHMgcmVuZGVyZWQgYnkgcm91dGVyLXZpZXcgY2FuIHJlc29sdmUgbmFtZWQgc2xvdHNcclxuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xyXG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xyXG4gICAgdmFyIHJvdXRlID0gcGFyZW50LiRyb3V0ZTtcclxuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcclxuXHJcbiAgICAvLyBkZXRlcm1pbmUgY3VycmVudCB2aWV3IGRlcHRoLCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHJlZVxyXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cclxuICAgIHZhciBkZXB0aCA9IDA7XHJcbiAgICB2YXIgaW5hY3RpdmUgPSBmYWxzZTtcclxuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9yb3V0ZXJSb290ICE9PSBwYXJlbnQpIHtcclxuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcclxuICAgICAgICBkZXB0aCsrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XHJcbiAgICAgICAgaW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xyXG4gICAgfVxyXG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcclxuXHJcbiAgICAvLyByZW5kZXIgcHJldmlvdXMgdmlldyBpZiB0aGUgdHJlZSBpcyBpbmFjdGl2ZSBhbmQga2VwdC1hbGl2ZVxyXG4gICAgaWYgKGluYWN0aXZlKSB7XHJcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xyXG4gICAgLy8gcmVuZGVyIGVtcHR5IG5vZGUgaWYgbm8gbWF0Y2hlZCByb3V0ZVxyXG4gICAgaWYgKCFtYXRjaGVkKSB7XHJcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcclxuICAgICAgcmV0dXJuIGgoKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb21wb25lbnQgPSBjYWNoZVtuYW1lXSA9IG1hdGNoZWQuY29tcG9uZW50c1tuYW1lXTtcclxuXHJcbiAgICAvLyBhdHRhY2ggaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tcclxuICAgIC8vIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGluc3RhbmNlJ3MgaW5qZWN0ZWQgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XHJcbiAgICAgIC8vIHZhbCBjb3VsZCBiZSB1bmRlZmluZWQgZm9yIHVucmVnaXN0cmF0aW9uXHJcbiAgICAgIHZhciBjdXJyZW50ID0gbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV07XHJcbiAgICAgIGlmIChcclxuICAgICAgICAodmFsICYmIGN1cnJlbnQgIT09IHZtKSB8fFxyXG4gICAgICAgICghdmFsICYmIGN1cnJlbnQgPT09IHZtKVxyXG4gICAgICApIHtcclxuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsc28gcmVnaXNldGVyIGluc3RhbmNlIGluIHByZXBhdGNoIGhvb2tcclxuICAgIC8vIGluIGNhc2UgdGhlIHNhbWUgY29tcG9uZW50IGluc3RhbmNlIGlzIHJldXNlZCBhY3Jvc3MgZGlmZmVyZW50IHJvdXRlc1xyXG4gICAgOyhkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KSkucHJlcGF0Y2ggPSBmdW5jdGlvbiAoXywgdm5vZGUpIHtcclxuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gcmVzb2x2ZSBwcm9wc1xyXG4gICAgZGF0YS5wcm9wcyA9IHJlc29sdmVQcm9wcyhyb3V0ZSwgbWF0Y2hlZC5wcm9wcyAmJiBtYXRjaGVkLnByb3BzW25hbWVdKTtcclxuXHJcbiAgICByZXR1cm4gaChjb21wb25lbnQsIGRhdGEsIGNoaWxkcmVuKVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xyXG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xyXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcclxuICAgICAgcmV0dXJuXHJcbiAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICByZXR1cm4gY29uZmlnXHJcbiAgICBjYXNlICdmdW5jdGlvbic6XHJcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXHJcbiAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICBcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIFwiICtcclxuICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGVuY29kZVJlc2VydmVSRSA9IC9bIScoKSpdL2c7XHJcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcclxudmFyIGNvbW1hUkUgPSAvJTJDL2c7XHJcblxyXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb25mb3JtYW50IHRvIFJGQzM5ODY6XHJcbi8vIC0gZXNjYXBlcyBbIScoKSpdXHJcbi8vIC0gcHJlc2VydmUgY29tbWFzXHJcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxyXG4gIC5yZXBsYWNlKGVuY29kZVJlc2VydmVSRSwgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKVxyXG4gIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XHJcblxyXG52YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcclxuICBxdWVyeSxcclxuICBleHRyYVF1ZXJ5LFxyXG4gIF9wYXJzZVF1ZXJ5XHJcbikge1xyXG4gIGlmICggZXh0cmFRdWVyeSA9PT0gdm9pZCAwICkgZXh0cmFRdWVyeSA9IHt9O1xyXG5cclxuICB2YXIgcGFyc2UgPSBfcGFyc2VRdWVyeSB8fCBwYXJzZVF1ZXJ5O1xyXG4gIHZhciBwYXJzZWRRdWVyeTtcclxuICB0cnkge1xyXG4gICAgcGFyc2VkUXVlcnkgPSBwYXJzZShxdWVyeSB8fCAnJyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xyXG4gICAgcGFyc2VkUXVlcnkgPSB7fTtcclxuICB9XHJcbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcclxuICAgIHZhciB2YWwgPSBleHRyYVF1ZXJ5W2tleV07XHJcbiAgICBwYXJzZWRRdWVyeVtrZXldID0gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsLnNsaWNlKCkgOiB2YWw7XHJcbiAgfVxyXG4gIHJldHVybiBwYXJzZWRRdWVyeVxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xyXG4gIHZhciByZXMgPSB7fTtcclxuXHJcbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcclxuXHJcbiAgaWYgKCFxdWVyeSkge1xyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH1cclxuXHJcbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcclxuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydHMuc2hpZnQoKSk7XHJcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxyXG4gICAgICA/IGRlY29kZShwYXJ0cy5qb2luKCc9JykpXHJcbiAgICAgIDogbnVsbDtcclxuXHJcbiAgICBpZiAocmVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXNba2V5XSA9IHZhbDtcclxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcclxuICAgICAgcmVzW2tleV0ucHVzaCh2YWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkgKG9iaikge1xyXG4gIHZhciByZXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XHJcblxyXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiAnJ1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGVuY29kZShrZXkpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XHJcbiAgICAgICAgaWYgKHZhbDIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWwyID09PSBudWxsKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwpXHJcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGw7XHJcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcblxyXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlIChcclxuICByZWNvcmQsXHJcbiAgbG9jYXRpb24sXHJcbiAgcmVkaXJlY3RlZEZyb20sXHJcbiAgcm91dGVyXHJcbikge1xyXG4gIHZhciBzdHJpbmdpZnlRdWVyeSQkMSA9IHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcclxuICB2YXIgcm91dGUgPSB7XHJcbiAgICBuYW1lOiBsb2NhdGlvbi5uYW1lIHx8IChyZWNvcmQgJiYgcmVjb3JkLm5hbWUpLFxyXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXHJcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcclxuICAgIGhhc2g6IGxvY2F0aW9uLmhhc2ggfHwgJycsXHJcbiAgICBxdWVyeTogbG9jYXRpb24ucXVlcnkgfHwge30sXHJcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcclxuICAgIGZ1bGxQYXRoOiBnZXRGdWxsUGF0aChsb2NhdGlvbiwgc3RyaW5naWZ5UXVlcnkkJDEpLFxyXG4gICAgbWF0Y2hlZDogcmVjb3JkID8gZm9ybWF0TWF0Y2gocmVjb3JkKSA6IFtdXHJcbiAgfTtcclxuICBpZiAocmVkaXJlY3RlZEZyb20pIHtcclxuICAgIHJvdXRlLnJlZGlyZWN0ZWRGcm9tID0gZ2V0RnVsbFBhdGgocmVkaXJlY3RlZEZyb20sIHN0cmluZ2lmeVF1ZXJ5JCQxKTtcclxuICB9XHJcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm91dGUpXHJcbn1cclxuXHJcbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcclxudmFyIFNUQVJUID0gY3JlYXRlUm91dGUobnVsbCwge1xyXG4gIHBhdGg6ICcvJ1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcclxuICB2YXIgcmVzID0gW107XHJcbiAgd2hpbGUgKHJlY29yZCkge1xyXG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcclxuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKFxyXG4gIHJlZixcclxuICBfc3RyaW5naWZ5UXVlcnlcclxuKSB7XHJcbiAgdmFyIHBhdGggPSByZWYucGF0aDtcclxuICB2YXIgcXVlcnkgPSByZWYucXVlcnk7IGlmICggcXVlcnkgPT09IHZvaWQgMCApIHF1ZXJ5ID0ge307XHJcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XHJcblxyXG4gIHZhciBzdHJpbmdpZnkgPSBfc3RyaW5naWZ5UXVlcnkgfHwgc3RyaW5naWZ5UXVlcnk7XHJcbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnkocXVlcnkpICsgaGFzaFxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYikge1xyXG4gIGlmIChiID09PSBTVEFSVCkge1xyXG4gICAgcmV0dXJuIGEgPT09IGJcclxuICB9IGVsc2UgaWYgKCFiKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9IGVsc2UgaWYgKGEucGF0aCAmJiBiLnBhdGgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxyXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxyXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXHJcbiAgICApXHJcbiAgfSBlbHNlIGlmIChhLm5hbWUgJiYgYi5uYW1lKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxyXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxyXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXHJcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxyXG4gICAgKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzT2JqZWN0RXF1YWwgKGEsIGIpIHtcclxuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcclxuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcclxuXHJcbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XHJcbiAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbiAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciBhVmFsID0gYVtrZXldO1xyXG4gICAgdmFyIGJWYWwgPSBiW2tleV07XHJcbiAgICAvLyBjaGVjayBuZXN0ZWQgZXF1YWxpdHlcclxuICAgIGlmICh0eXBlb2YgYVZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJWYWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdEVxdWFsKGFWYWwsIGJWYWwpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nKGFWYWwpID09PSBTdHJpbmcoYlZhbClcclxuICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xyXG4gIHJldHVybiAoXHJcbiAgICBjdXJyZW50LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJykuaW5kZXhPZihcclxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcclxuICAgICkgPT09IDAgJiZcclxuICAgICghdGFyZ2V0Lmhhc2ggfHwgY3VycmVudC5oYXNoID09PSB0YXJnZXQuaGFzaCkgJiZcclxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxyXG4gIClcclxufVxyXG5cclxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XHJcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xyXG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXHJcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcclxudmFyIGV2ZW50VHlwZXMgPSBbU3RyaW5nLCBBcnJheV07XHJcblxyXG52YXIgTGluayA9IHtcclxuICBuYW1lOiAncm91dGVyLWxpbmsnLFxyXG4gIHByb3BzOiB7XHJcbiAgICB0bzoge1xyXG4gICAgICB0eXBlOiB0b1R5cGVzLFxyXG4gICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIHRhZzoge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIGRlZmF1bHQ6ICdhJ1xyXG4gICAgfSxcclxuICAgIGV4YWN0OiBCb29sZWFuLFxyXG4gICAgYXBwZW5kOiBCb29sZWFuLFxyXG4gICAgcmVwbGFjZTogQm9vbGVhbixcclxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBldmVudDoge1xyXG4gICAgICB0eXBlOiBldmVudFR5cGVzLFxyXG4gICAgICBkZWZhdWx0OiAnY2xpY2snXHJcbiAgICB9XHJcbiAgfSxcclxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlcjtcclxuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XHJcbiAgICB2YXIgcmVmID0gcm91dGVyLnJlc29sdmUodGhpcy50bywgY3VycmVudCwgdGhpcy5hcHBlbmQpO1xyXG4gICAgdmFyIGxvY2F0aW9uID0gcmVmLmxvY2F0aW9uO1xyXG4gICAgdmFyIHJvdXRlID0gcmVmLnJvdXRlO1xyXG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcclxuXHJcbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xyXG4gICAgdmFyIGdsb2JhbEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzO1xyXG4gICAgdmFyIGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcztcclxuICAgIC8vIFN1cHBvcnQgZ2xvYmFsIGVtcHR5IGFjdGl2ZSBjbGFzc1xyXG4gICAgdmFyIGFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxBY3RpdmVDbGFzcyA9PSBudWxsXHJcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWFjdGl2ZSdcclxuICAgICAgICAgICAgOiBnbG9iYWxBY3RpdmVDbGFzcztcclxuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID09IG51bGxcclxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstZXhhY3QtYWN0aXZlJ1xyXG4gICAgICAgICAgICA6IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3M7XHJcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzID09IG51bGxcclxuICAgICAgICAgICAgPyBhY3RpdmVDbGFzc0ZhbGxiYWNrXHJcbiAgICAgICAgICAgIDogdGhpcy5hY3RpdmVDbGFzcztcclxuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzID0gdGhpcy5leGFjdEFjdGl2ZUNsYXNzID09IG51bGxcclxuICAgICAgICAgICAgPyBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2tcclxuICAgICAgICAgICAgOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3M7XHJcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGhcclxuICAgICAgPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKVxyXG4gICAgICA6IHJvdXRlO1xyXG5cclxuICAgIGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc10gPSBpc1NhbWVSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcclxuICAgIGNsYXNzZXNbYWN0aXZlQ2xhc3NdID0gdGhpcy5leGFjdFxyXG4gICAgICA/IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cclxuICAgICAgOiBpc0luY2x1ZGVkUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XHJcblxyXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICBpZiAoZ3VhcmRFdmVudChlKSkge1xyXG4gICAgICAgIGlmICh0aGlzJDEucmVwbGFjZSkge1xyXG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByb3V0ZXIucHVzaChsb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBvbiA9IHsgY2xpY2s6IGd1YXJkRXZlbnQgfTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnQpKSB7XHJcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb25bdGhpcy5ldmVudF0gPSBoYW5kbGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICBjbGFzczogY2xhc3Nlc1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xyXG4gICAgICBkYXRhLm9uID0gb247XHJcbiAgICAgIGRhdGEuYXR0cnMgPSB7IGhyZWY6IGhyZWYgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgbGlzdGVuZXIgYW5kIGhyZWZcclxuICAgICAgdmFyIGEgPSBmaW5kQW5jaG9yKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIC8vIGluIGNhc2UgdGhlIDxhPiBpcyBhIHN0YXRpYyBub2RlXHJcbiAgICAgICAgYS5pc1N0YXRpYyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBleHRlbmQgPSBfVnVlLnV0aWwuZXh0ZW5kO1xyXG4gICAgICAgIHZhciBhRGF0YSA9IGEuZGF0YSA9IGV4dGVuZCh7fSwgYS5kYXRhKTtcclxuICAgICAgICBhRGF0YS5vbiA9IG9uO1xyXG4gICAgICAgIHZhciBhQXR0cnMgPSBhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycyk7XHJcbiAgICAgICAgYUF0dHJzLmhyZWYgPSBocmVmO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSA8YT4gY2hpbGQsIGFwcGx5IGxpc3RlbmVyIHRvIHNlbGZcclxuICAgICAgICBkYXRhLm9uID0gb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XHJcbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2l0aCBjb250cm9sIGtleXNcclxuICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XHJcbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcclxuICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybiB9XHJcbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcclxuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxyXG4gIC8vIGRvbid0IHJlZGlyZWN0IGlmIGB0YXJnZXQ9XCJfYmxhbmtcImBcclxuICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcclxuICAgIHZhciB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcclxuICAgIGlmICgvXFxiX2JsYW5rXFxiL2kudGVzdCh0YXJnZXQpKSB7IHJldHVybiB9XHJcbiAgfVxyXG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcclxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kQW5jaG9yIChjaGlsZHJlbikge1xyXG4gIGlmIChjaGlsZHJlbikge1xyXG4gICAgdmFyIGNoaWxkO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcclxuICAgICAgICByZXR1cm4gY2hpbGRcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBfVnVlO1xyXG5cclxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XHJcbiAgaWYgKGluc3RhbGwuaW5zdGFsbGVkKSB7IHJldHVybiB9XHJcbiAgaW5zdGFsbC5pbnN0YWxsZWQgPSB0cnVlO1xyXG5cclxuICBfVnVlID0gVnVlO1xyXG5cclxuICB2YXIgaXNEZWYgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9O1xyXG5cclxuICB2YXIgcmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgY2FsbFZhbCkge1xyXG4gICAgdmFyIGkgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7XHJcbiAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkuZGF0YSkgJiYgaXNEZWYoaSA9IGkucmVnaXN0ZXJSb3V0ZUluc3RhbmNlKSkge1xyXG4gICAgICBpKHZtLCBjYWxsVmFsKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBWdWUubWl4aW4oe1xyXG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xyXG4gICAgICBpZiAoaXNEZWYodGhpcy4kb3B0aW9ucy5yb3V0ZXIpKSB7XHJcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XHJcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XHJcbiAgICAgICAgVnVlLnV0aWwuZGVmaW5lUmVhY3RpdmUodGhpcywgJ19yb3V0ZScsIHRoaXMuX3JvdXRlci5oaXN0b3J5LmN1cnJlbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSAodGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC5fcm91dGVyUm9vdCkgfHwgdGhpcztcclxuICAgICAgfVxyXG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcclxuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGVyJywge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGVyIH1cclxuICB9KTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZSB9XHJcbiAgfSk7XHJcblxyXG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JywgVmlldyk7XHJcbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLWxpbmsnLCBMaW5rKTtcclxuXHJcbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xyXG4gIC8vIHVzZSB0aGUgc2FtZSBob29rIG1lcmdpbmcgc3RyYXRlZ3kgZm9yIHJvdXRlIGhvb2tzXHJcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVBhdGggKFxyXG4gIHJlbGF0aXZlLFxyXG4gIGJhc2UsXHJcbiAgYXBwZW5kXHJcbikge1xyXG4gIHZhciBmaXJzdENoYXIgPSByZWxhdGl2ZS5jaGFyQXQoMCk7XHJcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJy8nKSB7XHJcbiAgICByZXR1cm4gcmVsYXRpdmVcclxuICB9XHJcblxyXG4gIGlmIChmaXJzdENoYXIgPT09ICc/JyB8fCBmaXJzdENoYXIgPT09ICcjJykge1xyXG4gICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVxyXG4gIH1cclxuXHJcbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xyXG5cclxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcclxuICAvLyAtIG5vdCBhcHBlbmRpbmdcclxuICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxyXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xyXG4gICAgc3RhY2sucG9wKCk7XHJcbiAgfVxyXG5cclxuICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcclxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcclxuICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XHJcbiAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSAnLicpIHtcclxuICAgICAgc3RhY2sucHVzaChzZWdtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXHJcbiAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xyXG4gICAgc3RhY2sudW5zaGlmdCgnJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhY2suam9pbignLycpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xyXG4gIHZhciBoYXNoID0gJyc7XHJcbiAgdmFyIHF1ZXJ5ID0gJyc7XHJcblxyXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcclxuICBpZiAoaGFzaEluZGV4ID49IDApIHtcclxuICAgIGhhc2ggPSBwYXRoLnNsaWNlKGhhc2hJbmRleCk7XHJcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcclxuICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XHJcbiAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpO1xyXG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGF0aDogcGF0aCxcclxuICAgIHF1ZXJ5OiBxdWVyeSxcclxuICAgIGhhc2g6IGhhc2hcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCkge1xyXG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpXHJcbn1cclxuXHJcbnZhciBpbmRleCQxID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxyXG4gKi9cclxudmFyIGluZGV4ID0gcGF0aFRvUmVnZXhwO1xyXG52YXIgcGFyc2VfMSA9IHBhcnNlO1xyXG52YXIgY29tcGlsZV8xID0gY29tcGlsZTtcclxudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XHJcbnZhciB0b2tlbnNUb1JlZ0V4cF8xID0gdG9rZW5zVG9SZWdFeHA7XHJcblxyXG4vKipcclxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cclxuICpcclxuICogQHR5cGUge1JlZ0V4cH1cclxuICovXHJcbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xyXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXHJcbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cclxuICAnKFxcXFxcXFxcLiknLFxyXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XHJcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcclxuICAvL1xyXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cclxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXHJcbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxyXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcclxuXS5qb2luKCd8JyksICdnJyk7XHJcblxyXG4vKipcclxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcclxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHshQXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XHJcbiAgdmFyIHRva2VucyA9IFtdO1xyXG4gIHZhciBrZXkgPSAwO1xyXG4gIHZhciBpbmRleCA9IDA7XHJcbiAgdmFyIHBhdGggPSAnJztcclxuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xyXG4gIHZhciByZXM7XHJcblxyXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XHJcbiAgICB2YXIgbSA9IHJlc1swXTtcclxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdO1xyXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcclxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpO1xyXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aDtcclxuXHJcbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cclxuICAgIGlmIChlc2NhcGVkKSB7XHJcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcclxuICAgICAgY29udGludWVcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF07XHJcbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdO1xyXG4gICAgdmFyIG5hbWUgPSByZXNbM107XHJcbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XTtcclxuICAgIHZhciBncm91cCA9IHJlc1s1XTtcclxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcclxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XTtcclxuXHJcbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxyXG4gICAgaWYgKHBhdGgpIHtcclxuICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XHJcbiAgICAgIHBhdGggPSAnJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XHJcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonO1xyXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonO1xyXG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xyXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwO1xyXG5cclxuICAgIHRva2Vucy5wdXNoKHtcclxuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcclxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXHJcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxyXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXHJcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxyXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxyXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcclxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXHJcbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xyXG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KTtcclxuICB9XHJcblxyXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXHJcbiAgaWYgKHBhdGgpIHtcclxuICAgIHRva2Vucy5wdXNoKHBhdGgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRva2Vuc1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcclxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXHJcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xyXG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xyXG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ31cclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xyXG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XHJcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXHJcbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aCk7XHJcblxyXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcclxuICAgIHZhciBwYXRoID0gJyc7XHJcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fTtcclxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcclxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XHJcblxyXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHBhdGggKz0gdG9rZW47XHJcblxyXG4gICAgICAgIGNvbnRpbnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XHJcbiAgICAgIHZhciBzZWdtZW50O1xyXG5cclxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcclxuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxyXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcclxuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpbmRleCQxKHZhbHVlKSkge1xyXG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XHJcblxyXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcclxuXHJcbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGF0aFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcclxufVxyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcclxuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcclxufVxyXG5cclxuLyoqXHJcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXHJcbiAqXHJcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcclxuICogQHJldHVybiB7IVJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XHJcbiAgcmUua2V5cyA9IGtleXM7XHJcbiAgcmV0dXJuIHJlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcclxuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xyXG59XHJcblxyXG4vKipcclxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXHJcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcclxuICogQHJldHVybiB7IVJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XHJcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cclxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XHJcblxyXG4gIGlmIChncm91cHMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGtleXMucHVzaCh7XHJcbiAgICAgICAgbmFtZTogaSxcclxuICAgICAgICBwcmVmaXg6IG51bGwsXHJcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxyXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcclxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxyXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxyXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcclxuICAgICAgICBwYXR0ZXJuOiBudWxsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcclxuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xyXG4gIHZhciBwYXJ0cyA9IFtdO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xyXG5cclxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxyXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXHJcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcclxuICogQHJldHVybiB7IVJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxyXG59XHJcblxyXG4vKipcclxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cclxuICpcclxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcclxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxyXG4gKi9cclxuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xyXG4gIGlmICghaW5kZXgkMShrZXlzKSkge1xyXG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XHJcbiAgICBrZXlzID0gW107XHJcbiAgfVxyXG5cclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xyXG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XHJcbiAgdmFyIHJvdXRlID0gJyc7XHJcblxyXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpO1xyXG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJztcclxuXHJcbiAgICAgIGtleXMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XHJcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcclxuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcclxuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcclxuICAgICAgfVxyXG5cclxuICAgICAgcm91dGUgKz0gY2FwdHVyZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcclxuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlcjtcclxuXHJcbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cclxuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcclxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XHJcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxyXG4gIGlmICghc3RyaWN0KSB7XHJcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVuZCkge1xyXG4gICAgcm91dGUgKz0gJyQnO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xyXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cclxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJztcclxuICB9XHJcblxyXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcclxufVxyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICpcclxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcclxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxyXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cclxuICpcclxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXHJcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcclxuICogQHJldHVybiB7IVJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xyXG4gIGlmICghaW5kZXgkMShrZXlzKSkge1xyXG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XHJcbiAgICBrZXlzID0gW107XHJcbiAgfVxyXG5cclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxyXG4gIH1cclxuXHJcbiAgaWYgKGluZGV4JDEocGF0aCkpIHtcclxuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcclxufVxyXG5cclxuaW5kZXgucGFyc2UgPSBwYXJzZV8xO1xyXG5pbmRleC5jb21waWxlID0gY29tcGlsZV8xO1xyXG5pbmRleC50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbl8xO1xyXG5pbmRleC50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXzE7XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuZnVuY3Rpb24gZmlsbFBhcmFtcyAoXHJcbiAgcGF0aCxcclxuICBwYXJhbXMsXHJcbiAgcm91dGVNc2dcclxuKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBmaWxsZXIgPVxyXG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcclxuICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IGluZGV4LmNvbXBpbGUocGF0aCkpO1xyXG4gICAgcmV0dXJuIGZpbGxlcihwYXJhbXMgfHwge30sIHsgcHJldHR5OiB0cnVlIH0pXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgd2FybihmYWxzZSwgKFwibWlzc2luZyBwYXJhbSBmb3IgXCIgKyByb3V0ZU1zZyArIFwiOiBcIiArIChlLm1lc3NhZ2UpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJydcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxyXG4gIHJvdXRlcyxcclxuICBvbGRQYXRoTGlzdCxcclxuICBvbGRQYXRoTWFwLFxyXG4gIG9sZE5hbWVNYXBcclxuKSB7XHJcbiAgLy8gdGhlIHBhdGggbGlzdCBpcyB1c2VkIHRvIGNvbnRyb2wgcGF0aCBtYXRjaGluZyBwcmlvcml0eVxyXG4gIHZhciBwYXRoTGlzdCA9IG9sZFBhdGhMaXN0IHx8IFtdO1xyXG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcclxuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIGVuc3VyZSB3aWxkY2FyZCByb3V0ZXMgYXJlIGFsd2F5cyBhdCB0aGUgZW5kXHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIGlmIChwYXRoTGlzdFtpXSA9PT0gJyonKSB7XHJcbiAgICAgIHBhdGhMaXN0LnB1c2gocGF0aExpc3Quc3BsaWNlKGksIDEpWzBdKTtcclxuICAgICAgbC0tO1xyXG4gICAgICBpLS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGF0aExpc3Q6IHBhdGhMaXN0LFxyXG4gICAgcGF0aE1hcDogcGF0aE1hcCxcclxuICAgIG5hbWVNYXA6IG5hbWVNYXBcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFJvdXRlUmVjb3JkIChcclxuICBwYXRoTGlzdCxcclxuICBwYXRoTWFwLFxyXG4gIG5hbWVNYXAsXHJcbiAgcm91dGUsXHJcbiAgcGFyZW50LFxyXG4gIG1hdGNoQXNcclxuKSB7XHJcbiAgdmFyIHBhdGggPSByb3V0ZS5wYXRoO1xyXG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKTtcclxuICAgIGFzc2VydChcclxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXHJcbiAgICAgIFwicm91dGUgY29uZmlnIFxcXCJjb21wb25lbnRcXFwiIGZvciBwYXRoOiBcIiArIChTdHJpbmcocGF0aCB8fCBuYW1lKSkgKyBcIiBjYW5ub3QgYmUgYSBcIiArXHJcbiAgICAgIFwic3RyaW5nIGlkLiBVc2UgYW4gYWN0dWFsIGNvbXBvbmVudCBpbnN0ZWFkLlwiXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgdmFyIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoLCBwYXJlbnQpO1xyXG4gIHZhciBwYXRoVG9SZWdleHBPcHRpb25zID0gcm91dGUucGF0aFRvUmVnZXhwT3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgaWYgKHR5cGVvZiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSAnYm9vbGVhbicpIHtcclxuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc2Vuc2l0aXZlID0gcm91dGUuY2FzZVNlbnNpdGl2ZTtcclxuICB9XHJcblxyXG4gIHZhciByZWNvcmQgPSB7XHJcbiAgICBwYXRoOiBub3JtYWxpemVkUGF0aCxcclxuICAgIHJlZ2V4OiBjb21waWxlUm91dGVSZWdleChub3JtYWxpemVkUGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucyksXHJcbiAgICBjb21wb25lbnRzOiByb3V0ZS5jb21wb25lbnRzIHx8IHsgZGVmYXVsdDogcm91dGUuY29tcG9uZW50IH0sXHJcbiAgICBpbnN0YW5jZXM6IHt9LFxyXG4gICAgbmFtZTogbmFtZSxcclxuICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgbWF0Y2hBczogbWF0Y2hBcyxcclxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcclxuICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcclxuICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge30sXHJcbiAgICBwcm9wczogcm91dGUucHJvcHMgPT0gbnVsbFxyXG4gICAgICA/IHt9XHJcbiAgICAgIDogcm91dGUuY29tcG9uZW50c1xyXG4gICAgICAgID8gcm91dGUucHJvcHNcclxuICAgICAgICA6IHsgZGVmYXVsdDogcm91dGUucHJvcHMgfVxyXG4gIH07XHJcblxyXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xyXG4gICAgLy8gV2FybiBpZiByb3V0ZSBpcyBuYW1lZCwgZG9lcyBub3QgcmVkaXJlY3QgYW5kIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuXHJcbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcclxuICAgIC8vIG5vdCBiZSByZW5kZXJlZCAoR0ggSXNzdWUgIzYyOSlcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChyb3V0ZS5uYW1lICYmICFyb3V0ZS5yZWRpcmVjdCAmJiByb3V0ZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gL15cXC8/JC8udGVzdChjaGlsZC5wYXRoKTsgfSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICBcIk5hbWVkIFJvdXRlICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJyBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLiBcIiArXHJcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xyXG4gICAgICAgICAgXCJ0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSB3aWxsIG5vdCBiZSByZW5kZXJlZC4gUmVtb3ZlIHRoZSBuYW1lIGZyb20gXCIgK1xyXG4gICAgICAgICAgXCJ0aGlzIHJvdXRlIGFuZCB1c2UgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgZm9yIG5hbWVkIFwiICtcclxuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgIHZhciBjaGlsZE1hdGNoQXMgPSBtYXRjaEFzXHJcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCBjaGlsZCwgcmVjb3JkLCBjaGlsZE1hdGNoQXMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmFyIGFsaWFzZXMgPSBBcnJheS5pc0FycmF5KHJvdXRlLmFsaWFzKVxyXG4gICAgICA/IHJvdXRlLmFsaWFzXHJcbiAgICAgIDogW3JvdXRlLmFsaWFzXTtcclxuXHJcbiAgICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XHJcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xyXG4gICAgICAgIHBhdGg6IGFsaWFzLFxyXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlblxyXG4gICAgICB9O1xyXG4gICAgICBhZGRSb3V0ZVJlY29yZChcclxuICAgICAgICBwYXRoTGlzdCxcclxuICAgICAgICBwYXRoTWFwLFxyXG4gICAgICAgIG5hbWVNYXAsXHJcbiAgICAgICAgYWxpYXNSb3V0ZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgcmVjb3JkLnBhdGggfHwgJy8nIC8vIG1hdGNoQXNcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFwYXRoTWFwW3JlY29yZC5wYXRoXSkge1xyXG4gICAgcGF0aExpc3QucHVzaChyZWNvcmQucGF0aCk7XHJcbiAgICBwYXRoTWFwW3JlY29yZC5wYXRoXSA9IHJlY29yZDtcclxuICB9XHJcblxyXG4gIGlmIChuYW1lKSB7XHJcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcclxuICAgICAgbmFtZU1hcFtuYW1lXSA9IHJlY29yZDtcclxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbWF0Y2hBcykge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIFwiRHVwbGljYXRlIG5hbWVkIHJvdXRlcyBkZWZpbml0aW9uOiBcIiArXHJcbiAgICAgICAgXCJ7IG5hbWU6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHBhdGg6IFxcXCJcIiArIChyZWNvcmQucGF0aCkgKyBcIlxcXCIgfVwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb21waWxlUm91dGVSZWdleCAocGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucykge1xyXG4gIHZhciByZWdleCA9IGluZGV4KHBhdGgsIFtdLCBwYXRoVG9SZWdleHBPcHRpb25zKTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdmFyIGtleXMgPSB7fTtcclxuICAgIHJlZ2V4LmtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHdhcm4oIWtleXNba2V5Lm5hbWVdLCAoXCJEdXBsaWNhdGUgcGFyYW0ga2V5cyBpbiByb3V0ZSB3aXRoIHBhdGg6IFxcXCJcIiArIHBhdGggKyBcIlxcXCJcIikpO1xyXG4gICAgICBrZXlzW2tleS5uYW1lXSA9IHRydWU7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlZ2V4XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCkge1xyXG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7XHJcbiAgaWYgKHBhdGhbMF0gPT09ICcvJykgeyByZXR1cm4gcGF0aCB9XHJcbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cclxuICByZXR1cm4gY2xlYW5QYXRoKCgocGFyZW50LnBhdGgpICsgXCIvXCIgKyBwYXRoKSlcclxufVxyXG5cclxuLyogICovXHJcblxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24gKFxyXG4gIHJhdyxcclxuICBjdXJyZW50LFxyXG4gIGFwcGVuZCxcclxuICByb3V0ZXJcclxuKSB7XHJcbiAgdmFyIG5leHQgPSB0eXBlb2YgcmF3ID09PSAnc3RyaW5nJyA/IHsgcGF0aDogcmF3IH0gOiByYXc7XHJcbiAgLy8gbmFtZWQgdGFyZ2V0XHJcbiAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XHJcbiAgICByZXR1cm4gbmV4dFxyXG4gIH1cclxuXHJcbiAgLy8gcmVsYXRpdmUgcGFyYW1zXHJcbiAgaWYgKCFuZXh0LnBhdGggJiYgbmV4dC5wYXJhbXMgJiYgY3VycmVudCkge1xyXG4gICAgbmV4dCA9IGFzc2lnbih7fSwgbmV4dCk7XHJcbiAgICBuZXh0Ll9ub3JtYWxpemVkID0gdHJ1ZTtcclxuICAgIHZhciBwYXJhbXMgPSBhc3NpZ24oYXNzaWduKHt9LCBjdXJyZW50LnBhcmFtcyksIG5leHQucGFyYW1zKTtcclxuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcclxuICAgICAgbmV4dC5uYW1lID0gY3VycmVudC5uYW1lO1xyXG4gICAgICBuZXh0LnBhcmFtcyA9IHBhcmFtcztcclxuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkLmxlbmd0aCkge1xyXG4gICAgICB2YXIgcmF3UGF0aCA9IGN1cnJlbnQubWF0Y2hlZFtjdXJyZW50Lm1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aDtcclxuICAgICAgbmV4dC5wYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInBhdGggXCIgKyAoY3VycmVudC5wYXRoKSkpO1xyXG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHdhcm4oZmFsc2UsIFwicmVsYXRpdmUgcGFyYW1zIG5hdmlnYXRpb24gcmVxdWlyZXMgYSBjdXJyZW50IHJvdXRlLlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXh0XHJcbiAgfVxyXG5cclxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xyXG4gIHZhciBiYXNlUGF0aCA9IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xyXG4gIHZhciBwYXRoID0gcGFyc2VkUGF0aC5wYXRoXHJcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcclxuICAgIDogYmFzZVBhdGg7XHJcblxyXG4gIHZhciBxdWVyeSA9IHJlc29sdmVRdWVyeShcclxuICAgIHBhcnNlZFBhdGgucXVlcnksXHJcbiAgICBuZXh0LnF1ZXJ5LFxyXG4gICAgcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnBhcnNlUXVlcnlcclxuICApO1xyXG5cclxuICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2g7XHJcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xyXG4gICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBfbm9ybWFsaXplZDogdHJ1ZSxcclxuICAgIHBhdGg6IHBhdGgsXHJcbiAgICBxdWVyeTogcXVlcnksXHJcbiAgICBoYXNoOiBoYXNoXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcclxuICBmb3IgKHZhciBrZXkgaW4gYikge1xyXG4gICAgYVtrZXldID0gYltrZXldO1xyXG4gIH1cclxuICByZXR1cm4gYVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVNYXRjaGVyIChcclxuICByb3V0ZXMsXHJcbiAgcm91dGVyXHJcbikge1xyXG4gIHZhciByZWYgPSBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMpO1xyXG4gIHZhciBwYXRoTGlzdCA9IHJlZi5wYXRoTGlzdDtcclxuICB2YXIgcGF0aE1hcCA9IHJlZi5wYXRoTWFwO1xyXG4gIHZhciBuYW1lTWFwID0gcmVmLm5hbWVNYXA7XHJcblxyXG4gIGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XHJcbiAgICBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMsIHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1hdGNoIChcclxuICAgIHJhdyxcclxuICAgIGN1cnJlbnRSb3V0ZSxcclxuICAgIHJlZGlyZWN0ZWRGcm9tXHJcbiAgKSB7XHJcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSwgZmFsc2UsIHJvdXRlcik7XHJcbiAgICB2YXIgbmFtZSA9IGxvY2F0aW9uLm5hbWU7XHJcblxyXG4gICAgaWYgKG5hbWUpIHtcclxuICAgICAgdmFyIHJlY29yZCA9IG5hbWVNYXBbbmFtZV07XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXJlY29yZCkgeyByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKSB9XHJcbiAgICAgIHZhciBwYXJhbU5hbWVzID0gcmVjb3JkLnJlZ2V4LmtleXNcclxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkubmFtZTsgfSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGN1cnJlbnRSb3V0ZSAmJiB0eXBlb2YgY3VycmVudFJvdXRlLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJvdXRlLnBhcmFtcykge1xyXG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xyXG4gICAgICAgICAgICBsb2NhdGlvbi5wYXJhbXNba2V5XSA9IGN1cnJlbnRSb3V0ZS5wYXJhbXNba2V5XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWNvcmQpIHtcclxuICAgICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcclxuICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGgpIHtcclxuICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhMaXN0W2ldO1xyXG4gICAgICAgIHZhciByZWNvcmQkMSA9IHBhdGhNYXBbcGF0aF07XHJcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocmVjb3JkJDEucmVnZXgsIGxvY2F0aW9uLnBhdGgsIGxvY2F0aW9uLnBhcmFtcykpIHtcclxuICAgICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkJDEsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG5vIG1hdGNoXHJcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxyXG4gICAgcmVjb3JkLFxyXG4gICAgbG9jYXRpb25cclxuICApIHtcclxuICAgIHZhciBvcmlnaW5hbFJlZGlyZWN0ID0gcmVjb3JkLnJlZGlyZWN0O1xyXG4gICAgdmFyIHJlZGlyZWN0ID0gdHlwZW9mIG9yaWdpbmFsUmVkaXJlY3QgPT09ICdmdW5jdGlvbidcclxuICAgICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKSlcclxuICAgICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XHJcblxyXG4gICAgaWYgKHR5cGVvZiByZWRpcmVjdCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XHJcbiAgICB2YXIgbmFtZSA9IHJlLm5hbWU7XHJcbiAgICB2YXIgcGF0aCA9IHJlLnBhdGg7XHJcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcclxuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcclxuICAgIHZhciBwYXJhbXMgPSBsb2NhdGlvbi5wYXJhbXM7XHJcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcclxuICAgIGhhc2ggPSByZS5oYXNPd25Qcm9wZXJ0eSgnaGFzaCcpID8gcmUuaGFzaCA6IGhhc2g7XHJcbiAgICBwYXJhbXMgPSByZS5oYXNPd25Qcm9wZXJ0eSgncGFyYW1zJykgPyByZS5wYXJhbXMgOiBwYXJhbXM7XHJcblxyXG4gICAgaWYgKG5hbWUpIHtcclxuICAgICAgLy8gcmVzb2x2ZWQgbmFtZWQgZGlyZWN0XHJcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGFzc2VydCh0YXJnZXRSZWNvcmQsIChcInJlZGlyZWN0IGZhaWxlZDogbmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWF0Y2goe1xyXG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxyXG4gICAgICAgIGhhc2g6IGhhc2gsXHJcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcclxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcclxuICAgIH0gZWxzZSBpZiAocGF0aCkge1xyXG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XHJcbiAgICAgIHZhciByYXdQYXRoID0gcmVzb2x2ZVJlY29yZFBhdGgocGF0aCwgcmVjb3JkKTtcclxuICAgICAgLy8gMi4gcmVzb2x2ZSBwYXJhbXNcclxuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XHJcbiAgICAgIC8vIDMuIHJlbWF0Y2ggd2l0aCBleGlzdGluZyBxdWVyeSBhbmQgaGFzaFxyXG4gICAgICByZXR1cm4gbWF0Y2goe1xyXG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxyXG4gICAgICAgIHBhdGg6IHJlc29sdmVkUGF0aCxcclxuICAgICAgICBxdWVyeTogcXVlcnksXHJcbiAgICAgICAgaGFzaDogaGFzaFxyXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuKGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhbGlhcyAoXHJcbiAgICByZWNvcmQsXHJcbiAgICBsb2NhdGlvbixcclxuICAgIG1hdGNoQXNcclxuICApIHtcclxuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcclxuICAgIHZhciBhbGlhc2VkTWF0Y2ggPSBtYXRjaCh7XHJcbiAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxyXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxyXG4gICAgfSk7XHJcbiAgICBpZiAoYWxpYXNlZE1hdGNoKSB7XHJcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XHJcbiAgICAgIHZhciBhbGlhc2VkUmVjb3JkID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdO1xyXG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSBhbGlhc2VkTWF0Y2gucGFyYW1zO1xyXG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9jcmVhdGVSb3V0ZSAoXHJcbiAgICByZWNvcmQsXHJcbiAgICBsb2NhdGlvbixcclxuICAgIHJlZGlyZWN0ZWRGcm9tXHJcbiAgKSB7XHJcbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5yZWRpcmVjdCkge1xyXG4gICAgICByZXR1cm4gcmVkaXJlY3QocmVjb3JkLCByZWRpcmVjdGVkRnJvbSB8fCBsb2NhdGlvbilcclxuICAgIH1cclxuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLm1hdGNoQXMpIHtcclxuICAgICAgcmV0dXJuIGFsaWFzKHJlY29yZCwgbG9jYXRpb24sIHJlY29yZC5tYXRjaEFzKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tLCByb3V0ZXIpXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbWF0Y2g6IG1hdGNoLFxyXG4gICAgYWRkUm91dGVzOiBhZGRSb3V0ZXNcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hdGNoUm91dGUgKFxyXG4gIHJlZ2V4LFxyXG4gIHBhdGgsXHJcbiAgcGFyYW1zXHJcbikge1xyXG4gIHZhciBtID0gcGF0aC5tYXRjaChyZWdleCk7XHJcblxyXG4gIGlmICghbSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgIHZhciBrZXkgPSByZWdleC5rZXlzW2kgLSAxXTtcclxuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdmFsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xyXG4gIHJldHVybiByZXNvbHZlUGF0aChwYXRoLCByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5wYXRoIDogJy8nLCB0cnVlKVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcblxyXG52YXIgcG9zaXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xyXG4gICAgaWYgKGUuc3RhdGUgJiYgZS5zdGF0ZS5rZXkpIHtcclxuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwgKFxyXG4gIHJvdXRlcixcclxuICB0byxcclxuICBmcm9tLFxyXG4gIGlzUG9wXHJcbikge1xyXG4gIGlmICghcm91dGVyLmFwcCkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcclxuICBpZiAoIWJlaGF2aW9yKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBhc3NlcnQodHlwZW9mIGJlaGF2aW9yID09PSAnZnVuY3Rpb24nLCBcInNjcm9sbEJlaGF2aW9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuICB9XHJcblxyXG4gIC8vIHdhaXQgdW50aWwgcmUtcmVuZGVyIGZpbmlzaGVzIGJlZm9yZSBzY3JvbGxpbmdcclxuICByb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xyXG4gICAgdmFyIHNob3VsZFNjcm9sbCA9IGJlaGF2aW9yKHRvLCBmcm9tLCBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbCk7XHJcbiAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnO1xyXG4gICAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHZhciBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2hvdWxkU2Nyb2xsLnNlbGVjdG9yKTtcclxuICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHNob3VsZFNjcm9sbC5vZmZzZXQgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5vZmZzZXQgPT09ICdvYmplY3QnID8gc2hvdWxkU2Nyb2xsLm9mZnNldCA6IHt9O1xyXG4gICAgICAgIG9mZnNldCA9IG5vcm1hbGl6ZU9mZnNldChvZmZzZXQpO1xyXG4gICAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsLCBvZmZzZXQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XHJcbiAgICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0ICYmIGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XHJcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zaXRpb24pIHtcclxuICAgICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xyXG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xyXG4gIGlmIChrZXkpIHtcclxuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcclxuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxyXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XHJcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XHJcbiAgaWYgKGtleSkge1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uIChlbCwgb2Zmc2V0KSB7XHJcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gIHZhciBkb2NSZWN0ID0gZG9jRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBlbFJlY3QubGVmdCAtIGRvY1JlY3QubGVmdCAtIG9mZnNldC54LFxyXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wIC0gb2Zmc2V0LnlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcclxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVPZmZzZXQgKG9iaikge1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IDAsXHJcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IDBcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IGluQnJvd3NlciAmJiAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xyXG5cclxuICBpZiAoXHJcbiAgICAodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiZcclxuICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcclxuICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxyXG4gICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMVxyXG4gICkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3RvcnlcclxufSkoKTtcclxuXHJcbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cclxudmFyIFRpbWUgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3dcclxuICA/IHdpbmRvdy5wZXJmb3JtYW5jZVxyXG4gIDogRGF0ZTtcclxuXHJcbnZhciBfa2V5ID0gZ2VuS2V5KCk7XHJcblxyXG5mdW5jdGlvbiBnZW5LZXkgKCkge1xyXG4gIHJldHVybiBUaW1lLm5vdygpLnRvRml4ZWQoMylcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U3RhdGVLZXkgKCkge1xyXG4gIHJldHVybiBfa2V5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcclxuICBfa2V5ID0ga2V5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwdXNoU3RhdGUgKHVybCwgcmVwbGFjZSkge1xyXG4gIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xyXG4gIC8vIHRyeS4uLmNhdGNoIHRoZSBwdXNoU3RhdGUgY2FsbCB0byBnZXQgYXJvdW5kIFNhZmFyaVxyXG4gIC8vIERPTSBFeGNlcHRpb24gMTggd2hlcmUgaXQgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcclxuICB2YXIgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xyXG4gIHRyeSB7XHJcbiAgICBpZiAocmVwbGFjZSkge1xyXG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9rZXkgPSBnZW5LZXkoKTtcclxuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgd2luZG93LmxvY2F0aW9uW3JlcGxhY2UgPyAncmVwbGFjZScgOiAnYXNzaWduJ10odXJsKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XHJcbiAgcHVzaFN0YXRlKHVybCwgdHJ1ZSk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcclxuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICBjYigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHF1ZXVlW2luZGV4XSkge1xyXG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc3RlcChpbmRleCArIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgc3RlcCgwKTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnRzIChtYXRjaGVkKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xyXG4gICAgdmFyIGhhc0FzeW5jID0gZmFsc2U7XHJcbiAgICB2YXIgcGVuZGluZyA9IDA7XHJcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xyXG5cclxuICAgIGZsYXRNYXBDb21wb25lbnRzKG1hdGNoZWQsIGZ1bmN0aW9uIChkZWYsIF8sIG1hdGNoLCBrZXkpIHtcclxuICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgY2lkIGF0dGFjaGVkLFxyXG4gICAgICAvLyBhc3N1bWUgaXQncyBhbiBhc3luYyBjb21wb25lbnQgcmVzb2x2ZSBmdW5jdGlvbi5cclxuICAgICAgLy8gd2UgYXJlIG5vdCB1c2luZyBWdWUncyBkZWZhdWx0IGFzeW5jIHJlc29sdmluZyBtZWNoYW5pc20gYmVjYXVzZVxyXG4gICAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxyXG4gICAgICAvLyByZXNvbHZlZC5cclxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZGVmLmNpZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaGFzQXN5bmMgPSB0cnVlO1xyXG4gICAgICAgIHBlbmRpbmcrKztcclxuXHJcbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xyXG4gICAgICAgICAgaWYgKHJlc29sdmVkRGVmLl9fZXNNb2R1bGUgJiYgcmVzb2x2ZWREZWYuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICByZXNvbHZlZERlZiA9IHJlc29sdmVkRGVmLmRlZmF1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBzYXZlIHJlc29sdmVkIG9uIGFzeW5jIGZhY3RvcnkgaW4gY2FzZSBpdCdzIHVzZWQgZWxzZXdoZXJlXHJcbiAgICAgICAgICBkZWYucmVzb2x2ZWQgPSB0eXBlb2YgcmVzb2x2ZWREZWYgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgPyByZXNvbHZlZERlZlxyXG4gICAgICAgICAgICA6IF9WdWUuZXh0ZW5kKHJlc29sdmVkRGVmKTtcclxuICAgICAgICAgIG1hdGNoLmNvbXBvbmVudHNba2V5XSA9IHJlc29sdmVkRGVmO1xyXG4gICAgICAgICAgcGVuZGluZy0tO1xyXG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xyXG4gICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICAgIHZhciBtc2cgPSBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbjtcclxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgbXNnKTtcclxuICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgZXJyb3IgPSBpc0Vycm9yKHJlYXNvbilcclxuICAgICAgICAgICAgICA/IHJlYXNvblxyXG4gICAgICAgICAgICAgIDogbmV3IEVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgIG5leHQoZXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXMgPSBkZWYocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5ldyBzeW50YXggaW4gVnVlIDIuM1xyXG4gICAgICAgICAgICB2YXIgY29tcCA9IHJlcy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIGlmIChjb21wICYmIHR5cGVvZiBjb21wLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICBjb21wLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFoYXNBc3luYykgeyBuZXh0KCk7IH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcclxuICBtYXRjaGVkLFxyXG4gIGZuXHJcbikge1xyXG4gIHJldHVybiBmbGF0dGVuKG1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oXHJcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxyXG4gICAgICBtLmluc3RhbmNlc1trZXldLFxyXG4gICAgICBtLCBrZXlcclxuICAgICk7IH0pXHJcbiAgfSkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZsYXR0ZW4gKGFycikge1xyXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpXHJcbn1cclxuXHJcbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2VcclxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXHJcbi8vIGlmIHRoZSB1c2VyIHVzZXMgYW4gYXJyb3cgZnVuY3Rpb24gc2hvcnRoYW5kIHRoYXQgaGFwcGVucyB0b1xyXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxyXG5mdW5jdGlvbiBvbmNlIChmbikge1xyXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XHJcblxyXG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxyXG4gICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xyXG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xyXG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XHJcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcclxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcclxuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xyXG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcclxuICB0aGlzLnJlYWR5Q2JzID0gW107XHJcbiAgdGhpcy5yZWFkeUVycm9yQ2JzID0gW107XHJcbiAgdGhpcy5lcnJvckNicyA9IFtdO1xyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xyXG4gIHRoaXMuY2IgPSBjYjtcclxufTtcclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xyXG4gIGlmICh0aGlzLnJlYWR5KSB7XHJcbiAgICBjYigpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xyXG4gICAgaWYgKGVycm9yQ2IpIHtcclxuICAgICAgdGhpcy5yZWFkeUVycm9yQ2JzLnB1c2goZXJyb3JDYik7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcclxuICB0aGlzLmVycm9yQ2JzLnB1c2goZXJyb3JDYik7XHJcbn07XHJcblxyXG5IaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8gKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgdmFyIHJvdXRlID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24sIHRoaXMuY3VycmVudCk7XHJcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcclxuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XHJcbiAgICB0aGlzJDEuZW5zdXJlVVJMKCk7XHJcblxyXG4gICAgLy8gZmlyZSByZWFkeSBjYnMgb25jZVxyXG4gICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcclxuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcyQxLnJlYWR5Q2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKHJvdXRlKTsgfSk7XHJcbiAgICB9XHJcbiAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgaWYgKG9uQWJvcnQpIHtcclxuICAgICAgb25BYm9ydChlcnIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVyciAmJiAhdGhpcyQxLnJlYWR5KSB7XHJcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XHJcbiAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcclxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XHJcbiAgICAgIGlmICh0aGlzJDEuZXJyb3JDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcyQxLmVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdhcm4oZmFsc2UsICd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQWJvcnQgJiYgb25BYm9ydChlcnIpO1xyXG4gIH07XHJcbiAgaWYgKFxyXG4gICAgaXNTYW1lUm91dGUocm91dGUsIGN1cnJlbnQpICYmXHJcbiAgICAvLyBpbiB0aGUgY2FzZSB0aGUgcm91dGUgbWFwIGhhcyBiZWVuIGR5bmFtaWNhbGx5IGFwcGVuZGVkIHRvXHJcbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxyXG4gICkge1xyXG4gICAgdGhpcy5lbnN1cmVVUkwoKTtcclxuICAgIHJldHVybiBhYm9ydCgpXHJcbiAgfVxyXG5cclxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcclxuICAgIHZhciB1cGRhdGVkID0gcmVmLnVwZGF0ZWQ7XHJcbiAgICB2YXIgZGVhY3RpdmF0ZWQgPSByZWYuZGVhY3RpdmF0ZWQ7XHJcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcclxuXHJcbiAgdmFyIHF1ZXVlID0gW10uY29uY2F0KFxyXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xyXG4gICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcclxuICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3NcclxuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxyXG4gICAgLy8gaW4tY29tcG9uZW50IHVwZGF0ZSBob29rc1xyXG4gICAgZXh0cmFjdFVwZGF0ZUhvb2tzKHVwZGF0ZWQpLFxyXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xyXG4gICAgYWN0aXZhdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5iZWZvcmVFbnRlcjsgfSksXHJcbiAgICAvLyBhc3luYyBjb21wb25lbnRzXHJcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcclxuICApO1xyXG5cclxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcclxuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xyXG4gICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xyXG4gICAgICByZXR1cm4gYWJvcnQoKVxyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XHJcbiAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc0Vycm9yKHRvKSkge1xyXG4gICAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXHJcbiAgICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xyXG4gICAgICAgICAgYWJvcnQodG8pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICB0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiAoXHJcbiAgICAgICAgICAgIHR5cGVvZiB0by5wYXRoID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICAgICB0eXBlb2YgdG8ubmFtZSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxyXG4gICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIHRvLnJlcGxhY2UpIHtcclxuICAgICAgICAgICAgdGhpcyQxLnJlcGxhY2UodG8pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcyQxLnB1c2godG8pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBjb25maXJtIHRyYW5zaXRpb24gYW5kIHBhc3Mgb24gdGhlIHZhbHVlXHJcbiAgICAgICAgICBuZXh0KHRvKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBhYm9ydChlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwb3N0RW50ZXJDYnMgPSBbXTtcclxuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xyXG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcclxuICAgIC8vIGV4dHJhY3RpbmcgaW4tY29tcG9uZW50IGVudGVyIGd1YXJkc1xyXG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcclxuICAgIHZhciBxdWV1ZSA9IGVudGVyR3VhcmRzLmNvbmNhdCh0aGlzJDEucm91dGVyLnJlc29sdmVIb29rcyk7XHJcbiAgICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xyXG4gICAgICAgIHJldHVybiBhYm9ydCgpXHJcbiAgICAgIH1cclxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xyXG4gICAgICBvbkNvbXBsZXRlKHJvdXRlKTtcclxuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XHJcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHBvc3RFbnRlckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYigpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5IaXN0b3J5LnByb3RvdHlwZS51cGRhdGVSb3V0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVJvdXRlIChyb3V0ZSkge1xyXG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xyXG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xyXG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XHJcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xyXG4gIGlmICghYmFzZSkge1xyXG4gICAgaWYgKGluQnJvd3Nlcikge1xyXG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcclxuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcclxuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XHJcbiAgICAgIC8vIHN0cmlwIGZ1bGwgVVJMIG9yaWdpblxyXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teXFwvXSsvLCAnJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiYXNlID0gJy8nO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcclxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xyXG4gICAgYmFzZSA9ICcvJyArIGJhc2U7XHJcbiAgfVxyXG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxyXG4gIHJldHVybiBiYXNlLnJlcGxhY2UoL1xcLyQvLCAnJylcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXVlIChcclxuICBjdXJyZW50LFxyXG4gIG5leHRcclxuKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XHJcbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICBpZiAoY3VycmVudFtpXSAhPT0gbmV4dFtpXSkge1xyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgdXBkYXRlZDogbmV4dC5zbGljZSgwLCBpKSxcclxuICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcclxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBleHRyYWN0R3VhcmRzIChcclxuICByZWNvcmRzLFxyXG4gIG5hbWUsXHJcbiAgYmluZCxcclxuICByZXZlcnNlXHJcbikge1xyXG4gIHZhciBndWFyZHMgPSBmbGF0TWFwQ29tcG9uZW50cyhyZWNvcmRzLCBmdW5jdGlvbiAoZGVmLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSkge1xyXG4gICAgdmFyIGd1YXJkID0gZXh0cmFjdEd1YXJkKGRlZiwgbmFtZSk7XHJcbiAgICBpZiAoZ3VhcmQpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZ3VhcmQpXHJcbiAgICAgICAgPyBndWFyZC5tYXAoZnVuY3Rpb24gKGd1YXJkKSB7IHJldHVybiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSk7IH0pXHJcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcclxuICBkZWYsXHJcbiAga2V5XHJcbikge1xyXG4gIGlmICh0eXBlb2YgZGVmICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAvLyBleHRlbmQgbm93IHNvIHRoYXQgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZC5cclxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XHJcbiAgfVxyXG4gIHJldHVybiBkZWYub3B0aW9uc1trZXldXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RMZWF2ZUd1YXJkcyAoZGVhY3RpdmF0ZWQpIHtcclxuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xyXG4gIHJldHVybiBleHRyYWN0R3VhcmRzKHVwZGF0ZWQsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIGJpbmRHdWFyZClcclxufVxyXG5cclxuZnVuY3Rpb24gYmluZEd1YXJkIChndWFyZCwgaW5zdGFuY2UpIHtcclxuICBpZiAoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xyXG4gICAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXHJcbiAgYWN0aXZhdGVkLFxyXG4gIGNicyxcclxuICBpc1ZhbGlkXHJcbikge1xyXG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlRW50ZXInLCBmdW5jdGlvbiAoZ3VhcmQsIF8sIG1hdGNoLCBrZXkpIHtcclxuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxyXG4gIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJpbmRFbnRlckd1YXJkIChcclxuICBndWFyZCxcclxuICBtYXRjaCxcclxuICBrZXksXHJcbiAgY2JzLFxyXG4gIGlzVmFsaWRcclxuKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlRW50ZXJHdWFyZCAodG8sIGZyb20sIG5leHQpIHtcclxuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgIG5leHQoY2IpO1xyXG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgLy8gIzc1MFxyXG4gICAgICAgICAgLy8gaWYgYSByb3V0ZXItdmlldyBpcyB3cmFwcGVkIHdpdGggYW4gb3V0LWluIHRyYW5zaXRpb24sXHJcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXHJcbiAgICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcG9sbCBmb3IgcmVnaXN0cmF0aW9uIHVudGlsIGN1cnJlbnQgcm91dGVcclxuICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB2YWxpZC5cclxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvbGwgKFxyXG4gIGNiLCAvLyBzb21laG93IGZsb3cgY2Fubm90IGluZmVyIHRoaXMgaXMgYSBmdW5jdGlvblxyXG4gIGluc3RhbmNlcyxcclxuICBrZXksXHJcbiAgaXNWYWxpZFxyXG4pIHtcclxuICBpZiAoaW5zdGFuY2VzW2tleV0pIHtcclxuICAgIGNiKGluc3RhbmNlc1trZXldKTtcclxuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHBvbGwoY2IsIGluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcclxuICAgIH0sIDE2KTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcbnZhciBIVE1MNUhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcclxuICBmdW5jdGlvbiBIVE1MNUhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XHJcblxyXG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xyXG5cclxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcclxuICAgICAgc2V0dXBTY3JvbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xyXG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldExvY2F0aW9uKHRoaXMkMS5iYXNlKSwgZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xyXG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmICggSGlzdG9yeSQkMSApIEhUTUw1SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xyXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XHJcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhUTUw1SGlzdG9yeTtcclxuXHJcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XHJcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcclxuICB9O1xyXG5cclxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgIHB1c2hTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xyXG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xyXG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xyXG4gICAgfSwgb25BYm9ydCk7XHJcbiAgfTtcclxuXHJcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xyXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICByZXBsYWNlU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcclxuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcclxuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcclxuICAgIH0sIG9uQWJvcnQpO1xyXG4gIH07XHJcblxyXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XHJcbiAgICBpZiAoZ2V0TG9jYXRpb24odGhpcy5iYXNlKSAhPT0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoKSB7XHJcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XHJcbiAgICAgIHB1c2ggPyBwdXNoU3RhdGUoY3VycmVudCkgOiByZXBsYWNlU3RhdGUoY3VycmVudCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xyXG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcclxuICB9O1xyXG5cclxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xyXG59KEhpc3RvcnkpKTtcclxuXHJcbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XHJcbiAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgaWYgKGJhc2UgJiYgcGF0aC5pbmRleE9mKGJhc2UpID09PSAwKSB7XHJcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XHJcbiAgfVxyXG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcbnZhciBIYXNoSGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xyXG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XHJcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcclxuICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcclxuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBlbnN1cmVTbGFzaCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcclxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XHJcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaEhpc3Rvcnk7XHJcblxyXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xyXG4gIC8vIHRvIGF2b2lkIHRoZSBoYXNoY2hhbmdlIGxpc3RlbmVyIGJlaW5nIGZpcmVkIHRvbyBlYXJseVxyXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHtcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcclxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcclxuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xyXG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xyXG4gICAgfSwgb25BYm9ydCk7XHJcbiAgfTtcclxuXHJcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xyXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XHJcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XHJcbiAgICB9LCBvbkFib3J0KTtcclxuICB9O1xyXG5cclxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xyXG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XHJcbiAgfTtcclxuXHJcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xyXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuZnVsbFBhdGg7XHJcbiAgICBpZiAoZ2V0SGFzaCgpICE9PSBjdXJyZW50KSB7XHJcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xyXG4gICAgcmV0dXJuIGdldEhhc2goKVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBIYXNoSGlzdG9yeTtcclxufShIaXN0b3J5KSk7XHJcblxyXG5mdW5jdGlvbiBjaGVja0ZhbGxiYWNrIChiYXNlKSB7XHJcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XHJcbiAgaWYgKCEvXlxcLyMvLnRlc3QobG9jYXRpb24pKSB7XHJcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcclxuICAgICAgY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcclxuICB2YXIgcGF0aCA9IGdldEhhc2goKTtcclxuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xyXG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcclxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxyXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XHJcbiAgdmFyIGluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XHJcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zbGljZShpbmRleCArIDEpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XHJcbiAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xyXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XHJcbiAgdmFyIGkgPSBocmVmLmluZGV4T2YoJyMnKTtcclxuICB2YXIgYmFzZSA9IGkgPj0gMCA/IGhyZWYuc2xpY2UoMCwgaSkgOiBocmVmO1xyXG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKChiYXNlICsgXCIjXCIgKyBwYXRoKSk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcbnZhciBBYnN0cmFjdEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcclxuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xyXG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XHJcbiAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICB0aGlzLmluZGV4ID0gLTE7XHJcbiAgfVxyXG5cclxuICBpZiAoIEhpc3RvcnkkJDEgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcclxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xyXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEhpc3Rvcnk7XHJcblxyXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXggKyAxKS5jb25jYXQocm91dGUpO1xyXG4gICAgICB0aGlzJDEuaW5kZXgrKztcclxuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcclxuICAgIH0sIG9uQWJvcnQpO1xyXG4gIH07XHJcblxyXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XHJcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XHJcbiAgICB9LCBvbkFib3J0KTtcclxuICB9O1xyXG5cclxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHZhciB0YXJnZXRJbmRleCA9IHRoaXMuaW5kZXggKyBuO1xyXG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0aGlzLnN0YWNrLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHZhciByb3V0ZSA9IHRoaXMuc3RhY2tbdGFyZ2V0SW5kZXhdO1xyXG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcclxuICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcclxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50LmZ1bGxQYXRoIDogJy8nXHJcbiAgfTtcclxuXHJcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKCkge1xyXG4gICAgLy8gbm9vcFxyXG4gIH07XHJcblxyXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XHJcbn0oSGlzdG9yeSkpO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XHJcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XHJcblxyXG4gIHRoaXMuYXBwID0gbnVsbDtcclxuICB0aGlzLmFwcHMgPSBbXTtcclxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcclxuICB0aGlzLnJlc29sdmVIb29rcyA9IFtdO1xyXG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xyXG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10sIHRoaXMpO1xyXG5cclxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XHJcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGUgJiYgb3B0aW9ucy5mYWxsYmFjayAhPT0gZmFsc2U7XHJcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcclxuICAgIG1vZGUgPSAnaGFzaCc7XHJcbiAgfVxyXG4gIGlmICghaW5Ccm93c2VyKSB7XHJcbiAgICBtb2RlID0gJ2Fic3RyYWN0JztcclxuICB9XHJcbiAgdGhpcy5tb2RlID0gbW9kZTtcclxuXHJcbiAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICBjYXNlICdoaXN0b3J5JzpcclxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnaGFzaCc6XHJcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIHRoaXMuZmFsbGJhY2spO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxyXG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XHJcbiAgICAgIGJyZWFrXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcclxuICAgICAgfVxyXG4gIH1cclxufTtcclxuXHJcbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGN1cnJlbnRSb3V0ZToge30gfTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXHJcbiAgcmF3LFxyXG4gIGN1cnJlbnQsXHJcbiAgcmVkaXJlY3RlZEZyb21cclxuKSB7XHJcbiAgcmV0dXJuIHRoaXMubWF0Y2hlci5tYXRjaChyYXcsIGN1cnJlbnQsIHJlZGlyZWN0ZWRGcm9tKVxyXG59O1xyXG5cclxucHJvdG90eXBlQWNjZXNzb3JzLmN1cnJlbnRSb3V0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydChcclxuICAgIGluc3RhbGwuaW5zdGFsbGVkLFxyXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXHJcbiAgICBcImJlZm9yZSBjcmVhdGluZyByb290IGluc3RhbmNlLlwiXHJcbiAgKTtcclxuXHJcbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcclxuXHJcbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuICBpZiAodGhpcy5hcHApIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdGhpcy5hcHAgPSBhcHA7XHJcblxyXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xyXG5cclxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xyXG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XHJcbiAgfSBlbHNlIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSGFzaEhpc3RvcnkpIHtcclxuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaGlzdG9yeS5zZXR1cExpc3RlbmVycygpO1xyXG4gICAgfTtcclxuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxyXG4gICAgICBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpLFxyXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lcixcclxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAocm91dGUpIHtcclxuICAgIHRoaXMkMS5hcHBzLmZvckVhY2goZnVuY3Rpb24gKGFwcCkge1xyXG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XHJcbiAgICB9KTtcclxuICB9KTtcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uIGJlZm9yZUVhY2ggKGZuKSB7XHJcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XHJcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLnJlc29sdmVIb29rcywgZm4pXHJcbn07XHJcblxyXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uIGFmdGVyRWFjaCAoZm4pIHtcclxuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYWZ0ZXJIb29rcywgZm4pXHJcbn07XHJcblxyXG5WdWVSb3V0ZXIucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xyXG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcclxuICB0aGlzLmhpc3Rvcnkub25FcnJvcihlcnJvckNiKTtcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XHJcbiAgdGhpcy5oaXN0b3J5LnB1c2gobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcclxuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XHJcbn07XHJcblxyXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcclxuICB0aGlzLmhpc3RvcnkuZ28obik7XHJcbn07XHJcblxyXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcclxuICB0aGlzLmdvKC0xKTtcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKCkge1xyXG4gIHRoaXMuZ28oMSk7XHJcbn07XHJcblxyXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XHJcbiAgdmFyIHJvdXRlID0gdG9cclxuICAgID8gdG8ubWF0Y2hlZFxyXG4gICAgICA/IHRvXHJcbiAgICAgIDogdGhpcy5yZXNvbHZlKHRvKS5yb3V0ZVxyXG4gICAgOiB0aGlzLmN1cnJlbnRSb3V0ZTtcclxuICBpZiAoIXJvdXRlKSB7XHJcbiAgICByZXR1cm4gW11cclxuICB9XHJcbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHJldHVybiBtLmNvbXBvbmVudHNba2V5XVxyXG4gICAgfSlcclxuICB9KSlcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKFxyXG4gIHRvLFxyXG4gIGN1cnJlbnQsXHJcbiAgYXBwZW5kXHJcbikge1xyXG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKFxyXG4gICAgdG8sXHJcbiAgICBjdXJyZW50IHx8IHRoaXMuaGlzdG9yeS5jdXJyZW50LFxyXG4gICAgYXBwZW5kLFxyXG4gICAgdGhpc1xyXG4gICk7XHJcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XHJcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XHJcbiAgdmFyIGJhc2UgPSB0aGlzLmhpc3RvcnkuYmFzZTtcclxuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcclxuICAgIHJvdXRlOiByb3V0ZSxcclxuICAgIGhyZWY6IGhyZWYsXHJcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcclxuICAgIHJlc29sdmVkOiByb3V0ZVxyXG4gIH1cclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUuYWRkUm91dGVzID0gZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcclxuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XHJcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xyXG4gICAgdGhpcy5oaXN0b3J5LnRyYW5zaXRpb25Ubyh0aGlzLmhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xyXG4gIH1cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcclxuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVySG9vayAobGlzdCwgZm4pIHtcclxuICBsaXN0LnB1c2goZm4pO1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaSA9IGxpc3QuaW5kZXhPZihmbik7XHJcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xyXG4gIHZhciBwYXRoID0gbW9kZSA9PT0gJ2hhc2gnID8gJyMnICsgZnVsbFBhdGggOiBmdWxsUGF0aDtcclxuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXHJcbn1cclxuXHJcblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcclxuVnVlUm91dGVyLnZlcnNpb24gPSAnMi43LjAnO1xyXG5cclxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XHJcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVnVlUm91dGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_home_vue__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_70421602_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_home_vue__ = __webpack_require__(19);\nvar disposed = false\nvar normalizeComponent = __webpack_require__(0)\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_home_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_70421602_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_home_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src\\\\views\\\\home.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] home.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-70421602\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-70421602\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaG9tZS52dWU/YWRiNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vaG9tZS52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTcwNDIxNjAyXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2hvbWUudnVlXCJcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcdmlld3NcXFxcaG9tZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGhvbWUudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTcwNDIxNjAyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNzA0MjE2MDJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmlld3MvaG9tZS52dWVcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n    name: 'indexP',\n    data() {\n        return {\n            todos: [{ text: 'Learn JavaScript' }, { text: 'Learn Vue' }, { text: 'Build something awesome' }]\n        };\n    },\n    methods: {\n        eClick() {\n            console.log(9999);\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaG9tZS52dWU/NmVlZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFZQTtVQUVBO1dBQ0E7O21CQUVBLFNBQ0EsOEJBQ0EsdUJBR0E7QUFOQTtBQU9BOztpQkFFQTt3QkFDQTtBQUVBO0FBSkE7QUFYQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXY+XHJcbiAgICAgICAgPG9sPlxyXG4gICAgICAgICAgICA8bGkgdi1mb3I9XCJ0b2RvIGluIHRvZG9zXCI+XHJcbiAgICAgICAgICAgICAgICB7eyB0b2RvLnRleHQgfX1cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICA8L29sPlxyXG4gICAgICAgIDxidXR0b24gQGNsaWNrPVwiZUNsaWNrKClcIj7kuovku7Y8L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbmFtZTogJ2luZGV4UCcsXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvZG9zOiBbXHJcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdMZWFybiBKYXZhU2NyaXB0JyB9LFxyXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnTGVhcm4gVnVlJyB9LFxyXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnQnVpbGQgc29tZXRoaW5nIGF3ZXNvbWUnIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgZUNsaWNrKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyg5OTk5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGhvbWUudnVlP2JlMDYyZmI0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", [\n    _c(\n      \"ol\",\n      _vm._l(_vm.todos, function(todo) {\n        return _c(\"li\", [\n          _vm._v(\"\\n            \" + _vm._s(todo.text) + \"\\n        \")\n        ])\n      })\n    ),\n    _vm._v(\" \"),\n    _c(\n      \"button\",\n      {\n        on: {\n          click: function($event) {\n            _vm.eClick()\n          }\n        }\n      },\n      [_vm._v(\"\")]\n    )\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-70421602\", esExports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaG9tZS52dWU/YjdmMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgW1xuICAgIF9jKFxuICAgICAgXCJvbFwiLFxuICAgICAgX3ZtLl9sKF92bS50b2RvcywgZnVuY3Rpb24odG9kbykge1xuICAgICAgICByZXR1cm4gX2MoXCJsaVwiLCBbXG4gICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgXCIgKyBfdm0uX3ModG9kby50ZXh0KSArIFwiXFxuICAgICAgICBcIilcbiAgICAgICAgXSlcbiAgICAgIH0pXG4gICAgKSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFxuICAgICAgXCJidXR0b25cIixcbiAgICAgIHtcbiAgICAgICAgb246IHtcbiAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBfdm0uZUNsaWNrKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbX3ZtLl92KFwi5LqL5Lu2XCIpXVxuICAgIClcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuZXhwb3J0IGRlZmF1bHQgZXNFeHBvcnRzXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi03MDQyMTYwMlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTcwNDIxNjAyXCIsXCJoYXNTY29wZWRcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL3ZpZXdzL2hvbWUudnVlXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_template_compiler_index_id_data_v_66f3da0c_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_about_vue__ = __webpack_require__(21);\nvar disposed = false\nvar normalizeComponent = __webpack_require__(0)\n/* script */\nvar __vue_script__ = null\n/* template */\n\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_template_compiler_index_id_data_v_66f3da0c_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_about_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src\\\\views\\\\about.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] about.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-66f3da0c\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-66f3da0c\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYWJvdXQudnVlPzNmMjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG52YXIgX192dWVfc2NyaXB0X18gPSBudWxsXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IF9fdnVlX3RlbXBsYXRlX18gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNjZmM2RhMGNcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYWJvdXQudnVlXCJcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcdmlld3NcXFxcYWJvdXQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBhYm91dC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNjZmM2RhMGNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi02NmYzZGEwY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9hYm91dC52dWVcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", [_vm._v(\"about\")])\n}\nvar staticRenderFns = []\nrender._withStripped = true\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-66f3da0c\", esExports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYWJvdXQudnVlPzdkY2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgW192bS5fdihcImFib3V0XCIpXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuZXhwb3J0IGRlZmF1bHQgZXNFeHBvcnRzXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi02NmYzZGEwY1wiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTY2ZjNkYTBjXCIsXCJoYXNTY29wZWRcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL3ZpZXdzL2Fib3V0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(23);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {\"hmr\":true}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(24)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./base.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./base.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3N0eWxlcy9iYXNlLmNzcz9mMGMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jhc2UuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jhc2UuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jhc2UuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hc3NldHMvc3R5bGVzL2Jhc2UuY3NzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(3)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"h1{\\r\\n    color: #999;\\r\\n}\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3N0eWxlcy9iYXNlLmNzcz9kNGYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsNEJBQTZCLG9CQUFvQixLQUFLOztBQUV0RCIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImgxe1xcclxcbiAgICBjb2xvcjogIzk5OTtcXHJcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL3NyYy9hc3NldHMvc3R5bGVzL2Jhc2UuY3NzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\nvar stylesInDom = {};\r\n\r\nvar\tmemoize = function (fn) {\r\n\tvar memo;\r\n\r\n\treturn function () {\r\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\treturn memo;\r\n\t};\r\n};\r\n\r\nvar isOldIE = memoize(function () {\r\n\t// Test for IE <= 9 as proposed by Browserhacks\r\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\r\n\t// Tests for existence of standard globals is to allow style-loader\r\n\t// to operate correctly into non-standard environments\r\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\r\n\treturn window && document && document.all && !window.atob;\r\n});\r\n\r\nvar getElement = (function (fn) {\r\n\tvar memo = {};\r\n\r\n\treturn function(selector) {\r\n\t\tif (typeof memo[selector] === \"undefined\") {\r\n\t\t\tvar styleTarget = fn.call(this, selector);\r\n\t\t\t// Special case to return head of iframe instead of iframe itself\r\n\t\t\tif (styleTarget instanceof window.HTMLIFrameElement) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\r\n\t\t\t\t\t// due to cross-origin restrictions\r\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\r\n\t\t\t\t} catch(e) {\r\n\t\t\t\t\tstyleTarget = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmemo[selector] = styleTarget;\r\n\t\t}\r\n\t\treturn memo[selector]\r\n\t};\r\n})(function (target) {\r\n\treturn document.querySelector(target)\r\n});\r\n\r\nvar singleton = null;\r\nvar\tsingletonCounter = 0;\r\nvar\tstylesInsertedAtTop = [];\r\n\r\nvar\tfixUrls = __webpack_require__(25);\r\n\r\nmodule.exports = function(list, options) {\r\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\r\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\r\n\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (!options.singleton) options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the <head> element\r\n\tif (!options.insertInto) options.insertInto = \"head\";\r\n\r\n\t// By default, add <style> tags to the bottom of the target\r\n\tif (!options.insertAt) options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list, options);\r\n\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update (newList) {\r\n\t\tvar mayRemove = [];\r\n\r\n\t\tfor (var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList, options);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\r\n\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};\r\n\r\nfunction addStylesToDom (styles, options) {\r\n\tfor (var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles (list, options) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\r\n\tfor (var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = options.base ? item[0] + options.base : item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\r\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse newStyles[id].parts.push(part);\r\n\t}\r\n\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement (options, style) {\r\n\tvar target = getElement(options.insertInto)\r\n\r\n\tif (!target) {\r\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\r\n\t}\r\n\r\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\r\n\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif (!lastStyleElementInsertedAtTop) {\r\n\t\t\ttarget.insertBefore(style, target.firstChild);\r\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\ttarget.appendChild(style);\r\n\t\t}\r\n\t\tstylesInsertedAtTop.push(style);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\ttarget.appendChild(style);\r\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\r\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\r\n\t\ttarget.insertBefore(style, nextSibling);\r\n\t} else {\r\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement (style) {\r\n\tif (style.parentNode === null) return false;\r\n\tstyle.parentNode.removeChild(style);\r\n\r\n\tvar idx = stylesInsertedAtTop.indexOf(style);\r\n\tif(idx >= 0) {\r\n\t\tstylesInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement (options) {\r\n\tvar style = document.createElement(\"style\");\r\n\r\n\toptions.attrs.type = \"text/css\";\r\n\r\n\taddAttrs(style, options.attrs);\r\n\tinsertStyleElement(options, style);\r\n\r\n\treturn style;\r\n}\r\n\r\nfunction createLinkElement (options) {\r\n\tvar link = document.createElement(\"link\");\r\n\r\n\toptions.attrs.type = \"text/css\";\r\n\toptions.attrs.rel = \"stylesheet\";\r\n\r\n\taddAttrs(link, options.attrs);\r\n\tinsertStyleElement(options, link);\r\n\r\n\treturn link;\r\n}\r\n\r\nfunction addAttrs (el, attrs) {\r\n\tObject.keys(attrs).forEach(function (key) {\r\n\t\tel.setAttribute(key, attrs[key]);\r\n\t});\r\n}\r\n\r\nfunction addStyle (obj, options) {\r\n\tvar style, update, remove, result;\r\n\r\n\t// If a transform function was defined, run it on the css\r\n\tif (options.transform && obj.css) {\r\n\t    result = options.transform(obj.css);\r\n\r\n\t    if (result) {\r\n\t    \t// If transform returns a value, use that instead of the original css.\r\n\t    \t// This allows running runtime transformations on the css.\r\n\t    \tobj.css = result;\r\n\t    } else {\r\n\t    \t// If the transform function returns a falsy value, don't add this css.\r\n\t    \t// This allows conditional loading of css\r\n\t    \treturn function() {\r\n\t    \t\t// noop\r\n\t    \t};\r\n\t    }\r\n\t}\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\r\n\t\tstyle = singleton || (singleton = createStyleElement(options));\r\n\r\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\r\n\r\n\t} else if (\r\n\t\tobj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\"\r\n\t) {\r\n\t\tstyle = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, style, options);\r\n\t\tremove = function () {\r\n\t\t\tremoveStyleElement(style);\r\n\r\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyle = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, style);\r\n\t\tremove = function () {\r\n\t\t\tremoveStyleElement(style);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle (newObj) {\r\n\t\tif (newObj) {\r\n\t\t\tif (\r\n\t\t\t\tnewObj.css === obj.css &&\r\n\t\t\t\tnewObj.media === obj.media &&\r\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\r\n\t\t\t) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag (style, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (style.styleSheet) {\r\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = style.childNodes;\r\n\r\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\r\n\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyle.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag (style, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyle.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(style.styleSheet) {\r\n\t\tstyle.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(style.firstChild) {\r\n\t\t\tstyle.removeChild(style.firstChild);\r\n\t\t}\r\n\r\n\t\tstyle.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink (link, options, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\t/*\r\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\r\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\r\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\r\n\t\tdirectly\r\n\t*/\r\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\r\n\r\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\r\n\t\tcss = fixUrls(css);\r\n\t}\r\n\r\n\tif (sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = link.href;\r\n\r\n\tlink.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/MzEzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5cclxudmFyIHN0eWxlc0luRG9tID0ge307XHJcblxyXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcclxuXHR2YXIgbWVtbztcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRyZXR1cm4gbWVtbztcclxuXHR9O1xyXG59O1xyXG5cclxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xyXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcclxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXHJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXHJcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XHJcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xyXG59KTtcclxuXHJcbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xyXG5cdHZhciBtZW1vID0ge307XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcclxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcclxuXHRcdFx0aWYgKHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXHJcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xyXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcclxuXHRcdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBzdHlsZVRhcmdldDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxyXG5cdH07XHJcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXHJcbn0pO1xyXG5cclxudmFyIHNpbmdsZXRvbiA9IG51bGw7XHJcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XHJcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xyXG5cclxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XHJcblxyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcclxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XHJcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcclxuXHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblxyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblxyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblxyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcclxuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXHJcblxyXG5cdGlmICghdGFyZ2V0KSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcclxuXHR9XHJcblxyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcclxuXHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xyXG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcclxuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcclxuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xyXG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcclxuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XHJcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcclxuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcclxuXHJcblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblxyXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHJcblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XHJcblxyXG5cdHJldHVybiBzdHlsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcclxuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cclxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHJcblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xyXG5cclxuXHRyZXR1cm4gbGluaztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xyXG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xyXG5cclxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3NcclxuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xyXG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcclxuXHJcblx0ICAgIGlmIChyZXN1bHQpIHtcclxuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXHJcblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxyXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cclxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xyXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHQgICAgXHRcdC8vIG5vb3BcclxuXHQgICAgXHR9O1xyXG5cdCAgICB9XHJcblx0fVxyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cclxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xyXG5cclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHJcblx0fSBlbHNlIGlmIChcclxuXHRcdG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxyXG5cdCkge1xyXG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XHJcblxyXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xyXG5cdFx0aWYgKG5ld09iaikge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxyXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXHJcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblxyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xyXG5cclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0LypcclxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxyXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcclxuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxyXG5cdFx0ZGlyZWN0bHlcclxuXHQqL1xyXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xyXG5cclxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcclxuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcclxuXHR9XHJcblxyXG5cdGlmIChzb3VyY2VNYXApIHtcclxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XHJcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XHJcblx0fVxyXG5cclxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcclxuXHJcblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcclxuXHJcblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports) {

eval("\r\n/**\r\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\r\n * embed the css on the page. This breaks all relative urls because now they are relative to a\r\n * bundle instead of the current page.\r\n *\r\n * One solution is to only use full urls, but that may be impossible.\r\n *\r\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\r\n *\r\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\r\n *\r\n */\r\n\r\nmodule.exports = function (css) {\r\n  // get current location\r\n  var location = typeof window !== \"undefined\" && window.location;\r\n\r\n  if (!location) {\r\n    throw new Error(\"fixUrls requires window.location\");\r\n  }\r\n\r\n\t// blank or null?\r\n\tif (!css || typeof css !== \"string\") {\r\n\t  return css;\r\n  }\r\n\r\n  var baseUrl = location.protocol + \"//\" + location.host;\r\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\r\n\r\n\t// convert each url(...)\r\n\t/*\r\n\tThis regular expression is just a way to recursively match brackets within\r\n\ta string.\r\n\r\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\r\n\t   (  = Start a capturing group\r\n\t     (?:  = Start a non-capturing group\r\n\t         [^)(]  = Match anything that isn't a parentheses\r\n\t         |  = OR\r\n\t         \\(  = Match a start parentheses\r\n\t             (?:  = Start another non-capturing groups\r\n\t                 [^)(]+  = Match anything that isn't a parentheses\r\n\t                 |  = OR\r\n\t                 \\(  = Match a start parentheses\r\n\t                     [^)(]*  = Match anything that isn't a parentheses\r\n\t                 \\)  = Match a end parentheses\r\n\t             )  = End Group\r\n              *\\) = Match anything and then a close parens\r\n          )  = Close non-capturing group\r\n          *  = Match anything\r\n       )  = Close capturing group\r\n\t \\)  = Match a close parens\r\n\r\n\t /gi  = Get all matches, not the first.  Be case insensitive.\r\n\t */\r\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\r\n\t\t// strip quotes (if they exist)\r\n\t\tvar unquotedOrigUrl = origUrl\r\n\t\t\t.trim()\r\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\r\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\r\n\r\n\t\t// already a full url? no change\r\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\r\n\t\t  return fullMatch;\r\n\t\t}\r\n\r\n\t\t// convert the url to a full url\r\n\t\tvar newUrl;\r\n\r\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\r\n\t\t  \t//TODO: should we add protocol?\r\n\t\t\tnewUrl = unquotedOrigUrl;\r\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\r\n\t\t\t// path should be relative to the base url\r\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\r\n\t\t} else {\r\n\t\t\t// path should be relative to current directory\r\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\r\n\t\t}\r\n\r\n\t\t// send back the fixed url(...)\r\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\r\n\t});\r\n\r\n\t// send back the fixed css\r\n\treturn fixedCss;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzPzk4OTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG4vKipcclxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cclxuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxyXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxyXG4gKlxyXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cclxuICpcclxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxyXG4gKlxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xyXG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXHJcbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XHJcblxyXG4gIGlmICghbG9jYXRpb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xyXG4gIH1cclxuXHJcblx0Ly8gYmxhbmsgb3IgbnVsbD9cclxuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XHJcblx0ICByZXR1cm4gY3NzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XHJcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XHJcblxyXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxyXG5cdC8qXHJcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cclxuXHRhIHN0cmluZy5cclxuXHJcblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xyXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcclxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcclxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcclxuXHQgICAgICAgICB8ICA9IE9SXHJcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcclxuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcclxuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcclxuXHQgICAgICAgICAgICAgICAgIHwgID0gT1JcclxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xyXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXHJcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXHJcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXHJcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcclxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcclxuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXHJcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xyXG5cclxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXHJcblx0ICovXHJcblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcclxuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcclxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXHJcblx0XHRcdC50cmltKClcclxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcclxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xyXG5cclxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXHJcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XHJcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcclxuXHRcdHZhciBuZXdVcmw7XHJcblxyXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcclxuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XHJcblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcclxuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XHJcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxyXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3RvcnlcclxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcclxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcclxuXHR9KTtcclxuXHJcblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3NcclxuXHRyZXR1cm4gZml4ZWRDc3M7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n");

/***/ })
/******/ ]);